
(function() {
var __main_module_name__ = "main";
var __resources__ = {};
function __imageResource(data) { var img = new Image(); img.src = data; return img; };
var FLIP_Y_AXIS = true;
var ENABLE_WEB_GL = false;
var SHOW_REDRAW_REGIONS = false;

__resources__["/__builtin__/event.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*global module exports require*/
/*jslint white: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true*/


/**
 * @namespace
 * Support for listening for and triggering events
 */
var event = {};

/**
 * @private
 * @ignore
 * Returns the event listener property of an object, creating it if it doesn't
 * already exist.
 *
 * @returns {Object}
 */
function getListeners(obj, eventName) {
    if (!obj.js_listeners_) {
        obj.js_listeners_ = {};
    }
    if (!eventName) {
        return obj.js_listeners_;
    }
    if (!obj.js_listeners_[eventName]) {
        obj.js_listeners_[eventName] = {};
    }
    return obj.js_listeners_[eventName];
}

/**
 * @private
 * @ignore
 * Keep track of the next ID for each new EventListener
 */
var eventID = 0;

/**
 * @class
 * Represents an event being listened to. You should not create instances of
 * this directly, it is instead returned by event.addListener
 *
 * @extends Object
 * 
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 */
event.EventListener = function (source, eventName, handler) {
    /**
     * Object to listen to for an event
     * @type Object 
     */
    this.source = source;
    
    /**
     * Name of the event to listen for
     * @type String
     */
    this.eventName = eventName;

    /**
     * Callback to fire when the event triggers
     * @type Function
     */
    this.handler = handler;

    /**
     * Unique ID number for this instance
     * @type Integer 
     */
    this.id = ++eventID;

    getListeners(source, eventName)[this.id] = this;
};

/**
 * Register an event listener
 *
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 *
 * @returns {event.EventListener} The event listener. Pass to removeListener to destroy it.
 */
event.addListener = function (source, eventName, handler) {
    return new event.EventListener(source, eventName, handler);
};

/**
 * Trigger an event. All listeners will be notified.
 *
 * @param {Object} source Object to trigger the event on
 * @param {String} eventName Name of the event to trigger
 */
event.trigger = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        args = Array.prototype.slice.call(arguments, 2),
        eventID,
        l;

    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            l = listeners[eventID];
            if (l) {
                l.handler.apply(undefined, args);
            }
        }
    }
};

/**
 * Remove a previously registered event listener
 *
 * @param {event.EventListener} listener EventListener to remove, as returned by event.addListener
 */
event.removeListener = function (listener) {
    delete getListeners(listener.source, listener.eventName)[listener.eventID];
};

/**
 * Remove a all event listeners for a given event
 *
 * @param {Object} source Object to remove listeners from
 * @param {String} eventName Name of event to remove listeners from
 */
event.clearListeners = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        eventID;


    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            var l = listeners[eventID];
            if (l) {
                event.removeListener(l);
            }
        }
    }
};

/**
 * Remove all event listeners on an object
 *
 * @param {Object} source Object to remove listeners from
 */
event.clearInstanceListeners = function (source, eventName) {
    var listeners = getListeners(source),
        eventID;

    for (eventName in listeners) {
        if (listeners.hasOwnProperty(eventName)) {
            var el = listeners[eventName];
            for (eventID in el) {
                if (el.hasOwnProperty(eventID)) {
                    var l = el[eventID];
                    if (l) {
                        event.removeListener(l);
                    }
                }
            }
        }
    }
};

module.exports = event;

}};
__resources__["/__builtin__/global.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event');


/**
 * @ignore
 */
function getAccessors(obj) {
    if (!obj.js_accessors_) {
        obj.js_accessors_ = {};
    }
    return obj.js_accessors_;
}

/**
 * @ignore
 */
function getBindings(obj) {
    if (!obj.js_bindings_) {
        obj.js_bindings_ = {};
    }
    return obj.js_bindings_;
}

/**
 * @ignore
 */
function addAccessor(obj, key, target, targetKey, noNotify) {
    getAccessors(obj)[key] = {
        key: targetKey,
        target: target
    };

    if (!noNotify) {
        obj.triggerChanged(key);
    }
}


/**
 * @ignore
 */
var objectID = 0;

/**
 * @class
 * A bindable object. Allows observing and binding to its properties.
 */
var BObject = function () {};
BObject.prototype = util.extend(BObject.prototype, /** @lends BObject# */{
    /**
     * Unique ID
     * @type Integer
     */
    _id: 0,
    

    /**
     * The constructor for subclasses. Overwrite this for any initalisation you
     * need to do.
     * @ignore
     */
    init: function () {},

    /**
     * Get a property from the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get
     * @returns {*} Value of the property
     */
    get: function (key) {
        var accessor = getAccessors(this)[key];
        if (accessor) {
            return accessor.target.get(accessor.key);
        } else {
            // Call getting function
            if (this['get_' + key]) {
                return this['get_' + key]();
            }

            return this[key];
        }
    },


    /**
     * Set a property on the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get
     * @param {*} value New value for the property
     */
    set: function (key, value) {
        var accessor = getAccessors(this)[key],
            oldVal = this.get(key);
        if (accessor) {
            accessor.target.set(accessor.key, value);
        } else {
            if (this['set_' + key]) {
                this['set_' + key](value);
            } else {
                this[key] = value;
            }
        }
        this.triggerChanged(key, oldVal);
    },

    /**
     * Set multiple propertys in one go
     *
     * @param {Object} kvp An Object where the key is a property name and the value is the value to assign to the property
     *
     * @example
     * var props = {
     *   monkey: 'ook',
     *   cat: 'meow',
     *   dog: 'woof'
     * };
     * foo.setValues(props);
     * console.log(foo.get('cat')); // Logs 'meow'
     */
    setValues: function (kvp) {
        for (var x in kvp) {
            if (kvp.hasOwnProperty(x)) {
                this.set(x, kvp[x]);
            }
        }
    },

    changed: function (key) {
    },

    /**
     * @private
     */
    notify: function (key, oldVal) {
        var accessor = getAccessors(this)[key];
        if (accessor) {
            accessor.target.notify(accessor.key, oldVal);
        }
    },

    /**
     * @private
     */
    triggerChanged: function(key, oldVal) {
        evt.trigger(this, key.toLowerCase() + '_changed', oldVal);
    },

    /**
     * Bind the value of a property on this object to that of another object so
     * they always have the same value. Setting the value on either object will update
     * the other too.
     *
     * @param {String} key Name of the property on this object that should be bound
     * @param {BOject} target Object to bind to
     * @param {String} [targetKey=key] Key on the target object to bind to
     * @param {Boolean} [noNotify=false] Set to true to prevent this object's property triggering a 'changed' event when adding the binding
     */
    bindTo: function (key, target, targetKey, noNotify) {
        targetKey = targetKey || key;
        var self = this;
        this.unbind(key);

        var oldVal = this.get(key);

        // When bound property changes, trigger a 'changed' event on this one too
        getBindings(this)[key] = evt.addListener(target, targetKey.toLowerCase() + '_changed', function (oldVal) {
            self.triggerChanged(key, oldVal);
        });

        addAccessor(this, key, target, targetKey, noNotify);
    },

    /**
     * Remove binding from a property which set setup using BObject#bindTo.
     *
     * @param {String} key Name of the property on this object to unbind
     */
    unbind: function (key) {
        var binding = getBindings(this)[key];
        if (!binding) {
            return;
        }

        delete getBindings(this)[key];
        evt.removeListener(binding);
        // Grab current value from bound property
        var val = this.get(key);
        delete getAccessors(this)[key];
        // Set bound value
        this[key] = val;
    },

    /**
     * Remove all bindings on this object
     */
    unbindAll: function () {
        var keys = [],
            bindings = getBindings(this);
        for (var k in bindings) {
            if (bindings.hasOwnProperty(k)) {
                this.unbind(k);
            }
        }
    },

    /**
     * Unique ID for this object
     * @getter id
     * @type Integer
     */
    get_id: function() {
        if (!this._id) {
            this._id = ++objectID;
        }

        return this._id;
    }
});


/**
 * Create a new instance of this object
 * @returns {BObject} New instance of this object
 */
BObject.create = function() {
    var ret = new this();
    ret.init.apply(ret, arguments);
    return ret;
};

/**
 * Create a new subclass by extending this one
 * @returns {Object} A new subclass of this object
 */
BObject.extend = function() {
    var newObj = function() {},
        args = [],
        i,
        x;

    // Copy 'class' methods
    for (x in this) {
        if (this.hasOwnProperty(x)) {
            newObj[x] = this[x];
        }
    }


    // Add given properties to the prototype
    newObj.prototype = util.beget(this.prototype);
    args.push(newObj.prototype);
    for (i = 0; i<arguments.length; i++) {
        args.push(arguments[i]);
    }
    util.extend.apply(null, args);

    newObj.superclass = this.prototype;
    // Create new instance
    return newObj;
};

/**
 * Get a property from the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @returns {*} Value of the property
 */
BObject.get = BObject.prototype.get;

/**
 * Set a property on the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @param {*} value New value for the property
 */
BObject.set = BObject.prototype.set;

var BArray = BObject.extend(/** @lends BArray# */{

    /**
     * @constructs 
     * A bindable array. Allows observing for changes made to its contents
     *
     * @extends BObject
     * @param {Array} [array=[]] A normal JS array to use for data
     */
    init: function (array) {
        this.array = array || [];
        this.set('length', this.array.length);
    },

    /**
     * Get an item
     *
     * @param {Integer} i Index to get item from
     * @returns {*} Value stored in the array at index 'i'
     */
    getAt: function (i) {
        return this.array[i];
    },

    /**
     * Set an item -- Overwrites any existing item at index
     *
     * @param {Integer} i Index to set item to
     * @param {*} value Value to assign to index
     */
    setAt: function (i, value) {
        var oldVal = this.array[i];
        this.array[i] = value;

        evt.trigger(this, 'set_at', i, oldVal);
    },

    /**
     * Insert a new item into the array without overwriting anything
     *
     * @param {Integer} i Index to insert item at
     * @param {*} value Value to insert
     */
    insertAt: function (i, value) {
        this.array.splice(i, 0, value);
        this.set('length', this.array.length);
        evt.trigger(this, 'insert_at', i);
    },

    /**
     * Remove item from the array and return it
     *
     * @param {Integer} i Index to remove
     * @returns {*} Value that was removed
     */
    removeAt: function (i) {
        var oldVal = this.array[i];
        this.array.splice(i, 1);
        this.set('length', this.array.length);
        evt.trigger(this, 'remove_at', i, oldVal);

        return oldVal;
    },

    /**
     * Get the internal Javascript Array instance
     *
     * @returns {Array} Internal Javascript Array
     */
    getArray: function () {
        return this.array;
    },

    /**
     * Append a value to the end of the array and return its new length
     *
     * @param {*} value Value to append to the array
     * @returns {Integer} New length of the array
     */
    push: function (value) {
        this.insertAt(this.array.length, value);
        return this.array.length;
    },

    /**
     * Remove value from the end of the array and return it
     *
     * @returns {*} Value that was removed
     */
    pop: function () {
        return this.removeAt(this.array.length - 1);
    }
});

exports.BObject = BObject;
exports.BArray = BArray;

}};
__resources__["/__builtin__/libs/base64.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * Thin wrapper around JXG's Base64 utils
 */

/** @ignore */
var JXG = require('JXGUtil');

/** @namespace */
var base64 = {
    /**
     * Decode a base64 encoded string into a binary string
     *
     * @param {String} input Base64 encoded data
     * @returns {String} Binary string
     */
    decode: function(input) {
        return JXG.Util.Base64.decode(input);
    },

    /**
     * Decode a base64 encoded string into a byte array
     *
     * @param {String} input Base64 encoded data
     * @returns {Integer[]} Array of bytes
     */
    decodeAsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = JXG.Util.Base64.decode(input),
            ar = [], i, j, len;

        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Encode a binary string into base64
     *
     * @param {String} input Binary string
     * @returns {String} Base64 encoded data
     */
    encode: function(input) {
        return JXG.Util.Base64.encode(input);
    }
};

module.exports = base64;

}};
__resources__["/__builtin__/libs/box2d.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
function extend(a, b) {
  for(var c in b) {
    a[c] = b[c]
  }
}
function isInstanceOf(obj, _constructor) {
  while(typeof obj === "object") {
    if(obj.constructor === _constructor) {
      return true
    }
    obj = obj._super
  }
  return false
}
;var b2BoundValues = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BoundValues.prototype.__constructor = function() {
  this.lowerValues = new Array;
  this.lowerValues[0] = 0;
  this.lowerValues[1] = 0;
  this.upperValues = new Array;
  this.upperValues[0] = 0;
  this.upperValues[1] = 0
};
b2BoundValues.prototype.__varz = function() {
};
b2BoundValues.prototype.lowerValues = null;
b2BoundValues.prototype.upperValues = null;var b2PairManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PairManager.prototype.__constructor = function() {
  this.m_pairs = new Array;
  this.m_pairBuffer = new Array;
  this.m_pairCount = 0;
  this.m_pairBufferCount = 0;
  this.m_freePair = null
};
b2PairManager.prototype.__varz = function() {
};
b2PairManager.prototype.AddPair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair != null) {
    return pair
  }
  if(this.m_freePair == null) {
    this.m_freePair = new b2Pair;
    this.m_pairs.push(this.m_freePair)
  }
  pair = this.m_freePair;
  this.m_freePair = pair.next;
  pair.proxy1 = proxy1;
  pair.proxy2 = proxy2;
  pair.status = 0;
  pair.userData = null;
  pair.next = null;
  proxy1.pairs[proxy2] = pair;
  proxy2.pairs[proxy1] = pair;
  ++this.m_pairCount;
  return pair
};
b2PairManager.prototype.RemovePair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair == null) {
    return null
  }
  var userData = pair.userData;
  delete proxy1.pairs[proxy2];
  delete proxy2.pairs[proxy1];
  pair.next = this.m_freePair;
  pair.proxy1 = null;
  pair.proxy2 = null;
  pair.userData = null;
  pair.status = 0;
  this.m_freePair = pair;
  --this.m_pairCount;
  return userData
};
b2PairManager.prototype.Find = function(proxy1, proxy2) {
  return proxy1.pairs[proxy2]
};
b2PairManager.prototype.ValidateBuffer = function() {
};
b2PairManager.prototype.ValidateTable = function() {
};
b2PairManager.prototype.Initialize = function(broadPhase) {
  this.m_broadPhase = broadPhase
};
b2PairManager.prototype.AddBufferedPair = function(proxy1, proxy2) {
  var pair = this.AddPair(proxy1, proxy2);
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.ClearRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.RemoveBufferedPair = function(proxy1, proxy2) {
  var pair = this.Find(proxy1, proxy2);
  if(pair == null) {
    return
  }
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.SetRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.Commit = function(callback) {
  var i = 0;
  var removeCount = 0;
  for(i = 0;i < this.m_pairBufferCount;++i) {
    var pair = this.m_pairBuffer[i];
    pair.ClearBuffered();
    var proxy1 = pair.proxy1;
    var proxy2 = pair.proxy2;
    if(pair.IsRemoved()) {
    }else {
      if(pair.IsFinal() == false) {
        callback(proxy1.userData, proxy2.userData)
      }
    }
  }
  this.m_pairBufferCount = 0;
  if(b2BroadPhase.s_validate) {
    this.ValidateTable()
  }
};
b2PairManager.prototype.m_broadPhase = null;
b2PairManager.prototype.m_pairs = null;
b2PairManager.prototype.m_freePair = null;
b2PairManager.prototype.m_pairCount = 0;
b2PairManager.prototype.m_pairBuffer = null;
b2PairManager.prototype.m_pairBufferCount = 0;var b2TimeStep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeStep.prototype.__constructor = function() {
};
b2TimeStep.prototype.__varz = function() {
};
b2TimeStep.prototype.Set = function(step) {
  this.dt = step.dt;
  this.inv_dt = step.inv_dt;
  this.positionIterations = step.positionIterations;
  this.velocityIterations = step.velocityIterations;
  this.warmStarting = step.warmStarting
};
b2TimeStep.prototype.dt = null;
b2TimeStep.prototype.inv_dt = null;
b2TimeStep.prototype.dtRatio = null;
b2TimeStep.prototype.velocityIterations = 0;
b2TimeStep.prototype.positionIterations = 0;
b2TimeStep.prototype.warmStarting = null;var b2Controller = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Controller.prototype.__constructor = function() {
};
b2Controller.prototype.__varz = function() {
};
b2Controller.prototype.Step = function(step) {
};
b2Controller.prototype.Draw = function(debugDraw) {
};
b2Controller.prototype.AddBody = function(body) {
  var edge = new b2ControllerEdge;
  edge.controller = this;
  edge.body = body;
  edge.nextBody = m_bodyList;
  edge.prevBody = null;
  m_bodyList = edge;
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge
  }
  m_bodyCount++;
  edge.nextController = body.m_controllerList;
  edge.prevController = null;
  body.m_controllerList = edge;
  if(edge.nextController) {
    edge.nextController.prevController = edge
  }
  body.m_controllerCount++
};
b2Controller.prototype.RemoveBody = function(body) {
  var edge = body.m_controllerList;
  while(edge && edge.controller != this) {
    edge = edge.nextController
  }
  if(edge.prevBody) {
    edge.prevBody.nextBody = edge.nextBody
  }
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge.prevBody
  }
  if(edge.nextController) {
    edge.nextController.prevController = edge.prevController
  }
  if(edge.prevController) {
    edge.prevController.nextController = edge.nextController
  }
  if(m_bodyList == edge) {
    m_bodyList = edge.nextBody
  }
  if(body.m_controllerList == edge) {
    body.m_controllerList = edge.nextController
  }
  body.m_controllerCount--;
  m_bodyCount--
};
b2Controller.prototype.Clear = function() {
  while(m_bodyList) {
    this.RemoveBody(m_bodyList.body)
  }
};
b2Controller.prototype.GetNext = function() {
  return this.m_next
};
b2Controller.prototype.GetWorld = function() {
  return this.m_world
};
b2Controller.prototype.GetBodyList = function() {
  return m_bodyList
};
b2Controller.prototype.m_next = null;
b2Controller.prototype.m_prev = null;
b2Controller.prototype.m_world = null;var b2GravityController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GravityController.prototype, b2Controller.prototype);
b2GravityController.prototype._super = b2Controller.prototype;
b2GravityController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2GravityController.prototype.__varz = function() {
};
b2GravityController.prototype.Step = function(step) {
  var i = null;
  var body1 = null;
  var p1 = null;
  var mass1 = 0;
  var j = null;
  var body2 = null;
  var p2 = null;
  var dx = 0;
  var dy = 0;
  var r2 = 0;
  var f = null;
  if(this.invSqr) {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }else {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }
};
b2GravityController.prototype.G = 1;
b2GravityController.prototype.invSqr = true;var b2DestructionListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DestructionListener.prototype.__constructor = function() {
};
b2DestructionListener.prototype.__varz = function() {
};
b2DestructionListener.prototype.SayGoodbyeJoint = function(joint) {
};
b2DestructionListener.prototype.SayGoodbyeFixture = function(fixture) {
};var b2ContactEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactEdge.prototype.__constructor = function() {
};
b2ContactEdge.prototype.__varz = function() {
};
b2ContactEdge.prototype.other = null;
b2ContactEdge.prototype.contact = null;
b2ContactEdge.prototype.prev = null;
b2ContactEdge.prototype.next = null;var b2EdgeChainDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2EdgeChainDef.prototype.__constructor = function() {
  this.vertexCount = 0;
  this.isALoop = true;
  this.vertices = []
};
b2EdgeChainDef.prototype.__varz = function() {
};
b2EdgeChainDef.prototype.vertices = null;
b2EdgeChainDef.prototype.vertexCount = null;
b2EdgeChainDef.prototype.isALoop = null;var b2Vec2 = function(x_, y_) {
  if(arguments.length == 2) {
    this.x = x_;
    this.y = y_
  }
};
b2Vec2.Make = function(x_, y_) {
  return new b2Vec2(x_, y_)
};
b2Vec2.prototype.SetZero = function() {
  this.x = 0;
  this.y = 0
};
b2Vec2.prototype.Set = function(x_, y_) {
  this.x = x_;
  this.y = y_
};
b2Vec2.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y
};
b2Vec2.prototype.GetNegative = function() {
  return new b2Vec2(-this.x, -this.y)
};
b2Vec2.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y
};
b2Vec2.prototype.Copy = function() {
  return new b2Vec2(this.x, this.y)
};
b2Vec2.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y
};
b2Vec2.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y
};
b2Vec2.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a
};
b2Vec2.prototype.MulM = function(A) {
  var tX = this.x;
  this.x = A.col1.x * tX + A.col2.x * this.y;
  this.y = A.col1.y * tX + A.col2.y * this.y
};
b2Vec2.prototype.MulTM = function(A) {
  var tX = b2Math.Dot(this, A.col1);
  this.y = b2Math.Dot(this, A.col2);
  this.x = tX
};
b2Vec2.prototype.CrossVF = function(s) {
  var tX = this.x;
  this.x = s * this.y;
  this.y = -s * tX
};
b2Vec2.prototype.CrossFV = function(s) {
  var tX = this.x;
  this.x = -s * this.y;
  this.y = s * tX
};
b2Vec2.prototype.MinV = function(b) {
  this.x = this.x < b.x ? this.x : b.x;
  this.y = this.y < b.y ? this.y : b.y
};
b2Vec2.prototype.MaxV = function(b) {
  this.x = this.x > b.x ? this.x : b.x;
  this.y = this.y > b.y ? this.y : b.y
};
b2Vec2.prototype.Abs = function() {
  if(this.x < 0) {
    this.x = -this.x
  }
  if(this.y < 0) {
    this.y = -this.y
  }
};
b2Vec2.prototype.Length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y)
};
b2Vec2.prototype.LengthSquared = function() {
  return this.x * this.x + this.y * this.y
};
b2Vec2.prototype.Normalize = function() {
  var length = Math.sqrt(this.x * this.x + this.y * this.y);
  if(length < Number.MIN_VALUE) {
    return 0
  }
  var invLength = 1 / length;
  this.x *= invLength;
  this.y *= invLength;
  return length
};
b2Vec2.prototype.IsValid = function() {
  return b2Math.IsValid(this.x) && b2Math.IsValid(this.y)
};
b2Vec2.prototype.x = 0;
b2Vec2.prototype.y = 0;var b2Vec3 = function(x, y, z) {
  if(arguments.length == 3) {
    this.x = x;
    this.y = y;
    this.z = z
  }
};
b2Vec3.prototype.SetZero = function() {
  this.x = this.y = this.z = 0
};
b2Vec3.prototype.Set = function(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z
};
b2Vec3.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z
};
b2Vec3.prototype.GetNegative = function() {
  return new b2Vec3(-this.x, -this.y, -this.z)
};
b2Vec3.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y;
  this.z = -this.z
};
b2Vec3.prototype.Copy = function() {
  return new b2Vec3(this.x, this.y, this.z)
};
b2Vec3.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y;
  this.z += v.z
};
b2Vec3.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y;
  this.z -= v.z
};
b2Vec3.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a;
  this.z *= a
};
b2Vec3.prototype.x = 0;
b2Vec3.prototype.y = 0;
b2Vec3.prototype.z = 0;var b2DistanceProxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceProxy.prototype.__constructor = function() {
};
b2DistanceProxy.prototype.__varz = function() {
};
b2DistanceProxy.prototype.Set = function(shape) {
  switch(shape.GetType()) {
    case b2Shape.e_circleShape:
      var circle = shape;
      this.m_vertices = new Array(1);
      this.m_vertices[0] = circle.m_p;
      this.m_count = 1;
      this.m_radius = circle.m_radius;
      break;
    case b2Shape.e_polygonShape:
      var polygon = shape;
      this.m_vertices = polygon.m_vertices;
      this.m_count = polygon.m_vertexCount;
      this.m_radius = polygon.m_radius;
      break;
    default:
      b2Settings.b2Assert(false)
  }
};
b2DistanceProxy.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2DistanceProxy.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2DistanceProxy.prototype.GetVertexCount = function() {
  return this.m_count
};
b2DistanceProxy.prototype.GetVertex = function(index) {
  b2Settings.b2Assert(0 <= index && index < this.m_count);
  return this.m_vertices[index]
};
b2DistanceProxy.prototype.m_vertices = null;
b2DistanceProxy.prototype.m_count = 0;
b2DistanceProxy.prototype.m_radius = null;var b2ContactFactory = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFactory.prototype.__constructor = function() {
};
b2ContactFactory.prototype.__varz = function() {
  this.InitializeRegisters()
};
b2ContactFactory.prototype.AddType = function(createFcn, destroyFcn, type1, type2) {
  this.m_registers[type1][type2].createFcn = createFcn;
  this.m_registers[type1][type2].destroyFcn = destroyFcn;
  this.m_registers[type1][type2].primary = true;
  if(type1 != type2) {
    this.m_registers[type2][type1].createFcn = createFcn;
    this.m_registers[type2][type1].destroyFcn = destroyFcn;
    this.m_registers[type2][type1].primary = false
  }
};
b2ContactFactory.prototype.InitializeRegisters = function() {
  this.m_registers = new Array(b2Shape.e_shapeTypeCount);
  for(var i = 0;i < b2Shape.e_shapeTypeCount;i++) {
    this.m_registers[i] = new Array(b2Shape.e_shapeTypeCount);
    for(var j = 0;j < b2Shape.e_shapeTypeCount;j++) {
      this.m_registers[i][j] = new b2ContactRegister
    }
  }
  this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
  this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
  this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape)
};
b2ContactFactory.prototype.Create = function(fixtureA, fixtureB) {
  var type1 = fixtureA.GetType();
  var type2 = fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  var c;
  if(reg.pool) {
    c = reg.pool;
    reg.pool = c.m_next;
    reg.poolCount--;
    c.Reset(fixtureA, fixtureB);
    return c
  }
  var createFcn = reg.createFcn;
  if(createFcn != null) {
    if(reg.primary) {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureA, fixtureB);
      return c
    }else {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureB, fixtureA);
      return c
    }
  }else {
    return null
  }
};
b2ContactFactory.prototype.Destroy = function(contact) {
  if(contact.m_manifold.m_pointCount > 0) {
    contact.m_fixtureA.m_body.SetAwake(true);
    contact.m_fixtureB.m_body.SetAwake(true)
  }
  var type1 = contact.m_fixtureA.GetType();
  var type2 = contact.m_fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  if(true) {
    reg.poolCount++;
    contact.m_next = reg.pool;
    reg.pool = contact
  }
  var destroyFcn = reg.destroyFcn;
  destroyFcn(contact, this.m_allocator)
};
b2ContactFactory.prototype.m_registers = null;
b2ContactFactory.prototype.m_allocator = null;var b2ConstantAccelController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantAccelController.prototype, b2Controller.prototype);
b2ConstantAccelController.prototype._super = b2Controller.prototype;
b2ConstantAccelController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantAccelController.prototype.__varz = function() {
  this.A = new b2Vec2(0, 0)
};
b2ConstantAccelController.prototype.Step = function(step) {
  var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y))
  }
};
b2ConstantAccelController.prototype.A = new b2Vec2(0, 0);var b2SeparationFunction = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SeparationFunction.prototype.__constructor = function() {
};
b2SeparationFunction.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_axis = new b2Vec2
};
b2SeparationFunction.e_points = 1;
b2SeparationFunction.e_faceA = 2;
b2SeparationFunction.e_faceB = 4;
b2SeparationFunction.prototype.Initialize = function(cache, proxyA, transformA, proxyB, transformB) {
  this.m_proxyA = proxyA;
  this.m_proxyB = proxyB;
  var count = cache.count;
  b2Settings.b2Assert(0 < count && count < 3);
  var localPointA;
  var localPointA1;
  var localPointA2;
  var localPointB;
  var localPointB1;
  var localPointB2;
  var pointAX;
  var pointAY;
  var pointBX;
  var pointBY;
  var normalX;
  var normalY;
  var tMat;
  var tVec;
  var s;
  var sgn;
  if(count == 1) {
    this.m_type = b2SeparationFunction.e_points;
    localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
    localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
    tVec = localPointA;
    tMat = transformA.R;
    pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = localPointB;
    tMat = transformB.R;
    pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    this.m_axis.x = pointBX - pointAX;
    this.m_axis.y = pointBY - pointAY;
    this.m_axis.Normalize()
  }else {
    if(cache.indexB[0] == cache.indexB[1]) {
      this.m_type = b2SeparationFunction.e_faceA;
      localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
      localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
      localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
      this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
      this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
      this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
      this.m_axis.Normalize();
      tVec = this.m_axis;
      tMat = transformA.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointB;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
      if(s < 0) {
        this.m_axis.NegativeSelf()
      }
    }else {
      if(cache.indexA[0] == cache.indexA[0]) {
        this.m_type = b2SeparationFunction.e_faceB;
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
        this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
        this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
        this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
        this.m_axis.Normalize();
        tVec = this.m_axis;
        tMat = transformB.R;
        normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tVec = this.m_localPoint;
        tMat = transformB.R;
        pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = localPointA;
        tMat = transformA.R;
        pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
        if(s < 0) {
          this.m_axis.NegativeSelf()
        }
      }else {
        localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
        localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        var pA = b2Math.MulX(transformA, localPointA);
        var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
        var pB = b2Math.MulX(transformB, localPointB);
        var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
        var a = dA.x * dA.x + dA.y * dA.y;
        var e = dB.x * dB.x + dB.y * dB.y;
        var r = b2Math.SubtractVV(dB, dA);
        var c = dA.x * r.x + dA.y * r.y;
        var f = dB.x * r.x + dB.y * r.y;
        var b = dA.x * dB.x + dA.y * dB.y;
        var denom = a * e - b * b;
        s = 0;
        if(denom != 0) {
          s = b2Math.Clamp((b * f - c * e) / denom, 0, 1)
        }
        var t = (b * s + f) / e;
        if(t < 0) {
          t = 0;
          s = b2Math.Clamp((b - c) / a, 0, 1)
        }
        localPointA = new b2Vec2;
        localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
        localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
        localPointB = new b2Vec2;
        localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
        localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
        if(s == 0 || s == 1) {
          this.m_type = b2SeparationFunction.e_faceB;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
          this.m_axis.Normalize();
          this.m_localPoint = localPointB;
          tVec = this.m_axis;
          tMat = transformB.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointA;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }else {
          this.m_type = b2SeparationFunction.e_faceA;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
          this.m_localPoint = localPointA;
          tVec = this.m_axis;
          tMat = transformA.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointB;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }
      }
    }
  }
};
b2SeparationFunction.prototype.Evaluate = function(transformA, transformB) {
  var axisA;
  var axisB;
  var localPointA;
  var localPointB;
  var pointA;
  var pointB;
  var seperation;
  var normal;
  switch(this.m_type) {
    case b2SeparationFunction.e_points:
      axisA = b2Math.MulTMV(transformA.R, this.m_axis);
      axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointA = b2Math.MulX(transformA, localPointA);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
      return seperation;
    case b2SeparationFunction.e_faceA:
      normal = b2Math.MulMV(transformA.R, this.m_axis);
      pointA = b2Math.MulX(transformA, this.m_localPoint);
      axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
      return seperation;
    case b2SeparationFunction.e_faceB:
      normal = b2Math.MulMV(transformB.R, this.m_axis);
      pointB = b2Math.MulX(transformB, this.m_localPoint);
      axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      pointA = b2Math.MulX(transformA, localPointA);
      seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
      return seperation;
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2SeparationFunction.prototype.m_proxyA = null;
b2SeparationFunction.prototype.m_proxyB = null;
b2SeparationFunction.prototype.m_type = 0;
b2SeparationFunction.prototype.m_localPoint = new b2Vec2;
b2SeparationFunction.prototype.m_axis = new b2Vec2;var b2DynamicTreePair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreePair.prototype.__constructor = function() {
};
b2DynamicTreePair.prototype.__varz = function() {
};
b2DynamicTreePair.prototype.proxyA = null;
b2DynamicTreePair.prototype.proxyB = null;var b2ContactConstraintPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraintPoint.prototype.__constructor = function() {
};
b2ContactConstraintPoint.prototype.__varz = function() {
  this.localPoint = new b2Vec2;
  this.rA = new b2Vec2;
  this.rB = new b2Vec2
};
b2ContactConstraintPoint.prototype.localPoint = new b2Vec2;
b2ContactConstraintPoint.prototype.rA = new b2Vec2;
b2ContactConstraintPoint.prototype.rB = new b2Vec2;
b2ContactConstraintPoint.prototype.normalImpulse = null;
b2ContactConstraintPoint.prototype.tangentImpulse = null;
b2ContactConstraintPoint.prototype.normalMass = null;
b2ContactConstraintPoint.prototype.tangentMass = null;
b2ContactConstraintPoint.prototype.equalizedMass = null;
b2ContactConstraintPoint.prototype.velocityBias = null;var b2ControllerEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ControllerEdge.prototype.__constructor = function() {
};
b2ControllerEdge.prototype.__varz = function() {
};
b2ControllerEdge.prototype.controller = null;
b2ControllerEdge.prototype.body = null;
b2ControllerEdge.prototype.prevBody = null;
b2ControllerEdge.prototype.nextBody = null;
b2ControllerEdge.prototype.prevController = null;
b2ControllerEdge.prototype.nextController = null;var b2DistanceInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceInput.prototype.__constructor = function() {
};
b2DistanceInput.prototype.__varz = function() {
};
b2DistanceInput.prototype.proxyA = null;
b2DistanceInput.prototype.proxyB = null;
b2DistanceInput.prototype.transformA = null;
b2DistanceInput.prototype.transformB = null;
b2DistanceInput.prototype.useRadii = null;var b2Settings = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Settings.prototype.__constructor = function() {
};
b2Settings.prototype.__varz = function() {
};
b2Settings.b2MixFriction = function(friction1, friction2) {
  return Math.sqrt(friction1 * friction2)
};
b2Settings.b2MixRestitution = function(restitution1, restitution2) {
  return restitution1 > restitution2 ? restitution1 : restitution2
};
b2Settings.b2Assert = function(a) {
  if(!a) {
    throw"Assertion Failed";
  }
};
b2Settings.VERSION = "2.1alpha";
b2Settings.USHRT_MAX = 65535;
b2Settings.b2_pi = Math.PI;
b2Settings.b2_maxManifoldPoints = 2;
b2Settings.b2_aabbExtension = 0.1;
b2Settings.b2_aabbMultiplier = 2;
b2Settings.b2_polygonRadius = 2 * b2Settings.b2_linearSlop;
b2Settings.b2_linearSlop = 0.0050;
b2Settings.b2_angularSlop = 2 / 180 * b2Settings.b2_pi;
b2Settings.b2_toiSlop = 8 * b2Settings.b2_linearSlop;
b2Settings.b2_maxTOIContactsPerIsland = 32;
b2Settings.b2_maxTOIJointsPerIsland = 32;
b2Settings.b2_velocityThreshold = 1;
b2Settings.b2_maxLinearCorrection = 0.2;
b2Settings.b2_maxAngularCorrection = 8 / 180 * b2Settings.b2_pi;
b2Settings.b2_maxTranslation = 2;
b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
b2Settings.b2_contactBaumgarte = 0.2;
b2Settings.b2_timeToSleep = 0.5;
b2Settings.b2_linearSleepTolerance = 0.01;
b2Settings.b2_angularSleepTolerance = 2 / 180 * b2Settings.b2_pi;var b2Proxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Proxy.prototype.__constructor = function() {
};
b2Proxy.prototype.__varz = function() {
  this.lowerBounds = new Array(2);
  this.upperBounds = new Array(2);
  this.pairs = new Object
};
b2Proxy.prototype.IsValid = function() {
  return this.overlapCount != b2BroadPhase.b2_invalid
};
b2Proxy.prototype.lowerBounds = new Array(2);
b2Proxy.prototype.upperBounds = new Array(2);
b2Proxy.prototype.overlapCount = 0;
b2Proxy.prototype.timeStamp = 0;
b2Proxy.prototype.pairs = new Object;
b2Proxy.prototype.next = null;
b2Proxy.prototype.userData = null;var b2Point = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Point.prototype.__constructor = function() {
};
b2Point.prototype.__varz = function() {
  this.p = new b2Vec2
};
b2Point.prototype.Support = function(xf, vX, vY) {
  return this.p
};
b2Point.prototype.GetFirstVertex = function(xf) {
  return this.p
};
b2Point.prototype.p = new b2Vec2;var b2WorldManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2WorldManifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2WorldManifold.prototype.__varz = function() {
  this.m_normal = new b2Vec2
};
b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {
  if(manifold.m_pointCount == 0) {
    return
  }
  var i = 0;
  var tVec;
  var tMat;
  var normalX;
  var normalY;
  var planePointX;
  var planePointY;
  var clipPointX;
  var clipPointY;
  switch(manifold.m_type) {
    case b2Manifold.e_circles:
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_points[0].m_localPoint;
      var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      var cAX = pointAX + radiusA * this.m_normal.x;
      var cAY = pointAY + radiusA * this.m_normal.y;
      var cBX = pointBX - radiusB * this.m_normal.x;
      var cBY = pointBY - radiusB * this.m_normal.y;
      this.m_points[0].x = 0.5 * (cAX + cBX);
      this.m_points[0].y = 0.5 * (cAY + cBY);
      break;
    case b2Manifold.e_faceA:
      tMat = xfA.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = normalX;
      this.m_normal.y = normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfB.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = xfB.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_localPoint;
      planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = -normalX;
      this.m_normal.y = -normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfA.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY
      }
      break
  }
};
b2WorldManifold.prototype.m_normal = new b2Vec2;
b2WorldManifold.prototype.m_points = null;var b2RayCastOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastOutput.prototype.__constructor = function() {
};
b2RayCastOutput.prototype.__varz = function() {
  this.normal = new b2Vec2
};
b2RayCastOutput.prototype.normal = new b2Vec2;
b2RayCastOutput.prototype.fraction = null;var b2ConstantForceController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantForceController.prototype, b2Controller.prototype);
b2ConstantForceController.prototype._super = b2Controller.prototype;
b2ConstantForceController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantForceController.prototype.__varz = function() {
  this.F = new b2Vec2(0, 0)
};
b2ConstantForceController.prototype.Step = function(step) {
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.ApplyForce(this.F, body.GetWorldCenter())
  }
};
b2ConstantForceController.prototype.F = new b2Vec2(0, 0);var b2MassData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2MassData.prototype.__constructor = function() {
};
b2MassData.prototype.__varz = function() {
  this.center = new b2Vec2(0, 0)
};
b2MassData.prototype.mass = 0;
b2MassData.prototype.center = new b2Vec2(0, 0);
b2MassData.prototype.I = 0;var b2DynamicTree = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTree.prototype.__constructor = function() {
  this.m_root = null;
  this.m_freeList = null;
  this.m_path = 0;
  this.m_insertionCount = 0
};
b2DynamicTree.prototype.__varz = function() {
};
b2DynamicTree.prototype.AllocateNode = function() {
  if(this.m_freeList) {
    var node = this.m_freeList;
    this.m_freeList = node.parent;
    node.parent = null;
    node.child1 = null;
    node.child2 = null;
    return node
  }
  return new b2DynamicTreeNode
};
b2DynamicTree.prototype.FreeNode = function(node) {
  node.parent = this.m_freeList;
  this.m_freeList = node
};
b2DynamicTree.prototype.InsertLeaf = function(leaf) {
  ++this.m_insertionCount;
  if(this.m_root == null) {
    this.m_root = leaf;
    this.m_root.parent = null;
    return
  }
  var center = leaf.aabb.GetCenter();
  var sibling = this.m_root;
  if(sibling.IsLeaf() == false) {
    do {
      var child1 = sibling.child1;
      var child2 = sibling.child2;
      var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
      var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
      if(norm1 < norm2) {
        sibling = child1
      }else {
        sibling = child2
      }
    }while(sibling.IsLeaf() == false)
  }
  var node1 = sibling.parent;
  var node2 = this.AllocateNode();
  node2.parent = node1;
  node2.userData = null;
  node2.aabb.Combine(leaf.aabb, sibling.aabb);
  if(node1) {
    if(sibling.parent.child1 == sibling) {
      node1.child1 = node2
    }else {
      node1.child2 = node2
    }
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    do {
      if(node1.aabb.Contains(node2.aabb)) {
        break
      }
      node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
      node2 = node1;
      node1 = node1.parent
    }while(node1)
  }else {
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    this.m_root = node2
  }
};
b2DynamicTree.prototype.RemoveLeaf = function(leaf) {
  if(leaf == this.m_root) {
    this.m_root = null;
    return
  }
  var node2 = leaf.parent;
  var node1 = node2.parent;
  var sibling;
  if(node2.child1 == leaf) {
    sibling = node2.child2
  }else {
    sibling = node2.child1
  }
  if(node1) {
    if(node1.child1 == node2) {
      node1.child1 = sibling
    }else {
      node1.child2 = sibling
    }
    sibling.parent = node1;
    this.FreeNode(node2);
    while(node1) {
      var oldAABB = node1.aabb;
      node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
      if(oldAABB.Contains(node1.aabb)) {
        break
      }
      node1 = node1.parent
    }
  }else {
    this.m_root = sibling;
    sibling.parent = null;
    this.FreeNode(node2)
  }
};
b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {
  var node = this.AllocateNode();
  var extendX = b2Settings.b2_aabbExtension;
  var extendY = b2Settings.b2_aabbExtension;
  node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  node.aabb.upperBound.x = aabb.upperBound.x + extendX;
  node.aabb.upperBound.y = aabb.upperBound.y + extendY;
  node.userData = userData;
  this.InsertLeaf(node);
  return node
};
b2DynamicTree.prototype.DestroyProxy = function(proxy) {
  this.RemoveLeaf(proxy);
  this.FreeNode(proxy)
};
b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {
  b2Settings.b2Assert(proxy.IsLeaf());
  if(proxy.aabb.Contains(aabb)) {
    return false
  }
  this.RemoveLeaf(proxy);
  var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
  var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
  proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
  proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
  this.InsertLeaf(proxy);
  return true
};
b2DynamicTree.prototype.Rebalance = function(iterations) {
  if(this.m_root == null) {
    return
  }
  for(var i = 0;i < iterations;i++) {
    var node = this.m_root;
    var bit = 0;
    while(node.IsLeaf() == false) {
      node = this.m_path >> bit & 1 ? node.child2 : node.child1;
      bit = bit + 1 & 31
    }
    ++this.m_path;
    this.RemoveLeaf(node);
    this.InsertLeaf(node)
  }
};
b2DynamicTree.prototype.GetFatAABB = function(proxy) {
  return proxy.aabb
};
b2DynamicTree.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2DynamicTree.prototype.Query = function(callback, aabb) {
  if(this.m_root == null) {
    return
  }
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(aabb)) {
      if(node.IsLeaf()) {
        var proceed = callback(node);
        if(!proceed) {
          return
        }
      }else {
        stack[count++] = node.child1;
        stack[count++] = node.child2
      }
    }
  }
};
b2DynamicTree.prototype.RayCast = function(callback, input) {
  if(this.m_root == null) {
    return
  }
  var p1 = input.p1;
  var p2 = input.p2;
  var r = b2Math.SubtractVV(p1, p2);
  r.Normalize();
  var v = b2Math.CrossFV(1, r);
  var abs_v = b2Math.AbsV(v);
  var maxFraction = input.maxFraction;
  var segmentAABB = new b2AABB;
  var tX;
  var tY;
  tX = p1.x + maxFraction * (p2.x - p1.x);
  tY = p1.y + maxFraction * (p2.y - p1.y);
  segmentAABB.lowerBound.x = Math.min(p1.x, tX);
  segmentAABB.lowerBound.y = Math.min(p1.y, tY);
  segmentAABB.upperBound.x = Math.max(p1.x, tX);
  segmentAABB.upperBound.y = Math.max(p1.y, tY);
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(segmentAABB) == false) {
      continue
    }
    var c = node.aabb.GetCenter();
    var h = node.aabb.GetExtents();
    var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
    if(separation > 0) {
      continue
    }
    if(node.IsLeaf()) {
      var subInput = new b2RayCastInput;
      subInput.p1 = input.p1;
      subInput.p2 = input.p2;
      subInput.maxFraction = input.maxFraction;
      maxFraction = callback(subInput, node);
      if(maxFraction == 0) {
        return
      }
      tX = p1.x + maxFraction * (p2.x - p1.x);
      tY = p1.y + maxFraction * (p2.y - p1.y);
      segmentAABB.lowerBound.x = Math.min(p1.x, tX);
      segmentAABB.lowerBound.y = Math.min(p1.y, tY);
      segmentAABB.upperBound.x = Math.max(p1.x, tX);
      segmentAABB.upperBound.y = Math.max(p1.y, tY)
    }else {
      stack[count++] = node.child1;
      stack[count++] = node.child2
    }
  }
};
b2DynamicTree.prototype.m_root = null;
b2DynamicTree.prototype.m_freeList = null;
b2DynamicTree.prototype.m_path = 0;
b2DynamicTree.prototype.m_insertionCount = 0;var b2JointEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointEdge.prototype.__constructor = function() {
};
b2JointEdge.prototype.__varz = function() {
};
b2JointEdge.prototype.other = null;
b2JointEdge.prototype.joint = null;
b2JointEdge.prototype.prev = null;
b2JointEdge.prototype.next = null;var b2RayCastInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastInput.prototype.__constructor = function() {
};
b2RayCastInput.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2RayCastInput.prototype.p1 = new b2Vec2;
b2RayCastInput.prototype.p2 = new b2Vec2;
b2RayCastInput.prototype.maxFraction = null;var Features = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
Features.prototype.__constructor = function() {
};
Features.prototype.__varz = function() {
};
Features.prototype.__defineGetter__("referenceEdge", function() {
  return this._referenceEdge
});
Features.prototype.__defineSetter__("referenceEdge", function(value) {
  this._referenceEdge = value;
  this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255
});
Features.prototype.__defineGetter__("incidentEdge", function() {
  return this._incidentEdge
});
Features.prototype.__defineSetter__("incidentEdge", function(value) {
  this._incidentEdge = value;
  this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280
});
Features.prototype.__defineGetter__("incidentVertex", function() {
  return this._incidentVertex
});
Features.prototype.__defineSetter__("incidentVertex", function(value) {
  this._incidentVertex = value;
  this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680
});
Features.prototype.__defineGetter__("flip", function() {
  return this._flip
});
Features.prototype.__defineSetter__("flip", function(value) {
  this._flip = value;
  this._m_id._key = this._m_id._key & 16777215 | this._flip << 24 & 4278190080
});
Features.prototype._referenceEdge = 0;
Features.prototype._incidentEdge = 0;
Features.prototype._incidentVertex = 0;
Features.prototype._flip = 0;
Features.prototype._m_id = null;var b2FilterData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FilterData.prototype.__constructor = function() {
};
b2FilterData.prototype.__varz = function() {
  this.categoryBits = 1;
  this.maskBits = 65535
};
b2FilterData.prototype.Copy = function() {
  var copy = new b2FilterData;
  copy.categoryBits = this.categoryBits;
  copy.maskBits = this.maskBits;
  copy.groupIndex = this.groupIndex;
  return copy
};
b2FilterData.prototype.categoryBits = 1;
b2FilterData.prototype.maskBits = 65535;
b2FilterData.prototype.groupIndex = 0;var b2AABB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2AABB.prototype.__constructor = function() {
};
b2AABB.prototype.__varz = function() {
  this.lowerBound = new b2Vec2;
  this.upperBound = new b2Vec2
};
b2AABB.Combine = function(aabb1, aabb2) {
  var aabb = new b2AABB;
  aabb.Combine(aabb1, aabb2);
  return aabb
};
b2AABB.prototype.IsValid = function() {
  var dX = this.upperBound.x - this.lowerBound.x;
  var dY = this.upperBound.y - this.lowerBound.y;
  var valid = dX >= 0 && dY >= 0;
  valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
  return valid
};
b2AABB.prototype.GetCenter = function() {
  return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
};
b2AABB.prototype.GetExtents = function() {
  return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
};
b2AABB.prototype.Contains = function(aabb) {
  var result = true && this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
  return result
};
b2AABB.prototype.RayCast = function(output, input) {
  var tmin = -Number.MAX_VALUE;
  var tmax = Number.MAX_VALUE;
  var pX = input.p1.x;
  var pY = input.p1.y;
  var dX = input.p2.x - input.p1.x;
  var dY = input.p2.y - input.p1.y;
  var absDX = Math.abs(dX);
  var absDY = Math.abs(dY);
  var normal = output.normal;
  var inv_d;
  var t1;
  var t2;
  var t3;
  var s;
  if(absDX < Number.MIN_VALUE) {
    if(pX < this.lowerBound.x || this.upperBound.x < pX) {
      return false
    }
  }else {
    inv_d = 1 / dX;
    t1 = (this.lowerBound.x - pX) * inv_d;
    t2 = (this.upperBound.x - pX) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.x = s;
      normal.y = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  if(absDY < Number.MIN_VALUE) {
    if(pY < this.lowerBound.y || this.upperBound.y < pY) {
      return false
    }
  }else {
    inv_d = 1 / dY;
    t1 = (this.lowerBound.y - pY) * inv_d;
    t2 = (this.upperBound.y - pY) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.y = s;
      normal.x = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  output.fraction = tmin;
  return true
};
b2AABB.prototype.TestOverlap = function(other) {
  var d1X = other.lowerBound.x - this.upperBound.x;
  var d1Y = other.lowerBound.y - this.upperBound.y;
  var d2X = this.lowerBound.x - other.upperBound.x;
  var d2Y = this.lowerBound.y - other.upperBound.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2AABB.prototype.Combine = function(aabb1, aabb2) {
  this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
  this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
  this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
  this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y)
};
b2AABB.prototype.lowerBound = new b2Vec2;
b2AABB.prototype.upperBound = new b2Vec2;var b2Jacobian = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Jacobian.prototype.__constructor = function() {
};
b2Jacobian.prototype.__varz = function() {
  this.linearA = new b2Vec2;
  this.linearB = new b2Vec2
};
b2Jacobian.prototype.SetZero = function() {
  this.linearA.SetZero();
  this.angularA = 0;
  this.linearB.SetZero();
  this.angularB = 0
};
b2Jacobian.prototype.Set = function(x1, a1, x2, a2) {
  this.linearA.SetV(x1);
  this.angularA = a1;
  this.linearB.SetV(x2);
  this.angularB = a2
};
b2Jacobian.prototype.Compute = function(x1, a1, x2, a2) {
  return this.linearA.x * x1.x + this.linearA.y * x1.y + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2
};
b2Jacobian.prototype.linearA = new b2Vec2;
b2Jacobian.prototype.angularA = null;
b2Jacobian.prototype.linearB = new b2Vec2;
b2Jacobian.prototype.angularB = null;var b2Bound = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Bound.prototype.__constructor = function() {
};
b2Bound.prototype.__varz = function() {
};
b2Bound.prototype.IsLower = function() {
  return(this.value & 1) == 0
};
b2Bound.prototype.IsUpper = function() {
  return(this.value & 1) == 1
};
b2Bound.prototype.Swap = function(b) {
  var tempValue = this.value;
  var tempProxy = this.proxy;
  var tempStabbingCount = this.stabbingCount;
  this.value = b.value;
  this.proxy = b.proxy;
  this.stabbingCount = b.stabbingCount;
  b.value = tempValue;
  b.proxy = tempProxy;
  b.stabbingCount = tempStabbingCount
};
b2Bound.prototype.value = 0;
b2Bound.prototype.proxy = null;
b2Bound.prototype.stabbingCount = 0;var b2SimplexVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexVertex.prototype.__constructor = function() {
};
b2SimplexVertex.prototype.__varz = function() {
};
b2SimplexVertex.prototype.Set = function(other) {
  this.wA.SetV(other.wA);
  this.wB.SetV(other.wB);
  this.w.SetV(other.w);
  this.a = other.a;
  this.indexA = other.indexA;
  this.indexB = other.indexB
};
b2SimplexVertex.prototype.wA = null;
b2SimplexVertex.prototype.wB = null;
b2SimplexVertex.prototype.w = null;
b2SimplexVertex.prototype.a = null;
b2SimplexVertex.prototype.indexA = 0;
b2SimplexVertex.prototype.indexB = 0;var b2Mat22 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat22.prototype.__constructor = function() {
  this.col1.x = this.col2.y = 1
};
b2Mat22.prototype.__varz = function() {
  this.col1 = new b2Vec2;
  this.col2 = new b2Vec2
};
b2Mat22.FromAngle = function(angle) {
  var mat = new b2Mat22;
  mat.Set(angle);
  return mat
};
b2Mat22.FromVV = function(c1, c2) {
  var mat = new b2Mat22;
  mat.SetVV(c1, c2);
  return mat
};
b2Mat22.prototype.Set = function(angle) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  this.col1.x = c;
  this.col2.x = -s;
  this.col1.y = s;
  this.col2.y = c
};
b2Mat22.prototype.SetVV = function(c1, c2) {
  this.col1.SetV(c1);
  this.col2.SetV(c2)
};
b2Mat22.prototype.Copy = function() {
  var mat = new b2Mat22;
  mat.SetM(this);
  return mat
};
b2Mat22.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2)
};
b2Mat22.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y
};
b2Mat22.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 1
};
b2Mat22.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 0
};
b2Mat22.prototype.GetAngle = function() {
  return Math.atan2(this.col1.y, this.col1.x)
};
b2Mat22.prototype.GetInverse = function(out) {
  var a = this.col1.x;
  var b = this.col2.x;
  var c = this.col1.y;
  var d = this.col2.y;
  var det = a * d - b * c;
  if(det != 0) {
    det = 1 / det
  }
  out.col1.x = det * d;
  out.col2.x = -det * b;
  out.col1.y = -det * c;
  out.col2.y = det * a;
  return out
};
b2Mat22.prototype.Solve = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat22.prototype.Abs = function() {
  this.col1.Abs();
  this.col2.Abs()
};
b2Mat22.prototype.col1 = new b2Vec2;
b2Mat22.prototype.col2 = new b2Vec2;var b2SimplexCache = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexCache.prototype.__constructor = function() {
};
b2SimplexCache.prototype.__varz = function() {
  this.indexA = new Array(3);
  this.indexB = new Array(3)
};
b2SimplexCache.prototype.metric = null;
b2SimplexCache.prototype.count = 0;
b2SimplexCache.prototype.indexA = new Array(3);
b2SimplexCache.prototype.indexB = new Array(3);var b2Shape = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Shape.prototype.__constructor = function() {
  this.m_type = b2Shape.e_unknownShape;
  this.m_radius = b2Settings.b2_linearSlop
};
b2Shape.prototype.__varz = function() {
};
b2Shape.TestOverlap = function(shape1, transform1, shape2, transform2) {
  var input = new b2DistanceInput;
  input.proxyA = new b2DistanceProxy;
  input.proxyA.Set(shape1);
  input.proxyB = new b2DistanceProxy;
  input.proxyB.Set(shape2);
  input.transformA = transform1;
  input.transformB = transform2;
  input.useRadii = true;
  var simplexCache = new b2SimplexCache;
  simplexCache.count = 0;
  var output = new b2DistanceOutput;
  b2Distance.Distance(output, simplexCache, input);
  return output.distance < 10 * Number.MIN_VALUE
};
b2Shape.e_hitCollide = 1;
b2Shape.e_missCollide = 0;
b2Shape.e_startsInsideCollide = -1;
b2Shape.e_unknownShape = -1;
b2Shape.e_circleShape = 0;
b2Shape.e_polygonShape = 1;
b2Shape.e_edgeShape = 2;
b2Shape.e_shapeTypeCount = 3;
b2Shape.prototype.Copy = function() {
  return null
};
b2Shape.prototype.Set = function(other) {
  this.m_radius = other.m_radius
};
b2Shape.prototype.GetType = function() {
  return this.m_type
};
b2Shape.prototype.TestPoint = function(xf, p) {
  return false
};
b2Shape.prototype.RayCast = function(output, input, transform) {
  return false
};
b2Shape.prototype.ComputeAABB = function(aabb, xf) {
};
b2Shape.prototype.ComputeMass = function(massData, density) {
};
b2Shape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  return 0
};
b2Shape.prototype.m_type = 0;
b2Shape.prototype.m_radius = null;var b2Segment = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Segment.prototype.__constructor = function() {
};
b2Segment.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2Segment.prototype.TestSegment = function(lambda, normal, segment, maxLambda) {
  var s = segment.p1;
  var rX = segment.p2.x - s.x;
  var rY = segment.p2.y - s.y;
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var nX = dY;
  var nY = -dX;
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = s.x - this.p1.x;
    var bY = s.y - this.p1.y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= maxLambda * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        nX /= nLen;
        nY /= nLen;
        lambda[0] = a;
        normal.Set(nX, nY);
        return true
      }
    }
  }
  return false
};
b2Segment.prototype.Extend = function(aabb) {
  this.ExtendForward(aabb);
  this.ExtendBackward(aabb)
};
b2Segment.prototype.ExtendForward = function(aabb) {
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
  this.p2.x = this.p1.x + dX * lambda;
  this.p2.y = this.p1.y + dY * lambda
};
b2Segment.prototype.ExtendBackward = function(aabb) {
  var dX = -this.p2.x + this.p1.x;
  var dY = -this.p2.y + this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
  this.p1.x = this.p2.x + dX * lambda;
  this.p1.y = this.p2.y + dY * lambda
};
b2Segment.prototype.p1 = new b2Vec2;
b2Segment.prototype.p2 = new b2Vec2;var b2ContactRegister = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactRegister.prototype.__constructor = function() {
};
b2ContactRegister.prototype.__varz = function() {
};
b2ContactRegister.prototype.createFcn = null;
b2ContactRegister.prototype.destroyFcn = null;
b2ContactRegister.prototype.primary = null;
b2ContactRegister.prototype.pool = null;
b2ContactRegister.prototype.poolCount = 0;var b2DebugDraw = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DebugDraw.prototype.__constructor = function() {
  this.m_drawFlags = 0
};
b2DebugDraw.prototype.__varz = function() {
};
b2DebugDraw.e_shapeBit = 1;
b2DebugDraw.e_jointBit = 2;
b2DebugDraw.e_aabbBit = 4;
b2DebugDraw.e_pairBit = 8;
b2DebugDraw.e_centerOfMassBit = 16;
b2DebugDraw.e_controllerBit = 32;
b2DebugDraw.prototype.SetFlags = function(flags) {
  this.m_drawFlags = flags
};
b2DebugDraw.prototype.GetFlags = function() {
  return this.m_drawFlags
};
b2DebugDraw.prototype.AppendFlags = function(flags) {
  this.m_drawFlags |= flags
};
b2DebugDraw.prototype.ClearFlags = function(flags) {
  this.m_drawFlags &= ~flags
};
b2DebugDraw.prototype.SetSprite = function(sprite) {
  this.m_sprite = sprite
};
b2DebugDraw.prototype.GetSprite = function() {
  return this.m_sprite
};
b2DebugDraw.prototype.SetDrawScale = function(drawScale) {
  this.m_drawScale = drawScale
};
b2DebugDraw.prototype.GetDrawScale = function() {
  return this.m_drawScale
};
b2DebugDraw.prototype.SetLineThickness = function(lineThickness) {
  this.m_lineThickness = lineThickness
};
b2DebugDraw.prototype.GetLineThickness = function() {
  return this.m_lineThickness
};
b2DebugDraw.prototype.SetAlpha = function(alpha) {
  this.m_alpha = alpha
};
b2DebugDraw.prototype.GetAlpha = function() {
  return this.m_alpha
};
b2DebugDraw.prototype.SetFillAlpha = function(alpha) {
  this.m_fillAlpha = alpha
};
b2DebugDraw.prototype.GetFillAlpha = function() {
  return this.m_fillAlpha
};
b2DebugDraw.prototype.SetXFormScale = function(xformScale) {
  this.m_xformScale = xformScale
};
b2DebugDraw.prototype.GetXFormScale = function() {
  return this.m_xformScale
};
b2DebugDraw.prototype.Clear = function() {
  this.m_sprite.clearRect(0, 0, this.m_sprite.canvas.width, this.m_sprite.canvas.height)
};
b2DebugDraw.prototype.Y = function(y) {
  return this.m_sprite.canvas.height - y
};
b2DebugDraw.prototype.ToWorldPoint = function(localPoint) {
  return new b2Vec2(localPoint.x / this.m_drawScale, this.Y(localPoint.y) / this.m_drawScale)
};
b2DebugDraw.prototype.ColorStyle = function(color, alpha) {
  return"rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + alpha + ")"
};
b2DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.moveTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale);
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.graphics.lineTo(vertices[i].x * this.m_drawScale, vertices[i].y * this.m_drawScale)
  }
  this.m_sprite.graphics.lineTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.lineTo(vertices[i].x * this.m_drawScale, this.Y(vertices[i].y * this.m_drawScale))
  }
  this.m_sprite.lineTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawCircle = function(center, radius, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.drawCircle(center.x * this.m_drawScale, center.y * this.m_drawScale, radius * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.arc(center.x * this.m_drawScale, this.Y(center.y * this.m_drawScale), radius * this.m_drawScale, 0, Math.PI * 2, true);
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(p1.x * this.m_drawScale, this.Y(p1.y * this.m_drawScale));
  this.m_sprite.lineTo(p2.x * this.m_drawScale, this.Y(p2.y * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawTransform = function(xf) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(255, 0, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col1.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath();
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(0, 255, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col2.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.m_drawFlags = 0;
b2DebugDraw.prototype.m_sprite = null;
b2DebugDraw.prototype.m_drawScale = 1;
b2DebugDraw.prototype.m_lineThickness = 1;
b2DebugDraw.prototype.m_alpha = 1;
b2DebugDraw.prototype.m_fillAlpha = 1;
b2DebugDraw.prototype.m_xformScale = 1;var b2Sweep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Sweep.prototype.__constructor = function() {
};
b2Sweep.prototype.__varz = function() {
  this.localCenter = new b2Vec2;
  this.c0 = new b2Vec2;
  this.c = new b2Vec2
};
b2Sweep.prototype.Set = function(other) {
  this.localCenter.SetV(other.localCenter);
  this.c0.SetV(other.c0);
  this.c.SetV(other.c);
  this.a0 = other.a0;
  this.a = other.a;
  this.t0 = other.t0
};
b2Sweep.prototype.Copy = function() {
  var copy = new b2Sweep;
  copy.localCenter.SetV(this.localCenter);
  copy.c0.SetV(this.c0);
  copy.c.SetV(this.c);
  copy.a0 = this.a0;
  copy.a = this.a;
  copy.t0 = this.t0;
  return copy
};
b2Sweep.prototype.GetTransform = function(xf, alpha) {
  xf.position.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
  xf.position.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
  var angle = (1 - alpha) * this.a0 + alpha * this.a;
  xf.R.Set(angle);
  var tMat = xf.R;
  xf.position.x -= tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y;
  xf.position.y -= tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y
};
b2Sweep.prototype.Advance = function(t) {
  if(this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
    var alpha = (t - this.t0) / (1 - this.t0);
    this.c0.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
    this.c0.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
    this.a0 = (1 - alpha) * this.a0 + alpha * this.a;
    this.t0 = t
  }
};
b2Sweep.prototype.localCenter = new b2Vec2;
b2Sweep.prototype.c0 = new b2Vec2;
b2Sweep.prototype.c = new b2Vec2;
b2Sweep.prototype.a0 = null;
b2Sweep.prototype.a = null;
b2Sweep.prototype.t0 = null;var b2DistanceOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceOutput.prototype.__constructor = function() {
};
b2DistanceOutput.prototype.__varz = function() {
  this.pointA = new b2Vec2;
  this.pointB = new b2Vec2
};
b2DistanceOutput.prototype.pointA = new b2Vec2;
b2DistanceOutput.prototype.pointB = new b2Vec2;
b2DistanceOutput.prototype.distance = null;
b2DistanceOutput.prototype.iterations = 0;var b2Mat33 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat33.prototype.__constructor = function(c1, c2, c3) {
  if(!c1 && !c2 && !c3) {
    this.col1.SetZero();
    this.col2.SetZero();
    this.col3.SetZero()
  }else {
    this.col1.SetV(c1);
    this.col2.SetV(c2);
    this.col3.SetV(c3)
  }
};
b2Mat33.prototype.__varz = function() {
  this.col1 = new b2Vec3;
  this.col2 = new b2Vec3;
  this.col3 = new b2Vec3
};
b2Mat33.prototype.SetVVV = function(c1, c2, c3) {
  this.col1.SetV(c1);
  this.col2.SetV(c2);
  this.col3.SetV(c3)
};
b2Mat33.prototype.Copy = function() {
  return new b2Mat33(this.col1, this.col2, this.col3)
};
b2Mat33.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2);
  this.col3.SetV(m.col3)
};
b2Mat33.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col1.z += m.col1.z;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y;
  this.col2.z += m.col2.z;
  this.col3.x += m.col3.x;
  this.col3.y += m.col3.y;
  this.col3.z += m.col3.z
};
b2Mat33.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 1;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 1
};
b2Mat33.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 0;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 0
};
b2Mat33.prototype.Solve22 = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat33.prototype.Solve33 = function(out, bX, bY, bZ) {
  var a11 = this.col1.x;
  var a21 = this.col1.y;
  var a31 = this.col1.z;
  var a12 = this.col2.x;
  var a22 = this.col2.y;
  var a32 = this.col2.z;
  var a13 = this.col3.x;
  var a23 = this.col3.y;
  var a33 = this.col3.z;
  var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
  out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
  out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
  return out
};
b2Mat33.prototype.col1 = new b2Vec3;
b2Mat33.prototype.col2 = new b2Vec3;
b2Mat33.prototype.col3 = new b2Vec3;var b2PositionSolverManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PositionSolverManifold.prototype.__constructor = function() {
  this.m_normal = new b2Vec2;
  this.m_separations = new Array(b2Settings.b2_maxManifoldPoints);
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2PositionSolverManifold.prototype.__varz = function() {
};
b2PositionSolverManifold.circlePointA = new b2Vec2;
b2PositionSolverManifold.circlePointB = new b2Vec2;
b2PositionSolverManifold.prototype.Initialize = function(cc) {
  b2Settings.b2Assert(cc.pointCount > 0);
  var i = 0;
  var clipPointX;
  var clipPointY;
  var tMat;
  var tVec;
  var planePointX;
  var planePointY;
  switch(cc.type) {
    case b2Manifold.e_circles:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.points[0].localPoint;
      var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      this.m_points[0].x = 0.5 * (pointAX + pointBX);
      this.m_points[0].y = 0.5 * (pointAY + pointBY);
      this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
      break;
    case b2Manifold.e_faceA:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].x = clipPointX;
        this.m_points[i].y = clipPointY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyA.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].Set(clipPointX, clipPointY)
      }
      this.m_normal.x *= -1;
      this.m_normal.y *= -1;
      break
  }
};
b2PositionSolverManifold.prototype.m_normal = null;
b2PositionSolverManifold.prototype.m_points = null;
b2PositionSolverManifold.prototype.m_separations = null;var b2OBB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2OBB.prototype.__constructor = function() {
};
b2OBB.prototype.__varz = function() {
  this.R = new b2Mat22;
  this.center = new b2Vec2;
  this.extents = new b2Vec2
};
b2OBB.prototype.R = new b2Mat22;
b2OBB.prototype.center = new b2Vec2;
b2OBB.prototype.extents = new b2Vec2;var b2Pair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Pair.prototype.__constructor = function() {
};
b2Pair.prototype.__varz = function() {
};
b2Pair.b2_nullProxy = b2Settings.USHRT_MAX;
b2Pair.e_pairBuffered = 1;
b2Pair.e_pairRemoved = 2;
b2Pair.e_pairFinal = 4;
b2Pair.prototype.SetBuffered = function() {
  this.status |= b2Pair.e_pairBuffered
};
b2Pair.prototype.ClearBuffered = function() {
  this.status &= ~b2Pair.e_pairBuffered
};
b2Pair.prototype.IsBuffered = function() {
  return(this.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
};
b2Pair.prototype.SetRemoved = function() {
  this.status |= b2Pair.e_pairRemoved
};
b2Pair.prototype.ClearRemoved = function() {
  this.status &= ~b2Pair.e_pairRemoved
};
b2Pair.prototype.IsRemoved = function() {
  return(this.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
};
b2Pair.prototype.SetFinal = function() {
  this.status |= b2Pair.e_pairFinal
};
b2Pair.prototype.IsFinal = function() {
  return(this.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
};
b2Pair.prototype.userData = null;
b2Pair.prototype.proxy1 = null;
b2Pair.prototype.proxy2 = null;
b2Pair.prototype.next = null;
b2Pair.prototype.status = 0;var b2FixtureDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FixtureDef.prototype.__constructor = function() {
  this.shape = null;
  this.userData = null;
  this.friction = 0.2;
  this.restitution = 0;
  this.density = 0;
  this.filter.categoryBits = 1;
  this.filter.maskBits = 65535;
  this.filter.groupIndex = 0;
  this.isSensor = false
};
b2FixtureDef.prototype.__varz = function() {
  this.filter = new b2FilterData
};
b2FixtureDef.prototype.shape = null;
b2FixtureDef.prototype.userData = null;
b2FixtureDef.prototype.friction = null;
b2FixtureDef.prototype.restitution = null;
b2FixtureDef.prototype.density = null;
b2FixtureDef.prototype.isSensor = null;
b2FixtureDef.prototype.filter = new b2FilterData;var b2ContactID = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactID.prototype.__constructor = function() {
  this.features._m_id = this
};
b2ContactID.prototype.__varz = function() {
  this.features = new Features
};
b2ContactID.prototype.Set = function(id) {
  key = id._key
};
b2ContactID.prototype.Copy = function() {
  var id = new b2ContactID;
  id.key = key;
  return id
};
b2ContactID.prototype.__defineSetter__("key", function() {
  return this._key
});
b2ContactID.prototype.__defineSetter__("key", function(value) {
  this._key = value;
  this.features._referenceEdge = this._key & 255;
  this.features._incidentEdge = (this._key & 65280) >> 8 & 255;
  this.features._incidentVertex = (this._key & 16711680) >> 16 & 255;
  this.features._flip = (this._key & 4278190080) >> 24 & 255
});
b2ContactID.prototype._key = 0;
b2ContactID.prototype.features = new Features;var b2Transform = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Transform.prototype.__constructor = function(pos, r) {
  if(pos) {
    this.position.SetV(pos);
    this.R.SetM(r)
  }
};
b2Transform.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.R = new b2Mat22
};
b2Transform.prototype.Initialize = function(pos, r) {
  this.position.SetV(pos);
  this.R.SetM(r)
};
b2Transform.prototype.SetIdentity = function() {
  this.position.SetZero();
  this.R.SetIdentity()
};
b2Transform.prototype.Set = function(x) {
  this.position.SetV(x.position);
  this.R.SetM(x.R)
};
b2Transform.prototype.GetAngle = function() {
  return Math.atan2(this.R.col1.y, this.R.col1.x)
};
b2Transform.prototype.position = new b2Vec2;
b2Transform.prototype.R = new b2Mat22;var b2EdgeShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeShape.prototype, b2Shape.prototype);
b2EdgeShape.prototype._super = b2Shape.prototype;
b2EdgeShape.prototype.__constructor = function(v1, v2) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_edgeShape;
  this.m_prevEdge = null;
  this.m_nextEdge = null;
  this.m_v1 = v1;
  this.m_v2 = v2;
  this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
  this.m_length = this.m_direction.Normalize();
  this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
  this.m_coreV1.Set(-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
  this.m_coreV2.Set(-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
  this.m_cornerDir1 = this.m_normal;
  this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
};
b2EdgeShape.prototype.__varz = function() {
  this.s_supportVec = new b2Vec2;
  this.m_v1 = new b2Vec2;
  this.m_v2 = new b2Vec2;
  this.m_coreV1 = new b2Vec2;
  this.m_coreV2 = new b2Vec2;
  this.m_normal = new b2Vec2;
  this.m_direction = new b2Vec2;
  this.m_cornerDir1 = new b2Vec2;
  this.m_cornerDir2 = new b2Vec2
};
b2EdgeShape.prototype.SetPrevEdge = function(edge, core, cornerDir, convex) {
  this.m_prevEdge = edge;
  this.m_coreV1 = core;
  this.m_cornerDir1 = cornerDir;
  this.m_cornerConvex1 = convex
};
b2EdgeShape.prototype.SetNextEdge = function(edge, core, cornerDir, convex) {
  this.m_nextEdge = edge;
  this.m_coreV2 = core;
  this.m_cornerDir2 = cornerDir;
  this.m_cornerConvex2 = convex
};
b2EdgeShape.prototype.TestPoint = function(transform, p) {
  return false
};
b2EdgeShape.prototype.RayCast = function(output, input, transform) {
  var tMat;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
  var nY = -(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X);
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = input.p1.x - v1X;
    var bY = input.p1.y - v1Y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= input.maxFraction * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        output.fraction = a;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        output.normal.x = nX / nLen;
        output.normal.y = nY / nLen;
        return true
      }
    }
  }
  return false
};
b2EdgeShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
  var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
  if(v1X < v2X) {
    aabb.lowerBound.x = v1X;
    aabb.upperBound.x = v2X
  }else {
    aabb.lowerBound.x = v2X;
    aabb.upperBound.x = v1X
  }
  if(v1Y < v2Y) {
    aabb.lowerBound.y = v1Y;
    aabb.upperBound.y = v2Y
  }else {
    aabb.lowerBound.y = v2Y;
    aabb.upperBound.y = v1Y
  }
};
b2EdgeShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = 0;
  massData.center.SetV(this.m_v1);
  massData.I = 0
};
b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
  var v1 = b2Math.MulX(xf, this.m_v1);
  var v2 = b2Math.MulX(xf, this.m_v2);
  var d1 = b2Math.Dot(normal, v1) - offset;
  var d2 = b2Math.Dot(normal, v2) - offset;
  if(d1 > 0) {
    if(d2 > 0) {
      return 0
    }else {
      v1.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v1.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }
  }else {
    if(d2 > 0) {
      v2.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v2.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }else {
    }
  }
  c.x = (v0.x + v1.x + v2.x) / 3;
  c.y = (v0.y + v1.y + v2.y) / 3;
  return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x))
};
b2EdgeShape.prototype.GetLength = function() {
  return this.m_length
};
b2EdgeShape.prototype.GetVertex1 = function() {
  return this.m_v1
};
b2EdgeShape.prototype.GetVertex2 = function() {
  return this.m_v2
};
b2EdgeShape.prototype.GetCoreVertex1 = function() {
  return this.m_coreV1
};
b2EdgeShape.prototype.GetCoreVertex2 = function() {
  return this.m_coreV2
};
b2EdgeShape.prototype.GetNormalVector = function() {
  return this.m_normal
};
b2EdgeShape.prototype.GetDirectionVector = function() {
  return this.m_direction
};
b2EdgeShape.prototype.GetCorner1Vector = function() {
  return this.m_cornerDir1
};
b2EdgeShape.prototype.GetCorner2Vector = function() {
  return this.m_cornerDir2
};
b2EdgeShape.prototype.Corner1IsConvex = function() {
  return this.m_cornerConvex1
};
b2EdgeShape.prototype.Corner2IsConvex = function() {
  return this.m_cornerConvex2
};
b2EdgeShape.prototype.GetFirstVertex = function(xf) {
  var tMat = xf.R;
  return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y))
};
b2EdgeShape.prototype.GetNextEdge = function() {
  return this.m_nextEdge
};
b2EdgeShape.prototype.GetPrevEdge = function() {
  return this.m_prevEdge
};
b2EdgeShape.prototype.Support = function(xf, dX, dY) {
  var tMat = xf.R;
  var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
  var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
  var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
  var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
  if(v1X * dX + v1Y * dY > v2X * dX + v2Y * dY) {
    this.s_supportVec.x = v1X;
    this.s_supportVec.y = v1Y
  }else {
    this.s_supportVec.x = v2X;
    this.s_supportVec.y = v2Y
  }
  return this.s_supportVec
};
b2EdgeShape.prototype.s_supportVec = new b2Vec2;
b2EdgeShape.prototype.m_v1 = new b2Vec2;
b2EdgeShape.prototype.m_v2 = new b2Vec2;
b2EdgeShape.prototype.m_coreV1 = new b2Vec2;
b2EdgeShape.prototype.m_coreV2 = new b2Vec2;
b2EdgeShape.prototype.m_length = null;
b2EdgeShape.prototype.m_normal = new b2Vec2;
b2EdgeShape.prototype.m_direction = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir1 = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir2 = new b2Vec2;
b2EdgeShape.prototype.m_cornerConvex1 = null;
b2EdgeShape.prototype.m_cornerConvex2 = null;
b2EdgeShape.prototype.m_nextEdge = null;
b2EdgeShape.prototype.m_prevEdge = null;var b2BuoyancyController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2BuoyancyController.prototype, b2Controller.prototype);
b2BuoyancyController.prototype._super = b2Controller.prototype;
b2BuoyancyController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2BuoyancyController.prototype.__varz = function() {
  this.normal = new b2Vec2(0, -1);
  this.velocity = new b2Vec2(0, 0)
};
b2BuoyancyController.prototype.Step = function(step) {
  if(!m_bodyList) {
    return
  }
  if(this.useWorldGravity) {
    this.gravity = this.GetWorld().GetGravity().Copy()
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(body.IsAwake() == false) {
      continue
    }
    var areac = new b2Vec2;
    var massc = new b2Vec2;
    var area = 0;
    var mass = 0;
    for(var fixture = body.GetFixtureList();fixture;fixture = fixture.GetNext()) {
      var sc = new b2Vec2;
      var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
      area += sarea;
      areac.x += sarea * sc.x;
      areac.y += sarea * sc.y;
      var shapeDensity;
      if(this.useDensity) {
        shapeDensity = 1
      }else {
        shapeDensity = 1
      }
      mass += sarea * shapeDensity;
      massc.x += sarea * sc.x * shapeDensity;
      massc.y += sarea * sc.y * shapeDensity
    }
    areac.x /= area;
    areac.y /= area;
    massc.x /= mass;
    massc.y /= mass;
    if(area < Number.MIN_VALUE) {
      continue
    }
    var buoyancyForce = this.gravity.GetNegative();
    buoyancyForce.Multiply(this.density * area);
    body.ApplyForce(buoyancyForce, massc);
    var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
    dragForce.Subtract(this.velocity);
    dragForce.Multiply(-this.linearDrag * area);
    body.ApplyForce(dragForce, areac);
    body.ApplyTorque(-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag)
  }
};
b2BuoyancyController.prototype.Draw = function(debugDraw) {
  var r = 1E3;
  var p1 = new b2Vec2;
  var p2 = new b2Vec2;
  p1.x = this.normal.x * this.offset + this.normal.y * r;
  p1.y = this.normal.y * this.offset - this.normal.x * r;
  p2.x = this.normal.x * this.offset - this.normal.y * r;
  p2.y = this.normal.y * this.offset + this.normal.x * r;
  var color = new b2Color(0, 0, 1);
  debugDraw.DrawSegment(p1, p2, color)
};
b2BuoyancyController.prototype.normal = new b2Vec2(0, -1);
b2BuoyancyController.prototype.offset = 0;
b2BuoyancyController.prototype.density = 0;
b2BuoyancyController.prototype.velocity = new b2Vec2(0, 0);
b2BuoyancyController.prototype.linearDrag = 2;
b2BuoyancyController.prototype.angularDrag = 1;
b2BuoyancyController.prototype.useDensity = false;
b2BuoyancyController.prototype.useWorldGravity = true;
b2BuoyancyController.prototype.gravity = null;var b2Body = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Body.prototype.__constructor = function(bd, world) {
  this.m_flags = 0;
  if(bd.bullet) {
    this.m_flags |= b2Body.e_bulletFlag
  }
  if(bd.fixedRotation) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }
  if(bd.allowSleep) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }
  if(bd.awake) {
    this.m_flags |= b2Body.e_awakeFlag
  }
  if(bd.active) {
    this.m_flags |= b2Body.e_activeFlag
  }
  this.m_world = world;
  this.m_xf.position.SetV(bd.position);
  this.m_xf.R.Set(bd.angle);
  this.m_sweep.localCenter.SetZero();
  this.m_sweep.t0 = 1;
  this.m_sweep.a0 = this.m_sweep.a = bd.angle;
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_contactList = null;
  this.m_controllerCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_linearVelocity.SetV(bd.linearVelocity);
  this.m_angularVelocity = bd.angularVelocity;
  this.m_linearDamping = bd.linearDamping;
  this.m_angularDamping = bd.angularDamping;
  this.m_force.Set(0, 0);
  this.m_torque = 0;
  this.m_sleepTime = 0;
  this.m_type = bd.type;
  if(this.m_type == b2Body.b2_dynamicBody) {
    this.m_mass = 1;
    this.m_invMass = 1
  }else {
    this.m_mass = 0;
    this.m_invMass = 0
  }
  this.m_I = 0;
  this.m_invI = 0;
  this.m_inertiaScale = bd.inertiaScale;
  this.m_userData = bd.userData;
  this.m_fixtureList = null;
  this.m_fixtureCount = 0
};
b2Body.prototype.__varz = function() {
  this.m_xf = new b2Transform;
  this.m_sweep = new b2Sweep;
  this.m_linearVelocity = new b2Vec2;
  this.m_force = new b2Vec2
};
b2Body.b2_staticBody = 0;
b2Body.b2_kinematicBody = 1;
b2Body.b2_dynamicBody = 2;
b2Body.s_xf1 = new b2Transform;
b2Body.e_islandFlag = 1;
b2Body.e_awakeFlag = 2;
b2Body.e_allowSleepFlag = 4;
b2Body.e_bulletFlag = 8;
b2Body.e_fixedRotationFlag = 16;
b2Body.e_activeFlag = 32;
b2Body.prototype.connectEdges = function(s1, s2, angle1) {
  var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
  var coreOffset = Math.tan((angle2 - angle1) * 0.5);
  var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
  core = b2Math.SubtractVV(core, s2.GetNormalVector());
  core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
  core = b2Math.AddVV(core, s2.GetVertex1());
  var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
  cornerDir.Normalize();
  var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0;
  s1.SetNextEdge(s2, core, cornerDir, convex);
  s2.SetPrevEdge(s1, core, cornerDir, convex);
  return angle2
};
b2Body.prototype.SynchronizeFixtures = function() {
  var xf1 = b2Body.s_xf1;
  xf1.R.Set(this.m_sweep.a0);
  var tMat = xf1.R;
  var tVec = this.m_sweep.localCenter;
  xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var f;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, xf1, this.m_xf)
  }
};
b2Body.prototype.SynchronizeTransform = function() {
  this.m_xf.R.Set(this.m_sweep.a);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
};
b2Body.prototype.ShouldCollide = function(other) {
  if(this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
    return false
  }
  for(var jn = this.m_jointList;jn;jn = jn.next) {
    if(jn.other == other) {
      if(jn.joint.m_collideConnected == false) {
        return false
      }
    }
  }
  return true
};
b2Body.prototype.Advance = function(t) {
  this.m_sweep.Advance(t);
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_sweep.a = this.m_sweep.a0;
  this.SynchronizeTransform()
};
b2Body.prototype.CreateFixture = function(def) {
  if(this.m_world.IsLocked() == true) {
    return null
  }
  var fixture = new b2Fixture;
  fixture.Create(this, this.m_xf, def);
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.CreateProxy(broadPhase, this.m_xf)
  }
  fixture.m_next = this.m_fixtureList;
  this.m_fixtureList = fixture;
  ++this.m_fixtureCount;
  fixture.m_body = this;
  if(fixture.m_density > 0) {
    this.ResetMassData()
  }
  this.m_world.m_flags |= b2World.e_newFixture;
  return fixture
};
b2Body.prototype.CreateFixture2 = function(shape, density) {
  var def = new b2FixtureDef;
  def.shape = shape;
  def.density = density;
  return this.CreateFixture(def)
};
b2Body.prototype.DestroyFixture = function(fixture) {
  if(this.m_world.IsLocked() == true) {
    return
  }
  var node = this.m_fixtureList;
  var ppF = null;
  var found = false;
  while(node != null) {
    if(node == fixture) {
      if(ppF) {
        ppF.m_next = fixture.m_next
      }else {
        this.m_fixtureList = fixture.m_next
      }
      found = true;
      break
    }
    ppF = node;
    node = node.m_next
  }
  var edge = this.m_contactList;
  while(edge) {
    var c = edge.contact;
    edge = edge.next;
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    if(fixture == fixtureA || fixture == fixtureB) {
      this.m_world.m_contactManager.Destroy(c)
    }
  }
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.DestroyProxy(broadPhase)
  }else {
  }
  fixture.Destroy();
  fixture.m_body = null;
  fixture.m_next = null;
  --this.m_fixtureCount;
  this.ResetMassData()
};
b2Body.prototype.SetPositionAndAngle = function(position, angle) {
  var f;
  if(this.m_world.IsLocked() == true) {
    return
  }
  this.m_xf.R.Set(angle);
  this.m_xf.position.SetV(position);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_sweep.a0 = this.m_sweep.a = angle;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, this.m_xf, this.m_xf)
  }
  this.m_world.m_contactManager.FindNewContacts()
};
b2Body.prototype.SetTransform = function(xf) {
  this.SetPositionAndAngle(xf.position, xf.GetAngle())
};
b2Body.prototype.GetTransform = function() {
  return this.m_xf
};
b2Body.prototype.GetPosition = function() {
  return this.m_xf.position
};
b2Body.prototype.SetPosition = function(position) {
  this.SetPositionAndAngle(position, this.GetAngle())
};
b2Body.prototype.GetAngle = function() {
  return this.m_sweep.a
};
b2Body.prototype.SetAngle = function(angle) {
  this.SetPositionAndAngle(this.GetPosition(), angle)
};
b2Body.prototype.GetWorldCenter = function() {
  return this.m_sweep.c
};
b2Body.prototype.GetLocalCenter = function() {
  return this.m_sweep.localCenter
};
b2Body.prototype.SetLinearVelocity = function(v) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_linearVelocity.SetV(v)
};
b2Body.prototype.GetLinearVelocity = function() {
  return this.m_linearVelocity
};
b2Body.prototype.SetAngularVelocity = function(omega) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_angularVelocity = omega
};
b2Body.prototype.GetAngularVelocity = function() {
  return this.m_angularVelocity
};
b2Body.prototype.GetDefinition = function() {
  var bd = new b2BodyDef;
  bd.type = this.GetType();
  bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
  bd.angle = this.GetAngle();
  bd.angularDamping = this.m_angularDamping;
  bd.angularVelocity = this.m_angularVelocity;
  bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
  bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
  bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
  bd.linearDamping = this.m_linearDamping;
  bd.linearVelocity.SetV(this.GetLinearVelocity());
  bd.position = this.GetPosition();
  bd.userData = this.GetUserData();
  return bd
};
b2Body.prototype.ApplyForce = function(force, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_force.x += force.x;
  this.m_force.y += force.y;
  this.m_torque += (point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x
};
b2Body.prototype.ApplyTorque = function(torque) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_torque += torque
};
b2Body.prototype.ApplyImpulse = function(impulse, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_linearVelocity.x += this.m_invMass * impulse.x;
  this.m_linearVelocity.y += this.m_invMass * impulse.y;
  this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x)
};
b2Body.prototype.Split = function(callback) {
  var linearVelocity = this.GetLinearVelocity().Copy();
  var angularVelocity = this.GetAngularVelocity();
  var center = this.GetWorldCenter();
  var body1 = this;
  var body2 = this.m_world.CreateBody(this.GetDefinition());
  var prev;
  for(var f = body1.m_fixtureList;f;) {
    if(callback(f)) {
      var next = f.m_next;
      if(prev) {
        prev.m_next = next
      }else {
        body1.m_fixtureList = next
      }
      body1.m_fixtureCount--;
      f.m_next = body2.m_fixtureList;
      body2.m_fixtureList = f;
      body2.m_fixtureCount++;
      f.m_body = body2;
      f = next
    }else {
      prev = f;
      f = f.m_next
    }
  }
  body1.ResetMassData();
  body2.ResetMassData();
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
  var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
  body1.SetLinearVelocity(velocity1);
  body2.SetLinearVelocity(velocity2);
  body1.SetAngularVelocity(angularVelocity);
  body2.SetAngularVelocity(angularVelocity);
  body1.SynchronizeFixtures();
  body2.SynchronizeFixtures();
  return body2
};
b2Body.prototype.Merge = function(other) {
  var f;
  for(f = other.m_fixtureList;f;) {
    var next = f.m_next;
    other.m_fixtureCount--;
    f.m_next = this.m_fixtureList;
    this.m_fixtureList = f;
    this.m_fixtureCount++;
    f.m_body = body2;
    f = next
  }
  body1.m_fixtureCount = 0;
  var body1 = this;
  var body2 = other;
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = body1.GetLinearVelocity().Copy();
  var velocity2 = body2.GetLinearVelocity().Copy();
  var angular1 = body1.GetAngularVelocity();
  var angular = body2.GetAngularVelocity();
  body1.ResetMassData();
  this.SynchronizeFixtures()
};
b2Body.prototype.GetMass = function() {
  return this.m_mass
};
b2Body.prototype.GetInertia = function() {
  return this.m_I
};
b2Body.prototype.GetMassData = function(data) {
  data.mass = this.m_mass;
  data.I = this.m_I;
  data.center.SetV(this.m_sweep.localCenter)
};
b2Body.prototype.SetMassData = function(massData) {
  b2Settings.b2Assert(this.m_world.IsLocked() == false);
  if(this.m_world.IsLocked() == true) {
    return
  }
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_mass = massData.mass;
  if(this.m_mass <= 0) {
    this.m_mass = 1
  }
  this.m_invMass = 1 / this.m_mass;
  if(massData.I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
    this.m_invI = 1 / this.m_I
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(massData.center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.ResetMassData = function() {
  this.m_mass = 0;
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_sweep.localCenter.SetZero();
  if(this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
    return
  }
  var center = b2Vec2.Make(0, 0);
  for(var f = this.m_fixtureList;f;f = f.m_next) {
    if(f.m_density == 0) {
      continue
    }
    var massData = f.GetMassData();
    this.m_mass += massData.mass;
    center.x += massData.center.x * massData.mass;
    center.y += massData.center.y * massData.mass;
    this.m_I += massData.I
  }
  if(this.m_mass > 0) {
    this.m_invMass = 1 / this.m_mass;
    center.x *= this.m_invMass;
    center.y *= this.m_invMass
  }else {
    this.m_mass = 1;
    this.m_invMass = 1
  }
  if(this.m_I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
    this.m_I *= this.m_inertiaScale;
    b2Settings.b2Assert(this.m_I > 0);
    this.m_invI = 1 / this.m_I
  }else {
    this.m_I = 0;
    this.m_invI = 0
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.GetWorldPoint = function(localPoint) {
  var A = this.m_xf.R;
  var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  u.x += this.m_xf.position.x;
  u.y += this.m_xf.position.y;
  return u
};
b2Body.prototype.GetWorldVector = function(localVector) {
  return b2Math.MulMV(this.m_xf.R, localVector)
};
b2Body.prototype.GetLocalPoint = function(worldPoint) {
  return b2Math.MulXT(this.m_xf, worldPoint)
};
b2Body.prototype.GetLocalVector = function(worldVector) {
  return b2Math.MulTMV(this.m_xf.R, worldVector)
};
b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint) {
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint) {
  var A = this.m_xf.R;
  var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  worldPoint.x += this.m_xf.position.x;
  worldPoint.y += this.m_xf.position.y;
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearDamping = function() {
  return this.m_linearDamping
};
b2Body.prototype.SetLinearDamping = function(linearDamping) {
  this.m_linearDamping = linearDamping
};
b2Body.prototype.GetAngularDamping = function() {
  return this.m_angularDamping
};
b2Body.prototype.SetAngularDamping = function(angularDamping) {
  this.m_angularDamping = angularDamping
};
b2Body.prototype.SetType = function(type) {
  if(this.m_type == type) {
    return
  }
  this.m_type = type;
  this.ResetMassData();
  if(this.m_type == b2Body.b2_staticBody) {
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0
  }
  this.SetAwake(true);
  this.m_force.SetZero();
  this.m_torque = 0;
  for(var ce = this.m_contactList;ce;ce = ce.next) {
    ce.contact.FlagForFiltering()
  }
};
b2Body.prototype.GetType = function() {
  return this.m_type
};
b2Body.prototype.SetBullet = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_bulletFlag
  }else {
    this.m_flags &= ~b2Body.e_bulletFlag
  }
};
b2Body.prototype.IsBullet = function() {
  return(this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag
};
b2Body.prototype.SetSleepingAllowed = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }else {
    this.m_flags &= ~b2Body.e_allowSleepFlag;
    this.SetAwake(true)
  }
};
b2Body.prototype.SetAwake = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_awakeFlag;
    this.m_sleepTime = 0
  }else {
    this.m_flags &= ~b2Body.e_awakeFlag;
    this.m_sleepTime = 0;
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0;
    this.m_force.SetZero();
    this.m_torque = 0
  }
};
b2Body.prototype.IsAwake = function() {
  return(this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag
};
b2Body.prototype.SetFixedRotation = function(fixed) {
  if(fixed) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }else {
    this.m_flags &= ~b2Body.e_fixedRotationFlag
  }
  this.ResetMassData()
};
b2Body.prototype.IsFixedRotation = function() {
  return(this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag
};
b2Body.prototype.SetActive = function(flag) {
  if(flag == this.IsActive()) {
    return
  }
  var broadPhase;
  var f;
  if(flag) {
    this.m_flags |= b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.CreateProxy(broadPhase, this.m_xf)
    }
  }else {
    this.m_flags &= ~b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.DestroyProxy(broadPhase)
    }
    var ce = this.m_contactList;
    while(ce) {
      var ce0 = ce;
      ce = ce.next;
      this.m_world.m_contactManager.Destroy(ce0.contact)
    }
    this.m_contactList = null
  }
};
b2Body.prototype.IsActive = function() {
  return(this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag
};
b2Body.prototype.IsSleepingAllowed = function() {
  return(this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag
};
b2Body.prototype.GetFixtureList = function() {
  return this.m_fixtureList
};
b2Body.prototype.GetJointList = function() {
  return this.m_jointList
};
b2Body.prototype.GetControllerList = function() {
  return this.m_controllerList
};
b2Body.prototype.GetContactList = function() {
  return this.m_contactList
};
b2Body.prototype.GetNext = function() {
  return this.m_next
};
b2Body.prototype.GetUserData = function() {
  return this.m_userData
};
b2Body.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Body.prototype.GetWorld = function() {
  return this.m_world
};
b2Body.prototype.m_flags = 0;
b2Body.prototype.m_type = 0;
b2Body.prototype.m_islandIndex = 0;
b2Body.prototype.m_xf = new b2Transform;
b2Body.prototype.m_sweep = new b2Sweep;
b2Body.prototype.m_linearVelocity = new b2Vec2;
b2Body.prototype.m_angularVelocity = null;
b2Body.prototype.m_force = new b2Vec2;
b2Body.prototype.m_torque = null;
b2Body.prototype.m_world = null;
b2Body.prototype.m_prev = null;
b2Body.prototype.m_next = null;
b2Body.prototype.m_fixtureList = null;
b2Body.prototype.m_fixtureCount = 0;
b2Body.prototype.m_controllerList = null;
b2Body.prototype.m_controllerCount = 0;
b2Body.prototype.m_jointList = null;
b2Body.prototype.m_contactList = null;
b2Body.prototype.m_mass = null;
b2Body.prototype.m_invMass = null;
b2Body.prototype.m_I = null;
b2Body.prototype.m_invI = null;
b2Body.prototype.m_inertiaScale = null;
b2Body.prototype.m_linearDamping = null;
b2Body.prototype.m_angularDamping = null;
b2Body.prototype.m_sleepTime = null;
b2Body.prototype.m_userData = null;var b2ContactImpulse = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactImpulse.prototype.__constructor = function() {
};
b2ContactImpulse.prototype.__varz = function() {
  this.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
  this.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints)
};
b2ContactImpulse.prototype.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
b2ContactImpulse.prototype.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints);var b2TensorDampingController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2TensorDampingController.prototype, b2Controller.prototype);
b2TensorDampingController.prototype._super = b2Controller.prototype;
b2TensorDampingController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2TensorDampingController.prototype.__varz = function() {
  this.T = new b2Mat22
};
b2TensorDampingController.prototype.SetAxisAligned = function(xDamping, yDamping) {
  this.T.col1.x = -xDamping;
  this.T.col1.y = 0;
  this.T.col2.x = 0;
  this.T.col2.y = -yDamping;
  if(xDamping > 0 || yDamping > 0) {
    this.maxTimestep = 1 / Math.max(xDamping, yDamping)
  }else {
    this.maxTimestep = 0
  }
};
b2TensorDampingController.prototype.Step = function(step) {
  var timestep = step.dt;
  if(timestep <= Number.MIN_VALUE) {
    return
  }
  if(timestep > this.maxTimestep && this.maxTimestep > 0) {
    timestep = this.maxTimestep
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep))
  }
};
b2TensorDampingController.prototype.T = new b2Mat22;
b2TensorDampingController.prototype.maxTimestep = 0;var b2ManifoldPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ManifoldPoint.prototype.__constructor = function() {
  this.Reset()
};
b2ManifoldPoint.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_id = new b2ContactID
};
b2ManifoldPoint.prototype.Reset = function() {
  this.m_localPoint.SetZero();
  this.m_normalImpulse = 0;
  this.m_tangentImpulse = 0;
  this.m_id.key = 0
};
b2ManifoldPoint.prototype.Set = function(m) {
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_normalImpulse = m.m_normalImpulse;
  this.m_tangentImpulse = m.m_tangentImpulse;
  this.m_id.Set(m.m_id)
};
b2ManifoldPoint.prototype.m_localPoint = new b2Vec2;
b2ManifoldPoint.prototype.m_normalImpulse = null;
b2ManifoldPoint.prototype.m_tangentImpulse = null;
b2ManifoldPoint.prototype.m_id = new b2ContactID;var b2PolygonShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonShape.prototype, b2Shape.prototype);
b2PolygonShape.prototype._super = b2Shape.prototype;
b2PolygonShape.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.m_type = b2Shape.e_polygonShape;
  this.m_centroid = new b2Vec2;
  this.m_vertices = new Array;
  this.m_normals = new Array
};
b2PolygonShape.prototype.__varz = function() {
};
b2PolygonShape.AsArray = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsArray(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsVector = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsVector(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsBox = function(hx, hy) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsBox(hx, hy);
  return polygonShape
};
b2PolygonShape.AsOrientedBox = function(hx, hy, center, angle) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsOrientedBox(hx, hy, center, angle);
  return polygonShape
};
b2PolygonShape.AsEdge = function(v1, v2) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsEdge(v1, v2);
  return polygonShape
};
b2PolygonShape.ComputeCentroid = function(vs, count) {
  var c = new b2Vec2;
  var area = 0;
  var p1X = 0;
  var p1Y = 0;
  var inv3 = 1 / 3;
  for(var i = 0;i < count;++i) {
    var p2 = vs[i];
    var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
    c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y)
  }
  c.x *= 1 / area;
  c.y *= 1 / area;
  return c
};
b2PolygonShape.ComputeOBB = function(obb, vs, count) {
  var i = 0;
  var p = new Array(count + 1);
  for(i = 0;i < count;++i) {
    p[i] = vs[i]
  }
  p[count] = p[0];
  var minArea = Number.MAX_VALUE;
  for(i = 1;i <= count;++i) {
    var root = p[parseInt(i - 1)];
    var uxX = p[i].x - root.x;
    var uxY = p[i].y - root.y;
    var length = Math.sqrt(uxX * uxX + uxY * uxY);
    uxX /= length;
    uxY /= length;
    var uyX = -uxY;
    var uyY = uxX;
    var lowerX = Number.MAX_VALUE;
    var lowerY = Number.MAX_VALUE;
    var upperX = -Number.MAX_VALUE;
    var upperY = -Number.MAX_VALUE;
    for(var j = 0;j < count;++j) {
      var dX = p[j].x - root.x;
      var dY = p[j].y - root.y;
      var rX = uxX * dX + uxY * dY;
      var rY = uyX * dX + uyY * dY;
      if(rX < lowerX) {
        lowerX = rX
      }
      if(rY < lowerY) {
        lowerY = rY
      }
      if(rX > upperX) {
        upperX = rX
      }
      if(rY > upperY) {
        upperY = rY
      }
    }
    var area = (upperX - lowerX) * (upperY - lowerY);
    if(area < 0.95 * minArea) {
      minArea = area;
      obb.R.col1.x = uxX;
      obb.R.col1.y = uxY;
      obb.R.col2.x = uyX;
      obb.R.col2.y = uyY;
      var centerX = 0.5 * (lowerX + upperX);
      var centerY = 0.5 * (lowerY + upperY);
      var tMat = obb.R;
      obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
      obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
      obb.extents.x = 0.5 * (upperX - lowerX);
      obb.extents.y = 0.5 * (upperY - lowerY)
    }
  }
};
b2PolygonShape.s_mat = new b2Mat22;
b2PolygonShape.prototype.Validate = function() {
  return false
};
b2PolygonShape.prototype.Reserve = function(count) {
  for(var i = this.m_vertices.length;i < count;i++) {
    this.m_vertices[i] = new b2Vec2;
    this.m_normals[i] = new b2Vec2
  }
};
b2PolygonShape.prototype.Copy = function() {
  var s = new b2PolygonShape;
  s.Set(this);
  return s
};
b2PolygonShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2PolygonShape)) {
    var other2 = other;
    this.m_centroid.SetV(other2.m_centroid);
    this.m_vertexCount = other2.m_vertexCount;
    this.Reserve(this.m_vertexCount);
    for(var i = 0;i < this.m_vertexCount;i++) {
      this.m_vertices[i].SetV(other2.m_vertices[i]);
      this.m_normals[i].SetV(other2.m_normals[i])
    }
  }
};
b2PolygonShape.prototype.SetAsArray = function(vertices, vertexCount) {
  var v = new Array;
  for(var i = 0, tVec = null;i < vertices.length, tVec = vertices[i];i++) {
    v.push(tVec)
  }
  this.SetAsVector(v, vertexCount)
};
b2PolygonShape.prototype.SetAsVector = function(vertices, vertexCount) {
  if(typeof vertexCount == "undefined") {
    vertexCount = vertices.length
  }
  b2Settings.b2Assert(2 <= vertexCount);
  this.m_vertexCount = vertexCount;
  this.Reserve(vertexCount);
  var i = 0;
  for(i = 0;i < this.m_vertexCount;i++) {
    this.m_vertices[i].SetV(vertices[i])
  }
  for(i = 0;i < this.m_vertexCount;++i) {
    var i1 = i;
    var i2 = i + 1 < this.m_vertexCount ? i + 1 : 0;
    var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
    b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
    this.m_normals[i].SetV(b2Math.CrossVF(edge, 1));
    this.m_normals[i].Normalize()
  }
  this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount)
};
b2PolygonShape.prototype.SetAsBox = function(hx, hy) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid.SetZero()
};
b2PolygonShape.prototype.SetAsOrientedBox = function(hx, hy, center, angle) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid = center;
  var xf = new b2Transform;
  xf.position = center;
  xf.R.Set(angle);
  for(var i = 0;i < this.m_vertexCount;++i) {
    this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
    this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i])
  }
};
b2PolygonShape.prototype.SetAsEdge = function(v1, v2) {
  this.m_vertexCount = 2;
  this.Reserve(2);
  this.m_vertices[0].SetV(v1);
  this.m_vertices[1].SetV(v2);
  this.m_centroid.x = 0.5 * (v1.x + v2.x);
  this.m_centroid.y = 0.5 * (v1.y + v2.y);
  this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1);
  this.m_normals[0].Normalize();
  this.m_normals[1].x = -this.m_normals[0].x;
  this.m_normals[1].y = -this.m_normals[0].y
};
b2PolygonShape.prototype.TestPoint = function(xf, p) {
  var tVec;
  var tMat = xf.R;
  var tX = p.x - xf.position.x;
  var tY = p.y - xf.position.y;
  var pLocalX = tX * tMat.col1.x + tY * tMat.col1.y;
  var pLocalY = tX * tMat.col2.x + tY * tMat.col2.y;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = pLocalX - tVec.x;
    tY = pLocalY - tVec.y;
    tVec = this.m_normals[i];
    var dot = tVec.x * tX + tVec.y * tY;
    if(dot > 0) {
      return false
    }
  }
  return true
};
b2PolygonShape.prototype.RayCast = function(output, input, transform) {
  var lower = 0;
  var upper = input.maxFraction;
  var tX;
  var tY;
  var tMat;
  var tVec;
  tX = input.p1.x - transform.position.x;
  tY = input.p1.y - transform.position.y;
  tMat = transform.R;
  var p1X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p1Y = tX * tMat.col2.x + tY * tMat.col2.y;
  tX = input.p2.x - transform.position.x;
  tY = input.p2.y - transform.position.y;
  tMat = transform.R;
  var p2X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p2Y = tX * tMat.col2.x + tY * tMat.col2.y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var index = -1;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = tVec.x - p1X;
    tY = tVec.y - p1Y;
    tVec = this.m_normals[i];
    var numerator = tVec.x * tX + tVec.y * tY;
    var denominator = tVec.x * dX + tVec.y * dY;
    if(denominator == 0) {
      if(numerator < 0) {
        return false
      }
    }else {
      if(denominator < 0 && numerator < lower * denominator) {
        lower = numerator / denominator;
        index = i
      }else {
        if(denominator > 0 && numerator < upper * denominator) {
          upper = numerator / denominator
        }
      }
    }
    if(upper < lower - Number.MIN_VALUE) {
      return false
    }
  }
  if(index >= 0) {
    output.fraction = lower;
    tMat = transform.R;
    tVec = this.m_normals[index];
    output.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    output.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    return true
  }
  return false
};
b2PolygonShape.prototype.ComputeAABB = function(aabb, xf) {
  var tMat = xf.R;
  var tVec = this.m_vertices[0];
  var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var upperX = lowerX;
  var upperY = lowerY;
  for(var i = 1;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    lowerX = lowerX < vX ? lowerX : vX;
    lowerY = lowerY < vY ? lowerY : vY;
    upperX = upperX > vX ? upperX : vX;
    upperY = upperY > vY ? upperY : vY
  }
  aabb.lowerBound.x = lowerX - this.m_radius;
  aabb.lowerBound.y = lowerY - this.m_radius;
  aabb.upperBound.x = upperX + this.m_radius;
  aabb.upperBound.y = upperY + this.m_radius
};
b2PolygonShape.prototype.ComputeMass = function(massData, density) {
  if(this.m_vertexCount == 2) {
    massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
    massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
    massData.mass = 0;
    massData.I = 0;
    return
  }
  var centerX = 0;
  var centerY = 0;
  var area = 0;
  var I = 0;
  var p1X = 0;
  var p1Y = 0;
  var k_inv3 = 1 / 3;
  for(var i = 0;i < this.m_vertexCount;++i) {
    var p2 = this.m_vertices[i];
    var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
    centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
    var px = p1X;
    var py = p1Y;
    var ex1 = e1X;
    var ey1 = e1Y;
    var ex2 = e2X;
    var ey2 = e2Y;
    var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
    var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
    I += D * (intx2 + inty2)
  }
  massData.mass = density * area;
  centerX *= 1 / area;
  centerY *= 1 / area;
  massData.center.Set(centerX, centerY);
  massData.I = density * I
};
b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var normalL = b2Math.MulTMV(xf.R, normal);
  var offsetL = offset - b2Math.Dot(normal, xf.position);
  var depths = new Array;
  var diveCount = 0;
  var intoIndex = -1;
  var outoIndex = -1;
  var lastSubmerged = false;
  var i = 0;
  for(i = 0;i < this.m_vertexCount;++i) {
    depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
    var isSubmerged = depths[i] < -Number.MIN_VALUE;
    if(i > 0) {
      if(isSubmerged) {
        if(!lastSubmerged) {
          intoIndex = i - 1;
          diveCount++
        }
      }else {
        if(lastSubmerged) {
          outoIndex = i - 1;
          diveCount++
        }
      }
    }
    lastSubmerged = isSubmerged
  }
  switch(diveCount) {
    case 0:
      if(lastSubmerged) {
        var md = new b2MassData;
        this.ComputeMass(md, 1);
        c.SetV(b2Math.MulX(xf, md.center));
        return md.mass
      }else {
        return 0
      }
      break;
    case 1:
      if(intoIndex == -1) {
        intoIndex = this.m_vertexCount - 1
      }else {
        outoIndex = this.m_vertexCount - 1
      }
      break
  }
  var intoIndex2 = (intoIndex + 1) % this.m_vertexCount;
  var outoIndex2 = (outoIndex + 1) % this.m_vertexCount;
  var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
  var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
  var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
  var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
  var area = 0;
  var center = new b2Vec2;
  var p2 = this.m_vertices[intoIndex2];
  var p3;
  i = intoIndex2;
  while(i != outoIndex2) {
    i = (i + 1) % this.m_vertexCount;
    if(i == outoIndex2) {
      p3 = outoVec
    }else {
      p3 = this.m_vertices[i]
    }
    var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
    area += triangleArea;
    center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
    center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
    p2 = p3
  }
  center.Multiply(1 / area);
  c.SetV(b2Math.MulX(xf, center));
  return area
};
b2PolygonShape.prototype.GetVertexCount = function() {
  return this.m_vertexCount
};
b2PolygonShape.prototype.GetVertices = function() {
  return this.m_vertices
};
b2PolygonShape.prototype.GetNormals = function() {
  return this.m_normals
};
b2PolygonShape.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2PolygonShape.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2PolygonShape.prototype.m_centroid = null;
b2PolygonShape.prototype.m_vertices = null;
b2PolygonShape.prototype.m_normals = null;
b2PolygonShape.prototype.m_vertexCount = 0;var b2Fixture = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Fixture.prototype.__constructor = function() {
  this.m_aabb = new b2AABB;
  this.m_userData = null;
  this.m_body = null;
  this.m_next = null;
  this.m_shape = null;
  this.m_density = 0;
  this.m_friction = 0;
  this.m_restitution = 0
};
b2Fixture.prototype.__varz = function() {
  this.m_filter = new b2FilterData
};
b2Fixture.prototype.Create = function(body, xf, def) {
  this.m_userData = def.userData;
  this.m_friction = def.friction;
  this.m_restitution = def.restitution;
  this.m_body = body;
  this.m_next = null;
  this.m_filter = def.filter.Copy();
  this.m_isSensor = def.isSensor;
  this.m_shape = def.shape.Copy();
  this.m_density = def.density
};
b2Fixture.prototype.Destroy = function() {
  this.m_shape = null
};
b2Fixture.prototype.CreateProxy = function(broadPhase, xf) {
  this.m_shape.ComputeAABB(this.m_aabb, xf);
  this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this)
};
b2Fixture.prototype.DestroyProxy = function(broadPhase) {
  if(this.m_proxy == null) {
    return
  }
  broadPhase.DestroyProxy(this.m_proxy);
  this.m_proxy = null
};
b2Fixture.prototype.Synchronize = function(broadPhase, transform1, transform2) {
  if(!this.m_proxy) {
    return
  }
  var aabb1 = new b2AABB;
  var aabb2 = new b2AABB;
  this.m_shape.ComputeAABB(aabb1, transform1);
  this.m_shape.ComputeAABB(aabb2, transform2);
  this.m_aabb.Combine(aabb1, aabb2);
  var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
  broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement)
};
b2Fixture.prototype.GetType = function() {
  return this.m_shape.GetType()
};
b2Fixture.prototype.GetShape = function() {
  return this.m_shape
};
b2Fixture.prototype.SetSensor = function(sensor) {
  if(this.m_isSensor == sensor) {
    return
  }
  this.m_isSensor = sensor;
  if(this.m_body == null) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor())
    }
    edge = edge.next
  }
};
b2Fixture.prototype.IsSensor = function() {
  return this.m_isSensor
};
b2Fixture.prototype.SetFilterData = function(filter) {
  this.m_filter = filter.Copy();
  if(this.m_body) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.FlagForFiltering()
    }
    edge = edge.next
  }
};
b2Fixture.prototype.GetFilterData = function() {
  return this.m_filter.Copy()
};
b2Fixture.prototype.GetBody = function() {
  return this.m_body
};
b2Fixture.prototype.GetNext = function() {
  return this.m_next
};
b2Fixture.prototype.GetUserData = function() {
  return this.m_userData
};
b2Fixture.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Fixture.prototype.TestPoint = function(p) {
  return this.m_shape.TestPoint(this.m_body.GetTransform(), p)
};
b2Fixture.prototype.RayCast = function(output, input) {
  return this.m_shape.RayCast(output, input, this.m_body.GetTransform())
};
b2Fixture.prototype.GetMassData = function(massData) {
  if(massData == null) {
    massData = new b2MassData
  }
  this.m_shape.ComputeMass(massData, this.m_density);
  return massData
};
b2Fixture.prototype.SetDensity = function(density) {
  this.m_density = density
};
b2Fixture.prototype.GetDensity = function() {
  return this.m_density
};
b2Fixture.prototype.GetFriction = function() {
  return this.m_friction
};
b2Fixture.prototype.SetFriction = function(friction) {
  this.m_friction = friction
};
b2Fixture.prototype.GetRestitution = function() {
  return this.m_restitution
};
b2Fixture.prototype.SetRestitution = function(restitution) {
  this.m_restitution = restitution
};
b2Fixture.prototype.GetAABB = function() {
  return this.m_aabb
};
b2Fixture.prototype.m_massData = null;
b2Fixture.prototype.m_aabb = null;
b2Fixture.prototype.m_density = null;
b2Fixture.prototype.m_next = null;
b2Fixture.prototype.m_body = null;
b2Fixture.prototype.m_shape = null;
b2Fixture.prototype.m_friction = null;
b2Fixture.prototype.m_restitution = null;
b2Fixture.prototype.m_proxy = null;
b2Fixture.prototype.m_filter = new b2FilterData;
b2Fixture.prototype.m_isSensor = null;
b2Fixture.prototype.m_userData = null;var b2DynamicTreeNode = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeNode.prototype.__constructor = function() {
};
b2DynamicTreeNode.prototype.__varz = function() {
  this.aabb = new b2AABB
};
b2DynamicTreeNode.prototype.IsLeaf = function() {
  return this.child1 == null
};
b2DynamicTreeNode.prototype.userData = null;
b2DynamicTreeNode.prototype.aabb = new b2AABB;
b2DynamicTreeNode.prototype.parent = null;
b2DynamicTreeNode.prototype.child1 = null;
b2DynamicTreeNode.prototype.child2 = null;var b2BodyDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BodyDef.prototype.__constructor = function() {
  this.userData = null;
  this.position.Set(0, 0);
  this.angle = 0;
  this.linearVelocity.Set(0, 0);
  this.angularVelocity = 0;
  this.linearDamping = 0;
  this.angularDamping = 0;
  this.allowSleep = true;
  this.awake = true;
  this.fixedRotation = false;
  this.bullet = false;
  this.type = b2Body.b2_staticBody;
  this.active = true;
  this.inertiaScale = 1
};
b2BodyDef.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.linearVelocity = new b2Vec2
};
b2BodyDef.prototype.type = 0;
b2BodyDef.prototype.position = new b2Vec2;
b2BodyDef.prototype.angle = null;
b2BodyDef.prototype.linearVelocity = new b2Vec2;
b2BodyDef.prototype.angularVelocity = null;
b2BodyDef.prototype.linearDamping = null;
b2BodyDef.prototype.angularDamping = null;
b2BodyDef.prototype.allowSleep = null;
b2BodyDef.prototype.awake = null;
b2BodyDef.prototype.fixedRotation = null;
b2BodyDef.prototype.bullet = null;
b2BodyDef.prototype.active = null;
b2BodyDef.prototype.userData = null;
b2BodyDef.prototype.inertiaScale = null;var b2DynamicTreeBroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeBroadPhase.prototype.__constructor = function() {
};
b2DynamicTreeBroadPhase.prototype.__varz = function() {
  this.m_tree = new b2DynamicTree;
  this.m_moveBuffer = new Array;
  this.m_pairBuffer = new Array
};
b2DynamicTreeBroadPhase.prototype.BufferMove = function(proxy) {
  this.m_moveBuffer[this.m_moveBuffer.length] = proxy
};
b2DynamicTreeBroadPhase.prototype.UnBufferMove = function(proxy) {
  var i = this.m_moveBuffer.indexOf(proxy);
  this.m_moveBuffer.splice(i, 1)
};
b2DynamicTreeBroadPhase.prototype.ComparePairs = function(pair1, pair2) {
  return 0
};
b2DynamicTreeBroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var proxy = this.m_tree.CreateProxy(aabb, userData);
  ++this.m_proxyCount;
  this.BufferMove(proxy);
  return proxy
};
b2DynamicTreeBroadPhase.prototype.DestroyProxy = function(proxy) {
  this.UnBufferMove(proxy);
  --this.m_proxyCount;
  this.m_tree.DestroyProxy(proxy)
};
b2DynamicTreeBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {
  var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
  if(buffer) {
    this.BufferMove(proxy)
  }
};
b2DynamicTreeBroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var aabbA = this.m_tree.GetFatAABB(proxyA);
  var aabbB = this.m_tree.GetFatAABB(proxyB);
  return aabbA.TestOverlap(aabbB)
};
b2DynamicTreeBroadPhase.prototype.GetUserData = function(proxy) {
  return this.m_tree.GetUserData(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetFatAABB = function(proxy) {
  return this.m_tree.GetFatAABB(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2DynamicTreeBroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairCount = 0;
  for(var i = 0, queryProxy = null;i < this.m_moveBuffer.length, queryProxy = this.m_moveBuffer[i];i++) {
    var that = this;
    function QueryCallback(proxy) {
      if(proxy == queryProxy) {
        return true
      }
      if(that.m_pairCount == that.m_pairBuffer.length) {
        that.m_pairBuffer[that.m_pairCount] = new b2DynamicTreePair
      }
      var pair = that.m_pairBuffer[that.m_pairCount];
      pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
      pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
      ++that.m_pairCount;
      return true
    }
    var fatAABB = this.m_tree.GetFatAABB(queryProxy);
    this.m_tree.Query(QueryCallback, fatAABB)
  }
  this.m_moveBuffer.length = 0;
  for(var i = 0;i < this.m_pairCount;) {
    var primaryPair = this.m_pairBuffer[i];
    var userDataA = this.m_tree.GetUserData(primaryPair.proxyA);
    var userDataB = this.m_tree.GetUserData(primaryPair.proxyB);
    callback(userDataA, userDataB);
    ++i;
    while(i < this.m_pairCount) {
      var pair = this.m_pairBuffer[i];
      if(pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
        break
      }
      ++i
    }
  }
};
b2DynamicTreeBroadPhase.prototype.Query = function(callback, aabb) {
  this.m_tree.Query(callback, aabb)
};
b2DynamicTreeBroadPhase.prototype.RayCast = function(callback, input) {
  this.m_tree.RayCast(callback, input)
};
b2DynamicTreeBroadPhase.prototype.Validate = function() {
};
b2DynamicTreeBroadPhase.prototype.Rebalance = function(iterations) {
  this.m_tree.Rebalance(iterations)
};
b2DynamicTreeBroadPhase.prototype.m_tree = new b2DynamicTree;
b2DynamicTreeBroadPhase.prototype.m_proxyCount = 0;
b2DynamicTreeBroadPhase.prototype.m_moveBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairCount = 0;var b2BroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BroadPhase.prototype.__constructor = function(worldAABB) {
  var i = 0;
  this.m_pairManager.Initialize(this);
  this.m_worldAABB = worldAABB;
  this.m_proxyCount = 0;
  this.m_bounds = new Array;
  for(i = 0;i < 2;i++) {
    this.m_bounds[i] = new Array
  }
  var dX = worldAABB.upperBound.x - worldAABB.lowerBound.x;
  var dY = worldAABB.upperBound.y - worldAABB.lowerBound.y;
  this.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX;
  this.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY;
  this.m_timeStamp = 1;
  this.m_queryResultCount = 0
};
b2BroadPhase.prototype.__varz = function() {
  this.m_pairManager = new b2PairManager;
  this.m_proxyPool = new Array;
  this.m_querySortKeys = new Array;
  this.m_queryResults = new Array;
  this.m_quantizationFactor = new b2Vec2
};
b2BroadPhase.BinarySearch = function(bounds, count, value) {
  var low = 0;
  var high = count - 1;
  while(low <= high) {
    var mid = Math.round((low + high) / 2);
    var bound = bounds[mid];
    if(bound.value > value) {
      high = mid - 1
    }else {
      if(bound.value < value) {
        low = mid + 1
      }else {
        return parseInt(mid)
      }
    }
  }
  return parseInt(low)
};
b2BroadPhase.s_validate = false;
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX;
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX;
b2BroadPhase.prototype.ComputeBounds = function(lowerValues, upperValues, aabb) {
  var minVertexX = aabb.lowerBound.x;
  var minVertexY = aabb.lowerBound.y;
  minVertexX = b2Math.Min(minVertexX, this.m_worldAABB.upperBound.x);
  minVertexY = b2Math.Min(minVertexY, this.m_worldAABB.upperBound.y);
  minVertexX = b2Math.Max(minVertexX, this.m_worldAABB.lowerBound.x);
  minVertexY = b2Math.Max(minVertexY, this.m_worldAABB.lowerBound.y);
  var maxVertexX = aabb.upperBound.x;
  var maxVertexY = aabb.upperBound.y;
  maxVertexX = b2Math.Min(maxVertexX, this.m_worldAABB.upperBound.x);
  maxVertexY = b2Math.Min(maxVertexY, this.m_worldAABB.upperBound.y);
  maxVertexX = b2Math.Max(maxVertexX, this.m_worldAABB.lowerBound.x);
  maxVertexY = b2Math.Max(maxVertexY, this.m_worldAABB.lowerBound.y);
  lowerValues[0] = parseInt(this.m_quantizationFactor.x * (minVertexX - this.m_worldAABB.lowerBound.x)) & b2Settings.USHRT_MAX - 1;
  upperValues[0] = parseInt(this.m_quantizationFactor.x * (maxVertexX - this.m_worldAABB.lowerBound.x)) % 65535 | 1;
  lowerValues[1] = parseInt(this.m_quantizationFactor.y * (minVertexY - this.m_worldAABB.lowerBound.y)) & b2Settings.USHRT_MAX - 1;
  upperValues[1] = parseInt(this.m_quantizationFactor.y * (maxVertexY - this.m_worldAABB.lowerBound.y)) % 65535 | 1
};
b2BroadPhase.prototype.TestOverlapValidate = function(p1, p2) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound1 = bounds[p1.lowerBounds[axis]];
    var bound2 = bounds[p2.upperBounds[axis]];
    if(bound1.value > bound2.value) {
      return false
    }
    bound1 = bounds[p1.upperBounds[axis]];
    bound2 = bounds[p2.lowerBounds[axis]];
    if(bound1.value < bound2.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.QueryAxis = function(lowerQueryOut, upperQueryOut, lowerValue, upperValue, bounds, boundCount, axis) {
  var lowerQuery = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue);
  var upperQuery = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue);
  var bound;
  for(var j = lowerQuery;j < upperQuery;++j) {
    bound = bounds[j];
    if(bound.IsLower()) {
      this.IncrementOverlapCount(bound.proxy)
    }
  }
  if(lowerQuery > 0) {
    var i = lowerQuery - 1;
    bound = bounds[i];
    var s = bound.stabbingCount;
    while(s) {
      bound = bounds[i];
      if(bound.IsLower()) {
        var proxy = bound.proxy;
        if(lowerQuery <= proxy.upperBounds[axis]) {
          this.IncrementOverlapCount(bound.proxy);
          --s
        }
      }
      --i
    }
  }
  lowerQueryOut[0] = lowerQuery;
  upperQueryOut[0] = upperQuery
};
b2BroadPhase.prototype.IncrementOverlapCount = function(proxy) {
  if(proxy.timeStamp < this.m_timeStamp) {
    proxy.timeStamp = this.m_timeStamp;
    proxy.overlapCount = 1
  }else {
    proxy.overlapCount = 2;
    this.m_queryResults[this.m_queryResultCount] = proxy;
    ++this.m_queryResultCount
  }
};
b2BroadPhase.prototype.IncrementTimeStamp = function() {
  if(this.m_timeStamp == b2Settings.USHRT_MAX) {
    for(var i = 0;i < this.m_proxyPool.length;++i) {
      this.m_proxyPool[i].timeStamp = 0
    }
    this.m_timeStamp = 1
  }else {
    ++this.m_timeStamp
  }
};
b2BroadPhase.prototype.InRange = function(aabb) {
  var dX;
  var dY;
  var d2X;
  var d2Y;
  dX = aabb.lowerBound.x;
  dY = aabb.lowerBound.y;
  dX -= this.m_worldAABB.upperBound.x;
  dY -= this.m_worldAABB.upperBound.y;
  d2X = this.m_worldAABB.lowerBound.x;
  d2Y = this.m_worldAABB.lowerBound.y;
  d2X -= aabb.upperBound.x;
  d2Y -= aabb.upperBound.y;
  dX = b2Math.Max(dX, d2X);
  dY = b2Math.Max(dY, d2Y);
  return b2Math.Max(dX, dY) < 0
};
b2BroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var index = 0;
  var proxy;
  var i = 0;
  var j = 0;
  if(!this.m_freeProxy) {
    this.m_freeProxy = this.m_proxyPool[this.m_proxyCount] = new b2Proxy;
    this.m_freeProxy.next = null;
    this.m_freeProxy.timeStamp = 0;
    this.m_freeProxy.overlapCount = b2BroadPhase.b2_invalid;
    this.m_freeProxy.userData = null;
    for(i = 0;i < 2;i++) {
      j = this.m_proxyCount * 2;
      this.m_bounds[i][j++] = new b2Bound;
      this.m_bounds[i][j] = new b2Bound
    }
  }
  proxy = this.m_freeProxy;
  this.m_freeProxy = proxy.next;
  proxy.overlapCount = 0;
  proxy.userData = userData;
  var boundCount = 2 * this.m_proxyCount;
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = 0;
    var upperIndex = 0;
    var lowerIndexOut = new Array;
    lowerIndexOut.push(lowerIndex);
    var upperIndexOut = new Array;
    upperIndexOut.push(upperIndex);
    this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
    lowerIndex = lowerIndexOut[0];
    upperIndex = upperIndexOut[0];
    bounds.splice(upperIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    bounds.splice(lowerIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    ++upperIndex;
    var tBound1 = bounds[lowerIndex];
    var tBound2 = bounds[upperIndex];
    tBound1.value = lowerValues[axis];
    tBound1.proxy = proxy;
    tBound2.value = upperValues[axis];
    tBound2.proxy = proxy;
    var tBoundAS3 = bounds[parseInt(lowerIndex - 1)];
    tBound1.stabbingCount = lowerIndex == 0 ? 0 : tBoundAS3.stabbingCount;
    tBoundAS3 = bounds[parseInt(upperIndex - 1)];
    tBound2.stabbingCount = tBoundAS3.stabbingCount;
    for(index = lowerIndex;index < upperIndex;++index) {
      tBoundAS3 = bounds[index];
      tBoundAS3.stabbingCount++
    }
    for(index = lowerIndex;index < boundCount + 2;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
  }
  ++this.m_proxyCount;
  for(i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.AddBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return proxy
};
b2BroadPhase.prototype.DestroyProxy = function(proxy_) {
  var proxy = proxy_;
  var tBound1;
  var tBound2;
  var boundCount = 2 * this.m_proxyCount;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    tBound1 = bounds[lowerIndex];
    var lowerValue = tBound1.value;
    tBound2 = bounds[upperIndex];
    var upperValue = tBound2.value;
    bounds.splice(upperIndex, 1);
    bounds.splice(lowerIndex, 1);
    bounds.push(tBound1);
    bounds.push(tBound2);
    var tEnd = boundCount - 2;
    for(var index = lowerIndex;index < tEnd;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
    tEnd = upperIndex - 1;
    for(var index2 = lowerIndex;index2 < tEnd;++index2) {
      tBound1 = bounds[index2];
      tBound1.stabbingCount--
    }
    var ignore = new Array;
    this.QueryAxis(ignore, ignore, lowerValue, upperValue, bounds, boundCount - 2, axis)
  }
  for(var i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.RemoveBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  proxy.userData = null;
  proxy.overlapCount = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[0] = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[1] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[0] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[1] = b2BroadPhase.b2_invalid;
  proxy.next = this.m_freeProxy;
  this.m_freeProxy = proxy;
  --this.m_proxyCount
};
b2BroadPhase.prototype.MoveProxy = function(proxy_, aabb, displacement) {
  var proxy = proxy_;
  var as3arr;
  var as3int = 0;
  var axis = 0;
  var index = 0;
  var bound;
  var prevBound;
  var nextBound;
  var nextProxyId = 0;
  var nextProxy;
  if(proxy == null) {
    return
  }
  if(aabb.IsValid() == false) {
    return
  }
  var boundCount = 2 * this.m_proxyCount;
  var newValues = new b2BoundValues;
  this.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);
  var oldValues = new b2BoundValues;
  for(axis = 0;axis < 2;++axis) {
    bound = this.m_bounds[axis][proxy.lowerBounds[axis]];
    oldValues.lowerValues[axis] = bound.value;
    bound = this.m_bounds[axis][proxy.upperBounds[axis]];
    oldValues.upperValues[axis] = bound.value
  }
  for(axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    var lowerValue = newValues.lowerValues[axis];
    var upperValue = newValues.upperValues[axis];
    bound = bounds[lowerIndex];
    var deltaLower = lowerValue - bound.value;
    bound.value = lowerValue;
    bound = bounds[upperIndex];
    var deltaUpper = upperValue - bound.value;
    bound.value = upperValue;
    if(deltaLower < 0) {
      index = lowerIndex;
      while(index > 0 && lowerValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        var prevProxy = prevBound.proxy;
        prevBound.stabbingCount++;
        if(prevBound.IsUpper() == true) {
          if(this.TestOverlapBound(newValues, prevProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        --index
      }
    }
    if(deltaUpper > 0) {
      index = upperIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= upperValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount++;
        if(nextBound.IsLower() == true) {
          if(this.TestOverlapBound(newValues, nextProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaLower > 0) {
      index = lowerIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= lowerValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount--;
        if(nextBound.IsUpper()) {
          if(this.TestOverlapBound(oldValues, nextProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaUpper < 0) {
      index = upperIndex;
      while(index > 0 && upperValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        prevProxy = prevBound.proxy;
        prevBound.stabbingCount--;
        if(prevBound.IsLower() == true) {
          if(this.TestOverlapBound(oldValues, prevProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        index--
      }
    }
  }
};
b2BroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairManager.Commit(callback)
};
b2BroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var proxyA_ = proxyA;
  var proxyB_ = proxyB;
  if(proxyA_.lowerBounds[0] > proxyB_.upperBounds[0]) {
    return false
  }
  if(proxyB_.lowerBounds[0] > proxyA_.upperBounds[0]) {
    return false
  }
  if(proxyA_.lowerBounds[1] > proxyB_.upperBounds[1]) {
    return false
  }
  if(proxyB_.lowerBounds[1] > proxyA_.upperBounds[1]) {
    return false
  }
  return true
};
b2BroadPhase.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2BroadPhase.prototype.GetFatAABB = function(proxy_) {
  var aabb = new b2AABB;
  var proxy = proxy_;
  aabb.lowerBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.lowerBounds[0]].value / this.m_quantizationFactor.x;
  aabb.lowerBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.lowerBounds[1]].value / this.m_quantizationFactor.y;
  aabb.upperBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.upperBounds[0]].value / this.m_quantizationFactor.x;
  aabb.upperBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.upperBounds[1]].value / this.m_quantizationFactor.y;
  return aabb
};
b2BroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2BroadPhase.prototype.Query = function(callback, aabb) {
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  for(var i = 0;i < this.m_queryResultCount;++i) {
    var proxy = this.m_queryResults[i];
    if(!callback(proxy)) {
      break
    }
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp()
};
b2BroadPhase.prototype.Validate = function() {
  var pair;
  var proxy1;
  var proxy2;
  var overlap;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var boundCount = 2 * this.m_proxyCount;
    var stabbingCount = 0;
    for(var i = 0;i < boundCount;++i) {
      var bound = bounds[i];
      if(bound.IsLower() == true) {
        stabbingCount++
      }else {
        stabbingCount--
      }
    }
  }
};
b2BroadPhase.prototype.Rebalance = function(iterations) {
};
b2BroadPhase.prototype.RayCast = function(callback, input) {
  var subInput = new b2RayCastInput;
  subInput.p1.SetV(input.p1);
  subInput.p2.SetV(input.p2);
  subInput.maxFraction = input.maxFraction;
  var dx = (input.p2.x - input.p1.x) * this.m_quantizationFactor.x;
  var dy = (input.p2.y - input.p1.y) * this.m_quantizationFactor.y;
  var sx = dx < -Number.MIN_VALUE ? -1 : dx > Number.MIN_VALUE ? 1 : 0;
  var sy = dy < -Number.MIN_VALUE ? -1 : dy > Number.MIN_VALUE ? 1 : 0;
  var p1x = this.m_quantizationFactor.x * (input.p1.x - this.m_worldAABB.lowerBound.x);
  var p1y = this.m_quantizationFactor.y * (input.p1.y - this.m_worldAABB.lowerBound.y);
  var startValues = new Array;
  var startValues2 = new Array;
  startValues[0] = parseInt(p1x) & b2Settings.USHRT_MAX - 1;
  startValues[1] = parseInt(p1y) & b2Settings.USHRT_MAX - 1;
  startValues2[0] = startValues[0] + 1;
  startValues2[1] = startValues[1] + 1;
  var startIndices = new Array;
  var xIndex = 0;
  var yIndex = 0;
  var proxy;
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[0], startValues2[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  if(sx >= 0) {
    xIndex = upperIndexOut[0] - 1
  }else {
    xIndex = lowerIndexOut[0]
  }
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[1], startValues2[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  if(sy >= 0) {
    yIndex = upperIndexOut[0] - 1
  }else {
    yIndex = lowerIndexOut[0]
  }
  for(var i = 0;i < this.m_queryResultCount;i++) {
    subInput.maxFraction = callback(this.m_queryResults[i], subInput)
  }
  for(;;) {
    var xProgress = 0;
    var yProgress = 0;
    xIndex += sx >= 0 ? 1 : -1;
    if(xIndex < 0 || xIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sx != 0) {
      xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
    }
    yIndex += sy >= 0 ? 1 : -1;
    if(yIndex < 0 || yIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sy != 0) {
      yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
    }
    for(;;) {
      if(sy == 0 || sx != 0 && xProgress < yProgress) {
        if(xProgress > subInput.maxFraction) {
          break
        }
        if(sx > 0 ? this.m_bounds[0][xIndex].IsLower() : this.m_bounds[0][xIndex].IsUpper()) {
          proxy = this.m_bounds[0][xIndex].proxy;
          if(sy >= 0) {
            if(proxy.lowerBounds[1] <= yIndex - 1 && proxy.upperBounds[1] >= yIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[1] <= yIndex && proxy.upperBounds[1] >= yIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sx > 0) {
          xIndex++;
          if(xIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          xIndex--;
          if(xIndex < 0) {
            break
          }
        }
        xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
      }else {
        if(yProgress > subInput.maxFraction) {
          break
        }
        if(sy > 0 ? this.m_bounds[1][yIndex].IsLower() : this.m_bounds[1][yIndex].IsUpper()) {
          proxy = this.m_bounds[1][yIndex].proxy;
          if(sx >= 0) {
            if(proxy.lowerBounds[0] <= xIndex - 1 && proxy.upperBounds[0] >= xIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[0] <= xIndex && proxy.upperBounds[0] >= xIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sy > 0) {
          yIndex++;
          if(yIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          yIndex--;
          if(yIndex < 0) {
            break
          }
        }
        yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
      }
    }
    break
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return
};
b2BroadPhase.prototype.TestOverlapBound = function(b, p) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound = bounds[p.upperBounds[axis]];
    if(b.lowerValues[axis] > bound.value) {
      return false
    }
    bound = bounds[p.lowerBounds[axis]];
    if(b.upperValues[axis] < bound.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.m_pairManager = new b2PairManager;
b2BroadPhase.prototype.m_proxyPool = new Array;
b2BroadPhase.prototype.m_freeProxy = null;
b2BroadPhase.prototype.m_bounds = null;
b2BroadPhase.prototype.m_querySortKeys = new Array;
b2BroadPhase.prototype.m_queryResults = new Array;
b2BroadPhase.prototype.m_queryResultCount = 0;
b2BroadPhase.prototype.m_worldAABB = null;
b2BroadPhase.prototype.m_quantizationFactor = new b2Vec2;
b2BroadPhase.prototype.m_proxyCount = 0;
b2BroadPhase.prototype.m_timeStamp = 0;var b2Manifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Manifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2ManifoldPoint
  }
  this.m_localPlaneNormal = new b2Vec2;
  this.m_localPoint = new b2Vec2
};
b2Manifold.prototype.__varz = function() {
};
b2Manifold.e_circles = 1;
b2Manifold.e_faceA = 2;
b2Manifold.e_faceB = 4;
b2Manifold.prototype.Reset = function() {
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Reset()
  }
  this.m_localPlaneNormal.SetZero();
  this.m_localPoint.SetZero();
  this.m_type = 0;
  this.m_pointCount = 0
};
b2Manifold.prototype.Set = function(m) {
  this.m_pointCount = m.m_pointCount;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Set(m.m_points[i])
  }
  this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_type = m.m_type
};
b2Manifold.prototype.Copy = function() {
  var copy = new b2Manifold;
  copy.Set(this);
  return copy
};
b2Manifold.prototype.m_points = null;
b2Manifold.prototype.m_localPlaneNormal = null;
b2Manifold.prototype.m_localPoint = null;
b2Manifold.prototype.m_type = 0;
b2Manifold.prototype.m_pointCount = 0;var b2CircleShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleShape.prototype, b2Shape.prototype);
b2CircleShape.prototype._super = b2Shape.prototype;
b2CircleShape.prototype.__constructor = function(radius) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_circleShape;
  this.m_radius = radius
};
b2CircleShape.prototype.__varz = function() {
  this.m_p = new b2Vec2
};
b2CircleShape.prototype.Copy = function() {
  var s = new b2CircleShape;
  s.Set(this);
  return s
};
b2CircleShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2CircleShape)) {
    var other2 = other;
    this.m_p.SetV(other2.m_p)
  }
};
b2CircleShape.prototype.TestPoint = function(transform, p) {
  var tMat = transform.R;
  var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  dX = p.x - dX;
  dY = p.y - dY;
  return dX * dX + dY * dY <= this.m_radius * this.m_radius
};
b2CircleShape.prototype.RayCast = function(output, input, transform) {
  var tMat = transform.R;
  var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  var sX = input.p1.x - positionX;
  var sY = input.p1.y - positionY;
  var b = sX * sX + sY * sY - this.m_radius * this.m_radius;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  var c = sX * rX + sY * rY;
  var rr = rX * rX + rY * rY;
  var sigma = c * c - rr * b;
  if(sigma < 0 || rr < Number.MIN_VALUE) {
    return false
  }
  var a = -(c + Math.sqrt(sigma));
  if(0 <= a && a <= input.maxFraction * rr) {
    a /= rr;
    output.fraction = a;
    output.normal.x = sX + a * rX;
    output.normal.y = sY + a * rY;
    output.normal.Normalize();
    return true
  }
  return false
};
b2CircleShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
  aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius)
};
b2CircleShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
  massData.center.SetV(this.m_p);
  massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
};
b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var p = b2Math.MulX(xf, this.m_p);
  var l = -(b2Math.Dot(normal, p) - offset);
  if(l < -this.m_radius + Number.MIN_VALUE) {
    return 0
  }
  if(l > this.m_radius) {
    c.SetV(p);
    return Math.PI * this.m_radius * this.m_radius
  }
  var r2 = this.m_radius * this.m_radius;
  var l2 = l * l;
  var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
  var com = -2 / 3 * Math.pow(r2 - l2, 1.5) / area;
  c.x = p.x + normal.x * com;
  c.y = p.y + normal.y * com;
  return area
};
b2CircleShape.prototype.GetLocalPosition = function() {
  return this.m_p
};
b2CircleShape.prototype.SetLocalPosition = function(position) {
  this.m_p.SetV(position)
};
b2CircleShape.prototype.GetRadius = function() {
  return this.m_radius
};
b2CircleShape.prototype.SetRadius = function(radius) {
  this.m_radius = radius
};
b2CircleShape.prototype.m_p = new b2Vec2;var b2Joint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Joint.prototype.__constructor = function(def) {
  b2Settings.b2Assert(def.bodyA != def.bodyB);
  this.m_type = def.type;
  this.m_prev = null;
  this.m_next = null;
  this.m_bodyA = def.bodyA;
  this.m_bodyB = def.bodyB;
  this.m_collideConnected = def.collideConnected;
  this.m_islandFlag = false;
  this.m_userData = def.userData
};
b2Joint.prototype.__varz = function() {
  this.m_edgeA = new b2JointEdge;
  this.m_edgeB = new b2JointEdge;
  this.m_localCenterA = new b2Vec2;
  this.m_localCenterB = new b2Vec2
};
b2Joint.Create = function(def, allocator) {
  var joint = null;
  switch(def.type) {
    case b2Joint.e_distanceJoint:
      joint = new b2DistanceJoint(def);
      break;
    case b2Joint.e_mouseJoint:
      joint = new b2MouseJoint(def);
      break;
    case b2Joint.e_prismaticJoint:
      joint = new b2PrismaticJoint(def);
      break;
    case b2Joint.e_revoluteJoint:
      joint = new b2RevoluteJoint(def);
      break;
    case b2Joint.e_pulleyJoint:
      joint = new b2PulleyJoint(def);
      break;
    case b2Joint.e_gearJoint:
      joint = new b2GearJoint(def);
      break;
    case b2Joint.e_lineJoint:
      joint = new b2LineJoint(def);
      break;
    case b2Joint.e_weldJoint:
      joint = new b2WeldJoint(def);
      break;
    case b2Joint.e_frictionJoint:
      joint = new b2FrictionJoint(def);
      break;
    default:
      break
  }
  return joint
};
b2Joint.Destroy = function(joint, allocator) {
};
b2Joint.e_unknownJoint = 0;
b2Joint.e_revoluteJoint = 1;
b2Joint.e_prismaticJoint = 2;
b2Joint.e_distanceJoint = 3;
b2Joint.e_pulleyJoint = 4;
b2Joint.e_mouseJoint = 5;
b2Joint.e_gearJoint = 6;
b2Joint.e_lineJoint = 7;
b2Joint.e_weldJoint = 8;
b2Joint.e_frictionJoint = 9;
b2Joint.e_inactiveLimit = 0;
b2Joint.e_atLowerLimit = 1;
b2Joint.e_atUpperLimit = 2;
b2Joint.e_equalLimits = 3;
b2Joint.prototype.InitVelocityConstraints = function(step) {
};
b2Joint.prototype.SolveVelocityConstraints = function(step) {
};
b2Joint.prototype.FinalizeVelocityConstraints = function() {
};
b2Joint.prototype.SolvePositionConstraints = function(baumgarte) {
  return false
};
b2Joint.prototype.GetType = function() {
  return this.m_type
};
b2Joint.prototype.GetAnchorA = function() {
  return null
};
b2Joint.prototype.GetAnchorB = function() {
  return null
};
b2Joint.prototype.GetReactionForce = function(inv_dt) {
  return null
};
b2Joint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2Joint.prototype.GetBodyA = function() {
  return this.m_bodyA
};
b2Joint.prototype.GetBodyB = function() {
  return this.m_bodyB
};
b2Joint.prototype.GetNext = function() {
  return this.m_next
};
b2Joint.prototype.GetUserData = function() {
  return this.m_userData
};
b2Joint.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Joint.prototype.IsActive = function() {
  return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
};
b2Joint.prototype.m_type = 0;
b2Joint.prototype.m_prev = null;
b2Joint.prototype.m_next = null;
b2Joint.prototype.m_edgeA = new b2JointEdge;
b2Joint.prototype.m_edgeB = new b2JointEdge;
b2Joint.prototype.m_bodyA = null;
b2Joint.prototype.m_bodyB = null;
b2Joint.prototype.m_islandFlag = null;
b2Joint.prototype.m_collideConnected = null;
b2Joint.prototype.m_userData = null;
b2Joint.prototype.m_localCenterA = new b2Vec2;
b2Joint.prototype.m_localCenterB = new b2Vec2;
b2Joint.prototype.m_invMassA = null;
b2Joint.prototype.m_invMassB = null;
b2Joint.prototype.m_invIA = null;
b2Joint.prototype.m_invIB = null;var b2LineJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJoint.prototype, b2Joint.prototype);
b2LineJoint.prototype._super = b2Joint.prototype;
b2LineJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2LineJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat22;
  this.m_impulse = new b2Vec2
};
b2LineJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.y = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.y = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.y = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2LineJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve(new b2Vec2, -Cdot1, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0)
      }
    }
    var b = -Cdot1 - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
    var f2r;
    if(this.m_K.col1.x != 0) {
      f2r = b / this.m_K.col1.x + f1.x
    }else {
      f2r = f1.x
    }
    this.m_impulse.x = f2r;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y * this.m_a1;
    L2 = df.x * this.m_s2 + df.y * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2;
    if(this.m_K.col1.x != 0) {
      df2 = -Cdot1 / this.m_K.col1.x
    }else {
      df2 = 0
    }
    this.m_impulse.x += df2;
    PX = df2 * this.m_perp.x;
    PY = df2 * this.m_perp.y;
    L1 = df2 * this.m_s1;
    L2 = df2 * this.m_s2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2LineJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec2;
  var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1));
  angularError = 0;
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve(impulse, -C1, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var impulse1;
    if(k11 != 0) {
      impulse1 = -C1 / k11
    }else {
      impulse1 = 0
    }
    impulse.x = impulse1;
    impulse.y = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2LineJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2LineJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2LineJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
};
b2LineJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2LineJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2LineJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2LineJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2LineJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2LineJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2LineJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2LineJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2LineJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2LineJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2LineJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2LineJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2LineJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2LineJoint.prototype.GetMaxMotorForce = function() {
  return this.m_maxMotorForce
};
b2LineJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2LineJoint.prototype.m_localAnchor1 = new b2Vec2;
b2LineJoint.prototype.m_localAnchor2 = new b2Vec2;
b2LineJoint.prototype.m_localXAxis1 = new b2Vec2;
b2LineJoint.prototype.m_localYAxis1 = new b2Vec2;
b2LineJoint.prototype.m_axis = new b2Vec2;
b2LineJoint.prototype.m_perp = new b2Vec2;
b2LineJoint.prototype.m_s1 = null;
b2LineJoint.prototype.m_s2 = null;
b2LineJoint.prototype.m_a1 = null;
b2LineJoint.prototype.m_a2 = null;
b2LineJoint.prototype.m_K = new b2Mat22;
b2LineJoint.prototype.m_impulse = new b2Vec2;
b2LineJoint.prototype.m_motorMass = null;
b2LineJoint.prototype.m_motorImpulse = null;
b2LineJoint.prototype.m_lowerTranslation = null;
b2LineJoint.prototype.m_upperTranslation = null;
b2LineJoint.prototype.m_maxMotorForce = null;
b2LineJoint.prototype.m_motorSpeed = null;
b2LineJoint.prototype.m_enableLimit = null;
b2LineJoint.prototype.m_enableMotor = null;
b2LineJoint.prototype.m_limitState = 0;var b2ContactSolver = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactSolver.prototype.__constructor = function() {
};
b2ContactSolver.prototype.__varz = function() {
  this.m_step = new b2TimeStep;
  this.m_constraints = new Array
};
b2ContactSolver.s_worldManifold = new b2WorldManifold;
b2ContactSolver.s_psm = new b2PositionSolverManifold;
b2ContactSolver.prototype.Initialize = function(step, contacts, contactCount, allocator) {
  var contact;
  this.m_step.Set(step);
  this.m_allocator = allocator;
  var i = 0;
  var tVec;
  var tMat;
  this.m_constraintCount = contactCount;
  while(this.m_constraints.length < this.m_constraintCount) {
    this.m_constraints[this.m_constraints.length] = new b2ContactConstraint
  }
  for(i = 0;i < contactCount;++i) {
    contact = contacts[i];
    var fixtureA = contact.m_fixtureA;
    var fixtureB = contact.m_fixtureB;
    var shapeA = fixtureA.m_shape;
    var shapeB = fixtureB.m_shape;
    var radiusA = shapeA.m_radius;
    var radiusB = shapeB.m_radius;
    var bodyA = fixtureA.m_body;
    var bodyB = fixtureB.m_body;
    var manifold = contact.GetManifold();
    var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
    var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
    var vAX = bodyA.m_linearVelocity.x;
    var vAY = bodyA.m_linearVelocity.y;
    var vBX = bodyB.m_linearVelocity.x;
    var vBY = bodyB.m_linearVelocity.y;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    b2Settings.b2Assert(manifold.m_pointCount > 0);
    b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
    var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
    var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
    var cc = this.m_constraints[i];
    cc.bodyA = bodyA;
    cc.bodyB = bodyB;
    cc.manifold = manifold;
    cc.normal.x = normalX;
    cc.normal.y = normalY;
    cc.pointCount = manifold.m_pointCount;
    cc.friction = friction;
    cc.restitution = restitution;
    cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
    cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
    cc.localPoint.x = manifold.m_localPoint.x;
    cc.localPoint.y = manifold.m_localPoint.y;
    cc.radius = radiusA + radiusB;
    cc.type = manifold.m_type;
    for(var k = 0;k < cc.pointCount;++k) {
      var cp = manifold.m_points[k];
      var ccp = cc.points[k];
      ccp.normalImpulse = cp.m_normalImpulse;
      ccp.tangentImpulse = cp.m_tangentImpulse;
      ccp.localPoint.SetV(cp.m_localPoint);
      var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
      var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
      var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
      var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
      var rnA = rAX * normalY - rAY * normalX;
      var rnB = rBX * normalY - rBY * normalX;
      rnA *= rnA;
      rnB *= rnB;
      var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
      ccp.normalMass = 1 / kNormal;
      var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
      kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
      ccp.equalizedMass = 1 / kEqualized;
      var tangentX = normalY;
      var tangentY = -normalX;
      var rtA = rAX * tangentY - rAY * tangentX;
      var rtB = rBX * tangentY - rBY * tangentX;
      rtA *= rtA;
      rtB *= rtB;
      var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
      ccp.tangentMass = 1 / kTangent;
      ccp.velocityBias = 0;
      var tX = vBX + -wB * rBY - vAX - -wA * rAY;
      var tY = vBY + wB * rBX - vAY - wA * rAX;
      var vRel = cc.normal.x * tX + cc.normal.y * tY;
      if(vRel < -b2Settings.b2_velocityThreshold) {
        ccp.velocityBias += -cc.restitution * vRel
      }
    }
    if(cc.pointCount == 2) {
      var ccp1 = cc.points[0];
      var ccp2 = cc.points[1];
      var invMassA = bodyA.m_invMass;
      var invIA = bodyA.m_invI;
      var invMassB = bodyB.m_invMass;
      var invIB = bodyB.m_invI;
      var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
      var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
      var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
      var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
      var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
      var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
      var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
      var k_maxConditionNumber = 100;
      if(k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
        cc.K.col1.Set(k11, k12);
        cc.K.col2.Set(k12, k22);
        cc.K.GetInverse(cc.normalMass)
      }else {
        cc.pointCount = 1
      }
    }
  }
};
b2ContactSolver.prototype.InitVelocityConstraints = function(step) {
  var tVec;
  var tVec2;
  var tMat;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var tX;
    var j = 0;
    var tCount = 0;
    if(step.warmStarting) {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp = c.points[j];
        ccp.normalImpulse *= step.dtRatio;
        ccp.tangentImpulse *= step.dtRatio;
        var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
        var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
        bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
        bodyA.m_linearVelocity.x -= invMassA * PX;
        bodyA.m_linearVelocity.y -= invMassA * PY;
        bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
        bodyB.m_linearVelocity.x += invMassB * PX;
        bodyB.m_linearVelocity.y += invMassB * PY
      }
    }else {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp2 = c.points[j];
        ccp2.normalImpulse = 0;
        ccp2.tangentImpulse = 0
      }
    }
  }
};
b2ContactSolver.prototype.SolveVelocityConstraints = function() {
  var j = 0;
  var ccp;
  var rAX;
  var rAY;
  var rBX;
  var rBY;
  var dvX;
  var dvY;
  var vn;
  var vt;
  var lambda;
  var maxFriction;
  var newImpulse;
  var PX;
  var PY;
  var dX;
  var dY;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var tMat;
  var tVec;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    var vA = bodyA.m_linearVelocity;
    var vB = bodyB.m_linearVelocity;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var friction = c.friction;
    var tX;
    for(j = 0;j < c.pointCount;j++) {
      ccp = c.points[j];
      dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vt = dvX * tangentX + dvY * tangentY;
      lambda = ccp.tangentMass * -vt;
      maxFriction = friction * ccp.normalImpulse;
      newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction);
      lambda = newImpulse - ccp.tangentImpulse;
      PX = lambda * tangentX;
      PY = lambda * tangentY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.tangentImpulse = newImpulse
    }
    var tCount = c.pointCount;
    if(c.pointCount == 1) {
      ccp = c.points[0];
      dvX = vB.x + -wB * ccp.rB.y - vA.x - -wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vn = dvX * normalX + dvY * normalY;
      lambda = -ccp.normalMass * (vn - ccp.velocityBias);
      newImpulse = ccp.normalImpulse + lambda;
      newImpulse = newImpulse > 0 ? newImpulse : 0;
      lambda = newImpulse - ccp.normalImpulse;
      PX = lambda * normalX;
      PY = lambda * normalY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.normalImpulse = newImpulse
    }else {
      var cp1 = c.points[0];
      var cp2 = c.points[1];
      var aX = cp1.normalImpulse;
      var aY = cp2.normalImpulse;
      var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
      var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
      var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
      var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
      var vn1 = dv1X * normalX + dv1Y * normalY;
      var vn2 = dv2X * normalX + dv2Y * normalY;
      var bX = vn1 - cp1.velocityBias;
      var bY = vn2 - cp2.velocityBias;
      tMat = c.K;
      bX -= tMat.col1.x * aX + tMat.col2.x * aY;
      bY -= tMat.col1.y * aX + tMat.col2.y * aY;
      var k_errorTol = 0.0010;
      for(;;) {
        tMat = c.normalMass;
        var xX = -(tMat.col1.x * bX + tMat.col2.x * bY);
        var xY = -(tMat.col1.y * bX + tMat.col2.y * bY);
        if(xX >= 0 && xY >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = -cp1.normalMass * bX;
        xY = 0;
        vn1 = 0;
        vn2 = c.K.col1.y * xX + bY;
        if(xX >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = -cp2.normalMass * bY;
        vn1 = c.K.col2.x * xY + bX;
        vn2 = 0;
        if(xY >= 0 && vn1 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = 0;
        vn1 = bX;
        vn2 = bY;
        if(vn1 >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        break
      }
    }
    bodyA.m_angularVelocity = wA;
    bodyB.m_angularVelocity = wB
  }
};
b2ContactSolver.prototype.FinalizeVelocityConstraints = function() {
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var m = c.manifold;
    for(var j = 0;j < c.pointCount;++j) {
      var point1 = m.m_points[j];
      var point2 = c.points[j];
      point1.m_normalImpulse = point2.normalImpulse;
      point1.m_tangentImpulse = point2.tangentImpulse
    }
  }
};
b2ContactSolver.prototype.SolvePositionConstraints = function(baumgarte) {
  var minSeparation = 0;
  for(var i = 0;i < this.m_constraintCount;i++) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_mass * bodyA.m_invMass;
    var invIA = bodyA.m_mass * bodyA.m_invI;
    var invMassB = bodyB.m_mass * bodyB.m_invMass;
    var invIB = bodyB.m_mass * bodyB.m_invI;
    b2ContactSolver.s_psm.Initialize(c);
    var normal = b2ContactSolver.s_psm.m_normal;
    for(var j = 0;j < c.pointCount;j++) {
      var ccp = c.points[j];
      var point = b2ContactSolver.s_psm.m_points[j];
      var separation = b2ContactSolver.s_psm.m_separations[j];
      var rAX = point.x - bodyA.m_sweep.c.x;
      var rAY = point.y - bodyA.m_sweep.c.y;
      var rBX = point.x - bodyB.m_sweep.c.x;
      var rBY = point.y - bodyB.m_sweep.c.y;
      minSeparation = minSeparation < separation ? minSeparation : separation;
      var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), -b2Settings.b2_maxLinearCorrection, 0);
      var impulse = -ccp.equalizedMass * C;
      var PX = impulse * normal.x;
      var PY = impulse * normal.y;
      bodyA.m_sweep.c.x -= invMassA * PX;
      bodyA.m_sweep.c.y -= invMassA * PY;
      bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
      bodyA.SynchronizeTransform();
      bodyB.m_sweep.c.x += invMassB * PX;
      bodyB.m_sweep.c.y += invMassB * PY;
      bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
      bodyB.SynchronizeTransform()
    }
  }
  return minSeparation > -1.5 * b2Settings.b2_linearSlop
};
b2ContactSolver.prototype.m_step = new b2TimeStep;
b2ContactSolver.prototype.m_allocator = null;
b2ContactSolver.prototype.m_constraints = new Array;
b2ContactSolver.prototype.m_constraintCount = 0;var b2Simplex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Simplex.prototype.__constructor = function() {
  this.m_vertices[0] = this.m_v1;
  this.m_vertices[1] = this.m_v2;
  this.m_vertices[2] = this.m_v3
};
b2Simplex.prototype.__varz = function() {
  this.m_v1 = new b2SimplexVertex;
  this.m_v2 = new b2SimplexVertex;
  this.m_v3 = new b2SimplexVertex;
  this.m_vertices = new Array(3)
};
b2Simplex.prototype.ReadCache = function(cache, proxyA, transformA, proxyB, transformB) {
  b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
  var wALocal;
  var wBLocal;
  this.m_count = cache.count;
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    var v = vertices[i];
    v.indexA = cache.indexA[i];
    v.indexB = cache.indexB[i];
    wALocal = proxyA.GetVertex(v.indexA);
    wBLocal = proxyB.GetVertex(v.indexB);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    v.a = 0
  }
  if(this.m_count > 1) {
    var metric1 = cache.metric;
    var metric2 = this.GetMetric();
    if(metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
      this.m_count = 0
    }
  }
  if(this.m_count == 0) {
    v = vertices[0];
    v.indexA = 0;
    v.indexB = 0;
    wALocal = proxyA.GetVertex(0);
    wBLocal = proxyB.GetVertex(0);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    this.m_count = 1
  }
};
b2Simplex.prototype.WriteCache = function(cache) {
  cache.metric = this.GetMetric();
  cache.count = parseInt(this.m_count);
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    cache.indexA[i] = parseInt(vertices[i].indexA);
    cache.indexB[i] = parseInt(vertices[i].indexB)
  }
};
b2Simplex.prototype.GetSearchDirection = function() {
  switch(this.m_count) {
    case 1:
      return this.m_v1.w.GetNegative();
    case 2:
      var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
      var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
      if(sgn > 0) {
        return b2Math.CrossFV(1, e12)
      }else {
        return b2Math.CrossVF(e12, 1)
      }
    ;
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetClosestPoint = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return new b2Vec2;
    case 1:
      return this.m_v1.w;
    case 2:
      return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetWitnessPoints = function(pA, pB) {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      break;
    case 1:
      pA.SetV(this.m_v1.wA);
      pB.SetV(this.m_v1.wB);
      break;
    case 2:
      pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
      pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
      pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
      pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
      break;
    case 3:
      pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
      pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
      break;
    default:
      b2Settings.b2Assert(false);
      break
  }
};
b2Simplex.prototype.GetMetric = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return 0;
    case 1:
      return 0;
    case 2:
      return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
    case 3:
      return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2Simplex.prototype.Solve2 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var d12_2 = -(w1.x * e12.x + w1.y * e12.y);
  if(d12_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  var d12_1 = w2.x * e12.x + w2.y * e12.y;
  if(d12_1 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  var inv_d12 = 1 / (d12_1 + d12_2);
  this.m_v1.a = d12_1 * inv_d12;
  this.m_v2.a = d12_2 * inv_d12;
  this.m_count = 2
};
b2Simplex.prototype.Solve3 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var w3 = this.m_v3.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var w1e12 = b2Math.Dot(w1, e12);
  var w2e12 = b2Math.Dot(w2, e12);
  var d12_1 = w2e12;
  var d12_2 = -w1e12;
  var e13 = b2Math.SubtractVV(w3, w1);
  var w1e13 = b2Math.Dot(w1, e13);
  var w3e13 = b2Math.Dot(w3, e13);
  var d13_1 = w3e13;
  var d13_2 = -w1e13;
  var e23 = b2Math.SubtractVV(w3, w2);
  var w2e23 = b2Math.Dot(w2, e23);
  var w3e23 = b2Math.Dot(w3, e23);
  var d23_1 = w3e23;
  var d23_2 = -w2e23;
  var n123 = b2Math.CrossVV(e12, e13);
  var d123_1 = n123 * b2Math.CrossVV(w2, w3);
  var d123_2 = n123 * b2Math.CrossVV(w3, w1);
  var d123_3 = n123 * b2Math.CrossVV(w1, w2);
  if(d12_2 <= 0 && d13_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  if(d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
    var inv_d12 = 1 / (d12_1 + d12_2);
    this.m_v1.a = d12_1 * inv_d12;
    this.m_v2.a = d12_2 * inv_d12;
    this.m_count = 2;
    return
  }
  if(d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
    var inv_d13 = 1 / (d13_1 + d13_2);
    this.m_v1.a = d13_1 * inv_d13;
    this.m_v3.a = d13_2 * inv_d13;
    this.m_count = 2;
    this.m_v2.Set(this.m_v3);
    return
  }
  if(d12_1 <= 0 && d23_2 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  if(d13_1 <= 0 && d23_1 <= 0) {
    this.m_v3.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v3);
    return
  }
  if(d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
    var inv_d23 = 1 / (d23_1 + d23_2);
    this.m_v2.a = d23_1 * inv_d23;
    this.m_v3.a = d23_2 * inv_d23;
    this.m_count = 2;
    this.m_v1.Set(this.m_v3);
    return
  }
  var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
  this.m_v1.a = d123_1 * inv_d123;
  this.m_v2.a = d123_2 * inv_d123;
  this.m_v3.a = d123_3 * inv_d123;
  this.m_count = 3
};
b2Simplex.prototype.m_v1 = new b2SimplexVertex;
b2Simplex.prototype.m_v2 = new b2SimplexVertex;
b2Simplex.prototype.m_v3 = new b2SimplexVertex;
b2Simplex.prototype.m_vertices = new Array(3);
b2Simplex.prototype.m_count = 0;var b2WeldJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJoint.prototype, b2Joint.prototype);
b2WeldJoint.prototype._super = b2Joint.prototype;
b2WeldJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_impulse.z *= step.dtRatio;
    bA.m_linearVelocity.x -= mA * this.m_impulse.x;
    bA.m_linearVelocity.y -= mA * this.m_impulse.y;
    bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
    bB.m_linearVelocity.x += mB * this.m_impulse.x;
    bB.m_linearVelocity.y += mB * this.m_impulse.y;
    bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero()
  }
};
b2WeldJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
  var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
  var Cdot2 = wB - wA;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -Cdot1X, -Cdot1Y, -Cdot2);
  this.m_impulse.Add(impulse);
  vA.x -= mA * impulse.x;
  vA.y -= mA * impulse.y;
  wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  vB.x += mB * impulse.x;
  vB.y += mB * impulse.y;
  wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2WeldJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
  var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
  var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
  var angularError = b2Math.Abs(C2);
  if(positionError > k_allowedStretch) {
    iA *= 1;
    iB *= 1
  }
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -C1X, -C1Y, -C2);
  bA.m_sweep.c.x -= mA * impulse.x;
  bA.m_sweep.c.y -= mA * impulse.y;
  bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  bB.m_sweep.c.x += mB * impulse.x;
  bB.m_sweep.c.y += mB * impulse.y;
  bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2WeldJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2WeldJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2WeldJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2WeldJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2WeldJoint.prototype.m_localAnchorA = new b2Vec2;
b2WeldJoint.prototype.m_localAnchorB = new b2Vec2;
b2WeldJoint.prototype.m_referenceAngle = null;
b2WeldJoint.prototype.m_impulse = new b2Vec3;
b2WeldJoint.prototype.m_mass = new b2Mat33;var b2Math = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Math.prototype.__constructor = function() {
};
b2Math.prototype.__varz = function() {
};
b2Math.IsValid = function(x) {
  return isFinite(x)
};
b2Math.Dot = function(a, b) {
  return a.x * b.x + a.y * b.y
};
b2Math.CrossVV = function(a, b) {
  return a.x * b.y - a.y * b.x
};
b2Math.CrossVF = function(a, s) {
  var v = new b2Vec2(s * a.y, -s * a.x);
  return v
};
b2Math.CrossFV = function(s, a) {
  var v = new b2Vec2(-s * a.y, s * a.x);
  return v
};
b2Math.MulMV = function(A, v) {
  var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
  return u
};
b2Math.MulTMV = function(A, v) {
  var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
  return u
};
b2Math.MulX = function(T, v) {
  var a = b2Math.MulMV(T.R, v);
  a.x += T.position.x;
  a.y += T.position.y;
  return a
};
b2Math.MulXT = function(T, v) {
  var a = b2Math.SubtractVV(v, T.position);
  var tX = a.x * T.R.col1.x + a.y * T.R.col1.y;
  a.y = a.x * T.R.col2.x + a.y * T.R.col2.y;
  a.x = tX;
  return a
};
b2Math.AddVV = function(a, b) {
  var v = new b2Vec2(a.x + b.x, a.y + b.y);
  return v
};
b2Math.SubtractVV = function(a, b) {
  var v = new b2Vec2(a.x - b.x, a.y - b.y);
  return v
};
b2Math.Distance = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return Math.sqrt(cX * cX + cY * cY)
};
b2Math.DistanceSquared = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return cX * cX + cY * cY
};
b2Math.MulFV = function(s, a) {
  var v = new b2Vec2(s * a.x, s * a.y);
  return v
};
b2Math.AddMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
  return C
};
b2Math.MulMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
  return C
};
b2Math.MulTMM = function(A, B) {
  var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
  var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
  var C = b2Mat22.FromVV(c1, c2);
  return C
};
b2Math.Abs = function(a) {
  return a > 0 ? a : -a
};
b2Math.AbsV = function(a) {
  var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
  return b
};
b2Math.AbsM = function(A) {
  var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
  return B
};
b2Math.Min = function(a, b) {
  return a < b ? a : b
};
b2Math.MinV = function(a, b) {
  var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
  return c
};
b2Math.Max = function(a, b) {
  return a > b ? a : b
};
b2Math.MaxV = function(a, b) {
  var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
  return c
};
b2Math.Clamp = function(a, low, high) {
  return a < low ? low : a > high ? high : a
};
b2Math.ClampV = function(a, low, high) {
  return b2Math.MaxV(low, b2Math.MinV(a, high))
};
b2Math.Swap = function(a, b) {
  var tmp = a[0];
  a[0] = b[0];
  b[0] = tmp
};
b2Math.Random = function() {
  return Math.random() * 2 - 1
};
b2Math.RandomRange = function(lo, hi) {
  var r = Math.random();
  r = (hi - lo) * r + lo;
  return r
};
b2Math.NextPowerOfTwo = function(x) {
  x |= x >> 1 & 2147483647;
  x |= x >> 2 & 1073741823;
  x |= x >> 4 & 268435455;
  x |= x >> 8 & 16777215;
  x |= x >> 16 & 65535;
  return x + 1
};
b2Math.IsPowerOfTwo = function(x) {
  var result = x > 0 && (x & x - 1) == 0;
  return result
};
b2Math.b2Vec2_zero = new b2Vec2(0, 0);
b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1, 0), new b2Vec2(0, 1));
b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);var b2PulleyJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJoint.prototype, b2Joint.prototype);
b2PulleyJoint.prototype._super = b2Joint.prototype;
b2PulleyJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_ground = this.m_bodyA.m_world.m_groundBody;
  this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
  this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_ratio = def.ratio;
  this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
  this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
  this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
  this.m_impulse = 0;
  this.m_limitImpulse1 = 0;
  this.m_limitImpulse2 = 0
};
b2PulleyJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u1 = new b2Vec2;
  this.m_u2 = new b2Vec2
};
b2PulleyJoint.b2_minPulleyLength = 2;
b2PulleyJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  this.m_u1.Set(p1X - s1X, p1Y - s1Y);
  this.m_u2.Set(p2X - s2X, p2Y - s2Y);
  var length1 = this.m_u1.Length();
  var length2 = this.m_u2.Length();
  if(length1 > b2Settings.b2_linearSlop) {
    this.m_u1.Multiply(1 / length1)
  }else {
    this.m_u1.SetZero()
  }
  if(length2 > b2Settings.b2_linearSlop) {
    this.m_u2.Multiply(1 / length2)
  }else {
    this.m_u2.SetZero()
  }
  var C = this.m_constant - length1 - this.m_ratio * length2;
  if(C > 0) {
    this.m_state = b2Joint.e_inactiveLimit;
    this.m_impulse = 0
  }else {
    this.m_state = b2Joint.e_atUpperLimit
  }
  if(length1 < this.m_maxLength1) {
    this.m_limitState1 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse1 = 0
  }else {
    this.m_limitState1 = b2Joint.e_atUpperLimit
  }
  if(length2 < this.m_maxLength2) {
    this.m_limitState2 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse2 = 0
  }else {
    this.m_limitState2 = b2Joint.e_atUpperLimit
  }
  var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
  var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
  this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
  this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
  this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
  this.m_limitMass1 = 1 / this.m_limitMass1;
  this.m_limitMass2 = 1 / this.m_limitMass2;
  this.m_pulleyMass = 1 / this.m_pulleyMass;
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    this.m_limitImpulse1 *= step.dtRatio;
    this.m_limitImpulse2 *= step.dtRatio;
    var P1X = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x;
    var P1Y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y;
    var P2X = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x;
    var P2Y = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }else {
    this.m_impulse = 0;
    this.m_limitImpulse1 = 0;
    this.m_limitImpulse2 = 0
  }
};
b2PulleyJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X;
  var v1Y;
  var v2X;
  var v2Y;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var Cdot;
  var impulse;
  var oldImpulse;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = this.m_pulleyMass * -Cdot;
    oldImpulse = this.m_impulse;
    this.m_impulse = b2Math.Max(0, this.m_impulse + impulse);
    impulse = this.m_impulse - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    P2X = -this.m_ratio * impulse * this.m_u2.x;
    P2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y);
    impulse = -this.m_limitMass1 * Cdot;
    oldImpulse = this.m_limitImpulse1;
    this.m_limitImpulse1 = b2Math.Max(0, this.m_limitImpulse1 + impulse);
    impulse = this.m_limitImpulse1 - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X)
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = -this.m_limitMass2 * Cdot;
    oldImpulse = this.m_limitImpulse2;
    this.m_limitImpulse2 = b2Math.Max(0, this.m_limitImpulse2 + impulse);
    impulse = this.m_limitImpulse2 - oldImpulse;
    P2X = -impulse * this.m_u2.x;
    P2Y = -impulse * this.m_u2.y;
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
};
b2PulleyJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var p1X;
  var p1Y;
  var p2X;
  var p2Y;
  var length1;
  var length2;
  var C;
  var impulse;
  var oldImpulse;
  var oldLimitPositionImpulse;
  var tX;
  var linearError = 0;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length1 = this.m_u1.Length();
    length2 = this.m_u2.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.Multiply(1 / length1)
    }else {
      this.m_u1.SetZero()
    }
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.Multiply(1 / length2)
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_constant - length1 - this.m_ratio * length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_pulleyMass * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    p2X = -this.m_ratio * impulse * this.m_u2.x;
    p2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    length1 = this.m_u1.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.x *= 1 / length1;
      this.m_u1.y *= 1 / length1
    }else {
      this.m_u1.SetZero()
    }
    C = this.m_maxLength1 - length1;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass1 * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bA.SynchronizeTransform()
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length2 = this.m_u2.Length();
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.x *= 1 / length2;
      this.m_u2.y *= 1 / length2
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_maxLength2 - length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass2 * C;
    p2X = -impulse * this.m_u2.x;
    p2Y = -impulse * this.m_u2.y;
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bB.SynchronizeTransform()
  }
  return linearError < b2Settings.b2_linearSlop
};
b2PulleyJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PulleyJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PulleyJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y)
};
b2PulleyJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2PulleyJoint.prototype.GetGroundAnchorA = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor1);
  return a
};
b2PulleyJoint.prototype.GetGroundAnchorB = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor2);
  return a
};
b2PulleyJoint.prototype.GetLength1 = function() {
  var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetLength2 = function() {
  var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2PulleyJoint.prototype.m_ground = null;
b2PulleyJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_u1 = new b2Vec2;
b2PulleyJoint.prototype.m_u2 = new b2Vec2;
b2PulleyJoint.prototype.m_constant = null;
b2PulleyJoint.prototype.m_ratio = null;
b2PulleyJoint.prototype.m_maxLength1 = null;
b2PulleyJoint.prototype.m_maxLength2 = null;
b2PulleyJoint.prototype.m_pulleyMass = null;
b2PulleyJoint.prototype.m_limitMass1 = null;
b2PulleyJoint.prototype.m_limitMass2 = null;
b2PulleyJoint.prototype.m_impulse = null;
b2PulleyJoint.prototype.m_limitImpulse1 = null;
b2PulleyJoint.prototype.m_limitImpulse2 = null;
b2PulleyJoint.prototype.m_state = 0;
b2PulleyJoint.prototype.m_limitState1 = 0;
b2PulleyJoint.prototype.m_limitState2 = 0;var b2PrismaticJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJoint.prototype, b2Joint.prototype);
b2PrismaticJoint.prototype._super = b2Joint.prototype;
b2PrismaticJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_refAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2PrismaticJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat33;
  this.m_impulse = new b2Vec3
};
b2PrismaticJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  if(this.m_motorMass > Number.MIN_VALUE) {
    this.m_motorMass = 1 / this.m_motorMass
  }
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
  this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = i1 + i2;
  this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
  this.m_K.col3.x = this.m_K.col1.z;
  this.m_K.col3.y = this.m_K.col2.z;
  this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.z = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.z = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2PrismaticJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  var Cdot1Y = w2 - w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve33(new b2Vec3, -Cdot1X, -Cdot1Y, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0)
      }
    }
    var bX = -Cdot1X - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
    var bY = -Cdot1Y - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
    var f2r = this.m_K.Solve22(new b2Vec2, bX, bY);
    f2r.x += f1.x;
    f2r.y += f1.y;
    this.m_impulse.x = f2r.x;
    this.m_impulse.y = f2r.y;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    df.z = this.m_impulse.z - f1.z;
    PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
    L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2 = this.m_K.Solve22(new b2Vec2, -Cdot1X, -Cdot1Y);
    this.m_impulse.x += df2.x;
    this.m_impulse.y += df2.y;
    PX = df2.x * this.m_perp.x;
    PY = df2.x * this.m_perp.y;
    L1 = df2.x * this.m_s1 + df2.y;
    L2 = df2.x * this.m_s2 + df2.y;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2PrismaticJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec3;
  var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
  var C1Y = a2 - a1 - this.m_refAngle;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
  angularError = b2Math.Abs(C1Y);
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
    this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = i1 + i2;
    this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
    this.m_K.col3.x = this.m_K.col1.z;
    this.m_K.col3.y = this.m_K.col2.z;
    this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve33(impulse, -C1X, -C1Y, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var k12 = i1 * this.m_s1 + i2 * this.m_s2;
    var k22 = i1 + i2;
    this.m_K.col1.Set(k11, k12, 0);
    this.m_K.col2.Set(k12, k22, 0);
    var impulse1 = this.m_K.Solve22(new b2Vec2, -C1X, -C1Y);
    impulse.x = impulse1.x;
    impulse.y = impulse1.y;
    impulse.z = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2PrismaticJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PrismaticJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PrismaticJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
};
b2PrismaticJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2PrismaticJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2PrismaticJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2PrismaticJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2PrismaticJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2PrismaticJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2PrismaticJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2PrismaticJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2PrismaticJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2PrismaticJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2PrismaticJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2PrismaticJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2PrismaticJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2PrismaticJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2PrismaticJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PrismaticJoint.prototype.m_localXAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localYAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_refAngle = null;
b2PrismaticJoint.prototype.m_axis = new b2Vec2;
b2PrismaticJoint.prototype.m_perp = new b2Vec2;
b2PrismaticJoint.prototype.m_s1 = null;
b2PrismaticJoint.prototype.m_s2 = null;
b2PrismaticJoint.prototype.m_a1 = null;
b2PrismaticJoint.prototype.m_a2 = null;
b2PrismaticJoint.prototype.m_K = new b2Mat33;
b2PrismaticJoint.prototype.m_impulse = new b2Vec3;
b2PrismaticJoint.prototype.m_motorMass = null;
b2PrismaticJoint.prototype.m_motorImpulse = null;
b2PrismaticJoint.prototype.m_lowerTranslation = null;
b2PrismaticJoint.prototype.m_upperTranslation = null;
b2PrismaticJoint.prototype.m_maxMotorForce = null;
b2PrismaticJoint.prototype.m_motorSpeed = null;
b2PrismaticJoint.prototype.m_enableLimit = null;
b2PrismaticJoint.prototype.m_enableMotor = null;
b2PrismaticJoint.prototype.m_limitState = 0;var b2RevoluteJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJoint.prototype, b2Joint.prototype);
b2RevoluteJoint.prototype._super = b2Joint.prototype;
b2RevoluteJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorImpulse = 0;
  this.m_lowerAngle = def.lowerAngle;
  this.m_upperAngle = def.upperAngle;
  this.m_maxMotorTorque = def.maxMotorTorque;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit
};
b2RevoluteJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.K3 = new b2Mat22;
  this.impulse3 = new b2Vec3;
  this.impulse2 = new b2Vec2;
  this.reduced = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2RevoluteJoint.tImpulse = new b2Vec2;
b2RevoluteJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  if(this.m_enableMotor || this.m_enableLimit) {
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
  this.m_mass.col2.x = -r1Y * r1X * i1 - r2Y * r2X * i2;
  this.m_mass.col3.x = -r1Y * i1 - r2Y * i2;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
  this.m_mass.col3.y = r1X * i1 + r2X * i2;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = i1 + i2;
  this.m_motorMass = 1 / (i1 + i2);
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(this.m_enableLimit) {
    var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    if(b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2Settings.b2_angularSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointAngle <= this.m_lowerAngle) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_impulse.z = 0
        }
        this.m_limitState = b2Joint.e_atLowerLimit
      }else {
        if(jointAngle >= this.m_upperAngle) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_impulse.z = 0
          }
          this.m_limitState = b2Joint.e_atUpperLimit
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x;
    var PY = this.m_impulse.y;
    bA.m_linearVelocity.x -= m1 * PX;
    bA.m_linearVelocity.y -= m1 * PY;
    bA.m_angularVelocity -= i1 * (r1X * PY - r1Y * PX + this.m_motorImpulse + this.m_impulse.z);
    bB.m_linearVelocity.x += m2 * PX;
    bB.m_linearVelocity.y += m2 * PY;
    bB.m_angularVelocity += i2 * (r2X * PY - r2Y * PX + this.m_motorImpulse + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2RevoluteJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  var newImpulse;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = w2 - w1 - this.m_motorSpeed;
    var impulse = this.m_motorMass * -Cdot;
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    w1 -= i1 * impulse;
    w2 += i2 * impulse
  }
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var Cdot1X = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var Cdot1Y = v2.y + w2 * r2X - v1.y - w1 * r1X;
    var Cdot2 = w2 - w1;
    this.m_mass.Solve33(this.impulse3, -Cdot1X, -Cdot1Y, -Cdot2);
    if(this.m_limitState == b2Joint.e_equalLimits) {
      this.m_impulse.Add(this.impulse3)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        newImpulse = this.m_impulse.z + this.impulse3.z;
        if(newImpulse < 0) {
          this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
          this.impulse3.x = this.reduced.x;
          this.impulse3.y = this.reduced.y;
          this.impulse3.z = -this.m_impulse.z;
          this.m_impulse.x += this.reduced.x;
          this.m_impulse.y += this.reduced.y;
          this.m_impulse.z = 0
        }
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          newImpulse = this.m_impulse.z + this.impulse3.z;
          if(newImpulse > 0) {
            this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
            this.impulse3.x = this.reduced.x;
            this.impulse3.y = this.reduced.y;
            this.impulse3.z = -this.m_impulse.z;
            this.m_impulse.x += this.reduced.x;
            this.m_impulse.y += this.reduced.y;
            this.m_impulse.z = 0
          }
        }
      }
    }
    v1.x -= m1 * this.impulse3.x;
    v1.y -= m1 * this.impulse3.y;
    w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
    v2.x += m2 * this.impulse3.x;
    v2.y += m2 * this.impulse3.y;
    w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z)
  }else {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var CdotX = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var CdotY = v2.y + w2 * r2X - v1.y - w1 * r1X;
    this.m_mass.Solve22(this.impulse2, -CdotX, -CdotY);
    this.m_impulse.x += this.impulse2.x;
    this.m_impulse.y += this.impulse2.y;
    v1.x -= m1 * this.impulse2.x;
    v1.y -= m1 * this.impulse2.y;
    w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
    v2.x += m2 * this.impulse2.x;
    v2.y += m2 * this.impulse2.y;
    w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x)
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2RevoluteJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var oldLimitImpulse;
  var C;
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var angularError = 0;
  var positionError = 0;
  var tX;
  var impulseX;
  var impulseY;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    var limitImpulse = 0;
    if(this.m_limitState == b2Joint.e_equalLimits) {
      C = b2Math.Clamp(angle - this.m_lowerAngle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection);
      limitImpulse = -this.m_motorMass * C;
      angularError = b2Math.Abs(C)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        C = angle - this.m_lowerAngle;
        angularError = -C;
        C = b2Math.Clamp(C + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0);
        limitImpulse = -this.m_motorMass * C
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          C = angle - this.m_upperAngle;
          angularError = C;
          C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0, b2Settings.b2_maxAngularCorrection);
          limitImpulse = -this.m_motorMass * C
        }
      }
    }
    bA.m_sweep.a -= bA.m_invI * limitImpulse;
    bB.m_sweep.a += bB.m_invI * limitImpulse;
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var CLengthSquared = CX * CX + CY * CY;
  var CLength = Math.sqrt(CLengthSquared);
  positionError = CLength;
  var invMass1 = bA.m_invMass;
  var invMass2 = bB.m_invMass;
  var invI1 = bA.m_invI;
  var invI2 = bB.m_invI;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  if(CLengthSquared > k_allowedStretch * k_allowedStretch) {
    var uX = CX / CLength;
    var uY = CY / CLength;
    var k = invMass1 + invMass2;
    var m = 1 / k;
    impulseX = m * -CX;
    impulseY = m * -CY;
    var k_beta = 0.5;
    bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
    bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
    bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
    bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
    CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y
  }
  this.K1.col1.x = invMass1 + invMass2;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass1 + invMass2;
  this.K2.col1.x = invI1 * r1Y * r1Y;
  this.K2.col2.x = -invI1 * r1X * r1Y;
  this.K2.col1.y = -invI1 * r1X * r1Y;
  this.K2.col2.y = invI1 * r1X * r1X;
  this.K3.col1.x = invI2 * r2Y * r2Y;
  this.K3.col2.x = -invI2 * r2X * r2Y;
  this.K3.col1.y = -invI2 * r2X * r2Y;
  this.K3.col2.y = invI2 * r2X * r2X;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.AddM(this.K3);
  this.K.Solve(b2RevoluteJoint.tImpulse, -CX, -CY);
  impulseX = b2RevoluteJoint.tImpulse.x;
  impulseY = b2RevoluteJoint.tImpulse.y;
  bA.m_sweep.c.x -= bA.m_invMass * impulseX;
  bA.m_sweep.c.y -= bA.m_invMass * impulseY;
  bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
  bB.m_sweep.c.x += bB.m_invMass * impulseX;
  bB.m_sweep.c.y += bB.m_invMass * impulseY;
  bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2RevoluteJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2RevoluteJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2RevoluteJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2RevoluteJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2RevoluteJoint.prototype.GetJointAngle = function() {
  return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
};
b2RevoluteJoint.prototype.GetJointSpeed = function() {
  return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
b2RevoluteJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2RevoluteJoint.prototype.EnableLimit = function(flag) {
  this.m_enableLimit = flag
};
b2RevoluteJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerAngle
};
b2RevoluteJoint.prototype.GetUpperLimit = function() {
  return this.m_upperAngle
};
b2RevoluteJoint.prototype.SetLimits = function(lower, upper) {
  this.m_lowerAngle = lower;
  this.m_upperAngle = upper
};
b2RevoluteJoint.prototype.IsMotorEnabled = function() {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  return this.m_enableMotor
};
b2RevoluteJoint.prototype.EnableMotor = function(flag) {
  this.m_enableMotor = flag
};
b2RevoluteJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2RevoluteJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2RevoluteJoint.prototype.SetMaxMotorTorque = function(torque) {
  this.m_maxMotorTorque = torque
};
b2RevoluteJoint.prototype.GetMotorTorque = function() {
  return this.m_maxMotorTorque
};
b2RevoluteJoint.prototype.K = new b2Mat22;
b2RevoluteJoint.prototype.K1 = new b2Mat22;
b2RevoluteJoint.prototype.K2 = new b2Mat22;
b2RevoluteJoint.prototype.K3 = new b2Mat22;
b2RevoluteJoint.prototype.impulse3 = new b2Vec3;
b2RevoluteJoint.prototype.impulse2 = new b2Vec2;
b2RevoluteJoint.prototype.reduced = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor1 = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor2 = new b2Vec2;
b2RevoluteJoint.prototype.m_impulse = new b2Vec3;
b2RevoluteJoint.prototype.m_motorImpulse = null;
b2RevoluteJoint.prototype.m_mass = new b2Mat33;
b2RevoluteJoint.prototype.m_motorMass = null;
b2RevoluteJoint.prototype.m_enableMotor = null;
b2RevoluteJoint.prototype.m_maxMotorTorque = null;
b2RevoluteJoint.prototype.m_motorSpeed = null;
b2RevoluteJoint.prototype.m_enableLimit = null;
b2RevoluteJoint.prototype.m_referenceAngle = null;
b2RevoluteJoint.prototype.m_lowerAngle = null;
b2RevoluteJoint.prototype.m_upperAngle = null;
b2RevoluteJoint.prototype.m_limitState = 0;var b2JointDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointDef.prototype.__constructor = function() {
  this.type = b2Joint.e_unknownJoint;
  this.userData = null;
  this.bodyA = null;
  this.bodyB = null;
  this.collideConnected = false
};
b2JointDef.prototype.__varz = function() {
};
b2JointDef.prototype.type = 0;
b2JointDef.prototype.userData = null;
b2JointDef.prototype.bodyA = null;
b2JointDef.prototype.bodyB = null;
b2JointDef.prototype.collideConnected = null;var b2LineJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJointDef.prototype, b2JointDef.prototype);
b2LineJointDef.prototype._super = b2JointDef.prototype;
b2LineJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_lineJoint;
  this.localAxisA.Set(1, 0);
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2LineJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2LineJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis)
};
b2LineJointDef.prototype.localAnchorA = new b2Vec2;
b2LineJointDef.prototype.localAnchorB = new b2Vec2;
b2LineJointDef.prototype.localAxisA = new b2Vec2;
b2LineJointDef.prototype.enableLimit = null;
b2LineJointDef.prototype.lowerTranslation = null;
b2LineJointDef.prototype.upperTranslation = null;
b2LineJointDef.prototype.enableMotor = null;
b2LineJointDef.prototype.maxMotorForce = null;
b2LineJointDef.prototype.motorSpeed = null;var b2DistanceJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJoint.prototype, b2Joint.prototype);
b2DistanceJoint.prototype._super = b2Joint.prototype;
b2DistanceJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_length = def.length;
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_impulse = 0;
  this.m_gamma = 0;
  this.m_bias = 0
};
b2DistanceJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u = new b2Vec2
};
b2DistanceJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
  if(length > b2Settings.b2_linearSlop) {
    this.m_u.Multiply(1 / length)
  }else {
    this.m_u.SetZero()
  }
  var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
  var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
  var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
  this.m_mass = invMass != 0 ? 1 / invMass : 0;
  if(this.m_frequencyHz > 0) {
    var C = length - this.m_length;
    var omega = 2 * Math.PI * this.m_frequencyHz;
    var d = 2 * this.m_mass * this.m_dampingRatio * omega;
    var k = this.m_mass * omega * omega;
    this.m_gamma = step.dt * (d + step.dt * k);
    this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
    this.m_bias = C * step.dt * k * this.m_gamma;
    this.m_mass = invMass + this.m_gamma;
    this.m_mass = this.m_mass != 0 ? 1 / this.m_mass : 0
  }
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    var PX = this.m_impulse * this.m_u.x;
    var PY = this.m_impulse * this.m_u.y;
    bA.m_linearVelocity.x -= bA.m_invMass * PX;
    bA.m_linearVelocity.y -= bA.m_invMass * PY;
    bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_linearVelocity.x += bB.m_invMass * PX;
    bB.m_linearVelocity.y += bB.m_invMass * PY;
    bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
  }else {
    this.m_impulse = 0
  }
};
b2DistanceJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
  var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
  var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
  var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
  var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
  var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
  this.m_impulse += impulse;
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_linearVelocity.x -= bA.m_invMass * PX;
  bA.m_linearVelocity.y -= bA.m_invMass * PY;
  bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_linearVelocity.x += bB.m_invMass * PX;
  bB.m_linearVelocity.y += bB.m_invMass * PY;
  bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
};
b2DistanceJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  if(this.m_frequencyHz > 0) {
    return true
  }
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(dX * dX + dY * dY);
  dX /= length;
  dY /= length;
  var C = length - this.m_length;
  C = b2Math.Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
  var impulse = -this.m_mass * C;
  this.m_u.Set(dX, dY);
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_sweep.c.x -= bA.m_invMass * PX;
  bA.m_sweep.c.y -= bA.m_invMass * PY;
  bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_sweep.c.x += bB.m_invMass * PX;
  bB.m_sweep.c.y += bB.m_invMass * PY;
  bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return b2Math.Abs(C) < b2Settings.b2_linearSlop
};
b2DistanceJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2DistanceJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2DistanceJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y)
};
b2DistanceJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2DistanceJoint.prototype.GetLength = function() {
  return this.m_length
};
b2DistanceJoint.prototype.SetLength = function(length) {
  this.m_length = length
};
b2DistanceJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2DistanceJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2DistanceJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2DistanceJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2DistanceJoint.prototype.m_localAnchor1 = new b2Vec2;
b2DistanceJoint.prototype.m_localAnchor2 = new b2Vec2;
b2DistanceJoint.prototype.m_u = new b2Vec2;
b2DistanceJoint.prototype.m_frequencyHz = null;
b2DistanceJoint.prototype.m_dampingRatio = null;
b2DistanceJoint.prototype.m_gamma = null;
b2DistanceJoint.prototype.m_bias = null;
b2DistanceJoint.prototype.m_impulse = null;
b2DistanceJoint.prototype.m_mass = null;
b2DistanceJoint.prototype.m_length = null;var b2PulleyJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJointDef.prototype, b2JointDef.prototype);
b2PulleyJointDef.prototype._super = b2JointDef.prototype;
b2PulleyJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_pulleyJoint;
  this.groundAnchorA.Set(-1, 1);
  this.groundAnchorB.Set(1, 1);
  this.localAnchorA.Set(-1, 0);
  this.localAnchorB.Set(1, 0);
  this.lengthA = 0;
  this.maxLengthA = 0;
  this.lengthB = 0;
  this.maxLengthB = 0;
  this.ratio = 1;
  this.collideConnected = true
};
b2PulleyJointDef.prototype.__varz = function() {
  this.groundAnchorA = new b2Vec2;
  this.groundAnchorB = new b2Vec2;
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2PulleyJointDef.prototype.Initialize = function(bA, bB, gaA, gaB, anchorA, anchorB, r) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.groundAnchorA.SetV(gaA);
  this.groundAnchorB.SetV(gaB);
  this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
  var d1X = anchorA.x - gaA.x;
  var d1Y = anchorA.y - gaA.y;
  this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
  var d2X = anchorB.x - gaB.x;
  var d2Y = anchorB.y - gaB.y;
  this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
  this.ratio = r;
  var C = this.lengthA + this.ratio * this.lengthB;
  this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
  this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio
};
b2PulleyJointDef.prototype.groundAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.groundAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.lengthA = null;
b2PulleyJointDef.prototype.maxLengthA = null;
b2PulleyJointDef.prototype.lengthB = null;
b2PulleyJointDef.prototype.maxLengthB = null;
b2PulleyJointDef.prototype.ratio = null;var b2DistanceJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJointDef.prototype, b2JointDef.prototype);
b2DistanceJointDef.prototype._super = b2JointDef.prototype;
b2DistanceJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_distanceJoint;
  this.length = 1;
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2DistanceJointDef.prototype.Initialize = function(bA, bB, anchorA, anchorB) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
  var dX = anchorB.x - anchorA.x;
  var dY = anchorB.y - anchorA.y;
  this.length = Math.sqrt(dX * dX + dY * dY);
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.localAnchorA = new b2Vec2;
b2DistanceJointDef.prototype.localAnchorB = new b2Vec2;
b2DistanceJointDef.prototype.length = null;
b2DistanceJointDef.prototype.frequencyHz = null;
b2DistanceJointDef.prototype.dampingRatio = null;var b2FrictionJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJointDef.prototype, b2JointDef.prototype);
b2FrictionJointDef.prototype._super = b2JointDef.prototype;
b2FrictionJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_frictionJoint;
  this.maxForce = 0;
  this.maxTorque = 0
};
b2FrictionJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2FrictionJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor))
};
b2FrictionJointDef.prototype.localAnchorA = new b2Vec2;
b2FrictionJointDef.prototype.localAnchorB = new b2Vec2;
b2FrictionJointDef.prototype.maxForce = null;
b2FrictionJointDef.prototype.maxTorque = null;var b2WeldJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJointDef.prototype, b2JointDef.prototype);
b2WeldJointDef.prototype._super = b2JointDef.prototype;
b2WeldJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_weldJoint;
  this.referenceAngle = 0
};
b2WeldJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2WeldJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2WeldJointDef.prototype.localAnchorA = new b2Vec2;
b2WeldJointDef.prototype.localAnchorB = new b2Vec2;
b2WeldJointDef.prototype.referenceAngle = null;var b2GearJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJointDef.prototype, b2JointDef.prototype);
b2GearJointDef.prototype._super = b2JointDef.prototype;
b2GearJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_gearJoint;
  this.joint1 = null;
  this.joint2 = null;
  this.ratio = 1
};
b2GearJointDef.prototype.__varz = function() {
};
b2GearJointDef.prototype.joint1 = null;
b2GearJointDef.prototype.joint2 = null;
b2GearJointDef.prototype.ratio = null;var b2Color = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Color.prototype.__constructor = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__varz = function() {
};
b2Color.prototype.Set = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__defineGetter__("r", function() {
  return this._r
});
b2Color.prototype.__defineSetter__("r", function(rr) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1))
});
b2Color.prototype.__defineGetter__("g", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("g", function(gg) {
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1))
});
b2Color.prototype.__defineGetter__("b", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("b", function(bb) {
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
});
b2Color.prototype.__defineGetter__("color", function() {
  return this._r << 16 | this._g << 8 | this._b
});
b2Color.prototype._r = 0;
b2Color.prototype._g = 0;
b2Color.prototype._b = 0;var b2FrictionJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJoint.prototype, b2Joint.prototype);
b2FrictionJoint.prototype._super = b2Joint.prototype;
b2FrictionJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_linearMass.SetZero();
  this.m_angularMass = 0;
  this.m_linearImpulse.SetZero();
  this.m_angularImpulse = 0;
  this.m_maxForce = def.maxForce;
  this.m_maxTorque = def.maxTorque
};
b2FrictionJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_linearImpulse = new b2Vec2;
  this.m_linearMass = new b2Mat22
};
b2FrictionJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var K = new b2Mat22;
  K.col1.x = mA + mB;
  K.col2.x = 0;
  K.col1.y = 0;
  K.col2.y = mA + mB;
  K.col1.x += iA * rAY * rAY;
  K.col2.x += -iA * rAX * rAY;
  K.col1.y += -iA * rAX * rAY;
  K.col2.y += iA * rAX * rAX;
  K.col1.x += iB * rBY * rBY;
  K.col2.x += -iB * rBX * rBY;
  K.col1.y += -iB * rBX * rBY;
  K.col2.y += iB * rBX * rBX;
  K.GetInverse(this.m_linearMass);
  this.m_angularMass = iA + iB;
  if(this.m_angularMass > 0) {
    this.m_angularMass = 1 / this.m_angularMass
  }
  if(step.warmStarting) {
    this.m_linearImpulse.x *= step.dtRatio;
    this.m_linearImpulse.y *= step.dtRatio;
    this.m_angularImpulse *= step.dtRatio;
    var P = this.m_linearImpulse;
    bA.m_linearVelocity.x -= mA * P.x;
    bA.m_linearVelocity.y -= mA * P.y;
    bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
    bB.m_linearVelocity.x += mB * P.x;
    bB.m_linearVelocity.y += mB * P.y;
    bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse)
  }else {
    this.m_linearImpulse.SetZero();
    this.m_angularImpulse = 0
  }
};
b2FrictionJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var maxImpulse;
  var Cdot = wB - wA;
  var impulse = -this.m_angularMass * Cdot;
  var oldImpulse = this.m_angularImpulse;
  maxImpulse = step.dt * this.m_maxTorque;
  this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
  impulse = this.m_angularImpulse - oldImpulse;
  wA -= iA * impulse;
  wB += iB * impulse;
  var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
  var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
  var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2(-CdotX, -CdotY));
  var oldImpulseV = this.m_linearImpulse.Copy();
  this.m_linearImpulse.Add(impulseV);
  maxImpulse = step.dt * this.m_maxForce;
  if(this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_linearImpulse.Normalize();
    this.m_linearImpulse.Multiply(maxImpulse)
  }
  impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
  vA.x -= mA * impulseV.x;
  vA.y -= mA * impulseV.y;
  wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
  vB.x += mB * impulseV.x;
  vB.y += mB * impulseV.y;
  wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2FrictionJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2FrictionJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2FrictionJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2FrictionJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y)
};
b2FrictionJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_angularImpulse
};
b2FrictionJoint.prototype.SetMaxForce = function(force) {
  this.m_maxForce = force
};
b2FrictionJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2FrictionJoint.prototype.SetMaxTorque = function(torque) {
  this.m_maxTorque = torque
};
b2FrictionJoint.prototype.GetMaxTorque = function() {
  return this.m_maxTorque
};
b2FrictionJoint.prototype.m_localAnchorA = new b2Vec2;
b2FrictionJoint.prototype.m_localAnchorB = new b2Vec2;
b2FrictionJoint.prototype.m_linearImpulse = new b2Vec2;
b2FrictionJoint.prototype.m_angularImpulse = null;
b2FrictionJoint.prototype.m_maxForce = null;
b2FrictionJoint.prototype.m_maxTorque = null;
b2FrictionJoint.prototype.m_linearMass = new b2Mat22;
b2FrictionJoint.prototype.m_angularMass = null;var b2Distance = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Distance.prototype.__constructor = function() {
};
b2Distance.prototype.__varz = function() {
};
b2Distance.Distance = function(output, cache, input) {
  ++b2Distance.b2_gjkCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var transformA = input.transformA;
  var transformB = input.transformB;
  var simplex = b2Distance.s_simplex;
  simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
  var vertices = simplex.m_vertices;
  var k_maxIters = 20;
  var saveA = b2Distance.s_saveA;
  var saveB = b2Distance.s_saveB;
  var saveCount = 0;
  var closestPoint = simplex.GetClosestPoint();
  var distanceSqr1 = closestPoint.LengthSquared();
  var distanceSqr2 = distanceSqr1;
  var i = 0;
  var p;
  var iter = 0;
  while(iter < k_maxIters) {
    saveCount = simplex.m_count;
    for(i = 0;i < saveCount;i++) {
      saveA[i] = vertices[i].indexA;
      saveB[i] = vertices[i].indexB
    }
    switch(simplex.m_count) {
      case 1:
        break;
      case 2:
        simplex.Solve2();
        break;
      case 3:
        simplex.Solve3();
        break;
      default:
        b2Settings.b2Assert(false)
    }
    if(simplex.m_count == 3) {
      break
    }
    p = simplex.GetClosestPoint();
    distanceSqr2 = p.LengthSquared();
    if(distanceSqr2 > distanceSqr1) {
    }
    distanceSqr1 = distanceSqr2;
    var d = simplex.GetSearchDirection();
    if(d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
      break
    }
    var vertex = vertices[simplex.m_count];
    vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
    vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
    vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
    vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
    vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
    ++iter;
    ++b2Distance.b2_gjkIters;
    var duplicate = false;
    for(i = 0;i < saveCount;i++) {
      if(vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
        duplicate = true;
        break
      }
    }
    if(duplicate) {
      break
    }
    ++simplex.m_count
  }
  b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
  simplex.GetWitnessPoints(output.pointA, output.pointB);
  output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
  output.iterations = iter;
  simplex.WriteCache(cache);
  if(input.useRadii) {
    var rA = proxyA.m_radius;
    var rB = proxyB.m_radius;
    if(output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
      output.distance -= rA + rB;
      var normal = b2Math.SubtractVV(output.pointB, output.pointA);
      normal.Normalize();
      output.pointA.x += rA * normal.x;
      output.pointA.y += rA * normal.y;
      output.pointB.x -= rB * normal.x;
      output.pointB.y -= rB * normal.y
    }else {
      p = new b2Vec2;
      p.x = 0.5 * (output.pointA.x + output.pointB.x);
      p.y = 0.5 * (output.pointA.y + output.pointB.y);
      output.pointA.x = output.pointB.x = p.x;
      output.pointA.y = output.pointB.y = p.y;
      output.distance = 0
    }
  }
};
b2Distance.b2_gjkCalls = 0;
b2Distance.b2_gjkIters = 0;
b2Distance.b2_gjkMaxIters = 0;
b2Distance.s_simplex = new b2Simplex;
b2Distance.s_saveA = new Array(3);
b2Distance.s_saveB = new Array(3);var b2MouseJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJoint.prototype, b2Joint.prototype);
b2MouseJoint.prototype._super = b2Joint.prototype;
b2MouseJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_target.SetV(def.target);
  var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
  var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
  var tMat = this.m_bodyB.m_xf.R;
  this.m_localAnchor.x = tX * tMat.col1.x + tY * tMat.col1.y;
  this.m_localAnchor.y = tX * tMat.col2.x + tY * tMat.col2.y;
  this.m_maxForce = def.maxForce;
  this.m_impulse.SetZero();
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_beta = 0;
  this.m_gamma = 0
};
b2MouseJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.m_localAnchor = new b2Vec2;
  this.m_target = new b2Vec2;
  this.m_impulse = new b2Vec2;
  this.m_mass = new b2Mat22;
  this.m_C = new b2Vec2
};
b2MouseJoint.prototype.InitVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var mass = b.GetMass();
  var omega = 2 * Math.PI * this.m_frequencyHz;
  var d = 2 * mass * this.m_dampingRatio * omega;
  var k = mass * omega * omega;
  this.m_gamma = step.dt * (d + step.dt * k);
  this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
  this.m_beta = step.dt * k * this.m_gamma;
  var tMat;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var invMass = b.m_invMass;
  var invI = b.m_invI;
  this.K1.col1.x = invMass;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass;
  this.K2.col1.x = invI * rY * rY;
  this.K2.col2.x = -invI * rX * rY;
  this.K2.col1.y = -invI * rX * rY;
  this.K2.col2.y = invI * rX * rX;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.col1.x += this.m_gamma;
  this.K.col2.y += this.m_gamma;
  this.K.GetInverse(this.m_mass);
  this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
  this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
  b.m_angularVelocity *= 0.98;
  this.m_impulse.x *= step.dtRatio;
  this.m_impulse.y *= step.dtRatio;
  b.m_linearVelocity.x += invMass * this.m_impulse.x;
  b.m_linearVelocity.y += invMass * this.m_impulse.y;
  b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x)
};
b2MouseJoint.prototype.SolveVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var tMat;
  var tX;
  var tY;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var CdotX = b.m_linearVelocity.x + -b.m_angularVelocity * rY;
  var CdotY = b.m_linearVelocity.y + b.m_angularVelocity * rX;
  tMat = this.m_mass;
  tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
  tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
  var impulseX = -(tMat.col1.x * tX + tMat.col2.x * tY);
  var impulseY = -(tMat.col1.y * tX + tMat.col2.y * tY);
  var oldImpulseX = this.m_impulse.x;
  var oldImpulseY = this.m_impulse.y;
  this.m_impulse.x += impulseX;
  this.m_impulse.y += impulseY;
  var maxImpulse = step.dt * this.m_maxForce;
  if(this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length())
  }
  impulseX = this.m_impulse.x - oldImpulseX;
  impulseY = this.m_impulse.y - oldImpulseY;
  b.m_linearVelocity.x += b.m_invMass * impulseX;
  b.m_linearVelocity.y += b.m_invMass * impulseY;
  b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX)
};
b2MouseJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2MouseJoint.prototype.GetAnchorA = function() {
  return this.m_target
};
b2MouseJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
};
b2MouseJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2MouseJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2MouseJoint.prototype.GetTarget = function() {
  return this.m_target
};
b2MouseJoint.prototype.SetTarget = function(target) {
  if(this.m_bodyB.IsAwake() == false) {
    this.m_bodyB.SetAwake(true)
  }
  this.m_target = target
};
b2MouseJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2MouseJoint.prototype.SetMaxForce = function(maxForce) {
  this.m_maxForce = maxForce
};
b2MouseJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2MouseJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2MouseJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2MouseJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2MouseJoint.prototype.K = new b2Mat22;
b2MouseJoint.prototype.K1 = new b2Mat22;
b2MouseJoint.prototype.K2 = new b2Mat22;
b2MouseJoint.prototype.m_localAnchor = new b2Vec2;
b2MouseJoint.prototype.m_target = new b2Vec2;
b2MouseJoint.prototype.m_impulse = new b2Vec2;
b2MouseJoint.prototype.m_mass = new b2Mat22;
b2MouseJoint.prototype.m_C = new b2Vec2;
b2MouseJoint.prototype.m_maxForce = null;
b2MouseJoint.prototype.m_frequencyHz = null;
b2MouseJoint.prototype.m_dampingRatio = null;
b2MouseJoint.prototype.m_beta = null;
b2MouseJoint.prototype.m_gamma = null;var b2PrismaticJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJointDef.prototype, b2JointDef.prototype);
b2PrismaticJointDef.prototype._super = b2JointDef.prototype;
b2PrismaticJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_prismaticJoint;
  this.localAxisA.Set(1, 0);
  this.referenceAngle = 0;
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2PrismaticJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2PrismaticJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2PrismaticJointDef.prototype.localAnchorA = new b2Vec2;
b2PrismaticJointDef.prototype.localAnchorB = new b2Vec2;
b2PrismaticJointDef.prototype.localAxisA = new b2Vec2;
b2PrismaticJointDef.prototype.referenceAngle = null;
b2PrismaticJointDef.prototype.enableLimit = null;
b2PrismaticJointDef.prototype.lowerTranslation = null;
b2PrismaticJointDef.prototype.upperTranslation = null;
b2PrismaticJointDef.prototype.enableMotor = null;
b2PrismaticJointDef.prototype.maxMotorForce = null;
b2PrismaticJointDef.prototype.motorSpeed = null;var b2TimeOfImpact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeOfImpact.prototype.__constructor = function() {
};
b2TimeOfImpact.prototype.__varz = function() {
};
b2TimeOfImpact.TimeOfImpact = function(input) {
  ++b2TimeOfImpact.b2_toiCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var sweepA = input.sweepA;
  var sweepB = input.sweepB;
  b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
  b2Settings.b2Assert(1 - sweepA.t0 > Number.MIN_VALUE);
  var radius = proxyA.m_radius + proxyB.m_radius;
  var tolerance = input.tolerance;
  var alpha = 0;
  var k_maxIterations = 1E3;
  var iter = 0;
  var target = 0;
  b2TimeOfImpact.s_cache.count = 0;
  b2TimeOfImpact.s_distanceInput.useRadii = false;
  for(;;) {
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
    b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
    b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
    b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
    b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
    b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
    if(b2TimeOfImpact.s_distanceOutput.distance <= 0) {
      alpha = 1;
      break
    }
    b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
    var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(separation <= 0) {
      alpha = 1;
      break
    }
    if(iter == 0) {
      if(separation > radius) {
        target = b2Math.Max(radius - tolerance, 0.75 * radius)
      }else {
        target = b2Math.Max(separation - tolerance, 0.02 * radius)
      }
    }
    if(separation - target < 0.5 * tolerance) {
      if(iter == 0) {
        alpha = 1;
        break
      }
      break
    }
    var newAlpha = alpha;
    var x1 = alpha;
    var x2 = 1;
    var f1 = separation;
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
    var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(f2 >= target) {
      alpha = 1;
      break
    }
    var rootIterCount = 0;
    for(;;) {
      var x;
      if(rootIterCount & 1) {
        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1)
      }else {
        x = 0.5 * (x1 + x2)
      }
      sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
      sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
      var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
      if(b2Math.Abs(f - target) < 0.025 * tolerance) {
        newAlpha = x;
        break
      }
      if(f > target) {
        x1 = x;
        f1 = f
      }else {
        x2 = x;
        f2 = f
      }
      ++rootIterCount;
      ++b2TimeOfImpact.b2_toiRootIters;
      if(rootIterCount == 50) {
        break
      }
    }
    b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
    if(newAlpha < (1 + 100 * Number.MIN_VALUE) * alpha) {
      break
    }
    alpha = newAlpha;
    iter++;
    ++b2TimeOfImpact.b2_toiIters;
    if(iter == k_maxIterations) {
      break
    }
  }
  b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
  return alpha
};
b2TimeOfImpact.b2_toiCalls = 0;
b2TimeOfImpact.b2_toiIters = 0;
b2TimeOfImpact.b2_toiMaxIters = 0;
b2TimeOfImpact.b2_toiRootIters = 0;
b2TimeOfImpact.b2_toiMaxRootIters = 0;
b2TimeOfImpact.s_cache = new b2SimplexCache;
b2TimeOfImpact.s_distanceInput = new b2DistanceInput;
b2TimeOfImpact.s_xfA = new b2Transform;
b2TimeOfImpact.s_xfB = new b2Transform;
b2TimeOfImpact.s_fcn = new b2SeparationFunction;
b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput;var b2GearJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJoint.prototype, b2Joint.prototype);
b2GearJoint.prototype._super = b2Joint.prototype;
b2GearJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var type1 = def.joint1.m_type;
  var type2 = def.joint2.m_type;
  this.m_revolute1 = null;
  this.m_prismatic1 = null;
  this.m_revolute2 = null;
  this.m_prismatic2 = null;
  var coordinate1;
  var coordinate2;
  this.m_ground1 = def.joint1.GetBodyA();
  this.m_bodyA = def.joint1.GetBodyB();
  if(type1 == b2Joint.e_revoluteJoint) {
    this.m_revolute1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    this.m_prismatic1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  this.m_ground2 = def.joint2.GetBodyA();
  this.m_bodyB = def.joint2.GetBodyB();
  if(type2 == b2Joint.e_revoluteJoint) {
    this.m_revolute2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    this.m_prismatic2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  this.m_ratio = def.ratio;
  this.m_constant = coordinate1 + this.m_ratio * coordinate2;
  this.m_impulse = 0
};
b2GearJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_J = new b2Jacobian
};
b2GearJoint.prototype.InitVelocityConstraints = function(step) {
  var g1 = this.m_ground1;
  var g2 = this.m_ground2;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var ugX;
  var ugY;
  var rX;
  var rY;
  var tMat;
  var tVec;
  var crug;
  var tX;
  var K = 0;
  this.m_J.SetZero();
  if(this.m_revolute1) {
    this.m_J.angularA = -1;
    K += bA.m_invI
  }else {
    tMat = g1.m_xf.R;
    tVec = this.m_prismatic1.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bA.m_xf.R;
    rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearA.Set(-ugX, -ugY);
    this.m_J.angularA = -crug;
    K += bA.m_invMass + bA.m_invI * crug * crug
  }
  if(this.m_revolute2) {
    this.m_J.angularB = -this.m_ratio;
    K += this.m_ratio * this.m_ratio * bB.m_invI
  }else {
    tMat = g2.m_xf.R;
    tVec = this.m_prismatic2.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bB.m_xf.R;
    rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearB.Set(-this.m_ratio * ugX, -this.m_ratio * ugY);
    this.m_J.angularB = -this.m_ratio * crug;
    K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug)
  }
  this.m_mass = K > 0 ? 1 / K : 0;
  if(step.warmStarting) {
    bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
    bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
    bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
    bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
    bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
    bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB
  }else {
    this.m_impulse = 0
  }
};
b2GearJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
  var impulse = -this.m_mass * Cdot;
  this.m_impulse += impulse;
  bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB
};
b2GearJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var linearError = 0;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var coordinate1;
  var coordinate2;
  if(this.m_revolute1) {
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  if(this.m_revolute2) {
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
  var impulse = -this.m_mass * C;
  bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError < b2Settings.b2_linearSlop
};
b2GearJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2GearJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2GearJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y)
};
b2GearJoint.prototype.GetReactionTorque = function(inv_dt) {
  var tMat = this.m_bodyB.m_xf.R;
  var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
  var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var PX = this.m_impulse * this.m_J.linearB.x;
  var PY = this.m_impulse * this.m_J.linearB.y;
  return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX)
};
b2GearJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2GearJoint.prototype.SetRatio = function(ratio) {
  this.m_ratio = ratio
};
b2GearJoint.prototype.m_ground1 = null;
b2GearJoint.prototype.m_ground2 = null;
b2GearJoint.prototype.m_revolute1 = null;
b2GearJoint.prototype.m_prismatic1 = null;
b2GearJoint.prototype.m_revolute2 = null;
b2GearJoint.prototype.m_prismatic2 = null;
b2GearJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_J = new b2Jacobian;
b2GearJoint.prototype.m_constant = null;
b2GearJoint.prototype.m_ratio = null;
b2GearJoint.prototype.m_mass = null;
b2GearJoint.prototype.m_impulse = null;var b2TOIInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TOIInput.prototype.__constructor = function() {
};
b2TOIInput.prototype.__varz = function() {
  this.proxyA = new b2DistanceProxy;
  this.proxyB = new b2DistanceProxy;
  this.sweepA = new b2Sweep;
  this.sweepB = new b2Sweep
};
b2TOIInput.prototype.proxyA = new b2DistanceProxy;
b2TOIInput.prototype.proxyB = new b2DistanceProxy;
b2TOIInput.prototype.sweepA = new b2Sweep;
b2TOIInput.prototype.sweepB = new b2Sweep;
b2TOIInput.prototype.tolerance = null;var b2RevoluteJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJointDef.prototype, b2JointDef.prototype);
b2RevoluteJointDef.prototype._super = b2JointDef.prototype;
b2RevoluteJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_revoluteJoint;
  this.localAnchorA.Set(0, 0);
  this.localAnchorB.Set(0, 0);
  this.referenceAngle = 0;
  this.lowerAngle = 0;
  this.upperAngle = 0;
  this.maxMotorTorque = 0;
  this.motorSpeed = 0;
  this.enableLimit = false;
  this.enableMotor = false
};
b2RevoluteJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2RevoluteJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2RevoluteJointDef.prototype.localAnchorA = new b2Vec2;
b2RevoluteJointDef.prototype.localAnchorB = new b2Vec2;
b2RevoluteJointDef.prototype.referenceAngle = null;
b2RevoluteJointDef.prototype.enableLimit = null;
b2RevoluteJointDef.prototype.lowerAngle = null;
b2RevoluteJointDef.prototype.upperAngle = null;
b2RevoluteJointDef.prototype.enableMotor = null;
b2RevoluteJointDef.prototype.motorSpeed = null;
b2RevoluteJointDef.prototype.maxMotorTorque = null;var b2MouseJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJointDef.prototype, b2JointDef.prototype);
b2MouseJointDef.prototype._super = b2JointDef.prototype;
b2MouseJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_mouseJoint;
  this.maxForce = 0;
  this.frequencyHz = 5;
  this.dampingRatio = 0.7
};
b2MouseJointDef.prototype.__varz = function() {
  this.target = new b2Vec2
};
b2MouseJointDef.prototype.target = new b2Vec2;
b2MouseJointDef.prototype.maxForce = null;
b2MouseJointDef.prototype.frequencyHz = null;
b2MouseJointDef.prototype.dampingRatio = null;var b2Contact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Contact.prototype.__constructor = function() {
};
b2Contact.prototype.__varz = function() {
  this.m_nodeA = new b2ContactEdge;
  this.m_nodeB = new b2ContactEdge;
  this.m_manifold = new b2Manifold;
  this.m_oldManifold = new b2Manifold
};
b2Contact.s_input = new b2TOIInput;
b2Contact.e_sensorFlag = 1;
b2Contact.e_continuousFlag = 2;
b2Contact.e_islandFlag = 4;
b2Contact.e_toiFlag = 8;
b2Contact.e_touchingFlag = 16;
b2Contact.e_enabledFlag = 32;
b2Contact.e_filterFlag = 64;
b2Contact.prototype.Reset = function(fixtureA, fixtureB) {
  this.m_flags = b2Contact.e_enabledFlag;
  if(!fixtureA || !fixtureB) {
    this.m_fixtureA = null;
    this.m_fixtureB = null;
    return
  }
  if(fixtureA.IsSensor() || fixtureB.IsSensor()) {
    this.m_flags |= b2Contact.e_sensorFlag
  }
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
    this.m_flags |= b2Contact.e_continuousFlag
  }
  this.m_fixtureA = fixtureA;
  this.m_fixtureB = fixtureB;
  this.m_manifold.m_pointCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_nodeA.contact = null;
  this.m_nodeA.prev = null;
  this.m_nodeA.next = null;
  this.m_nodeA.other = null;
  this.m_nodeB.contact = null;
  this.m_nodeB.prev = null;
  this.m_nodeB.next = null;
  this.m_nodeB.other = null
};
b2Contact.prototype.Update = function(listener) {
  var tManifold = this.m_oldManifold;
  this.m_oldManifold = this.m_manifold;
  this.m_manifold = tManifold;
  this.m_flags |= b2Contact.e_enabledFlag;
  var touching = false;
  var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
  var bodyA = this.m_fixtureA.m_body;
  var bodyB = this.m_fixtureB.m_body;
  var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
  if(this.m_flags & b2Contact.e_sensorFlag) {
    if(aabbOverlap) {
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      var xfA = bodyA.GetTransform();
      var xfB = bodyB.GetTransform();
      touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB)
    }
    this.m_manifold.m_pointCount = 0
  }else {
    if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
      this.m_flags |= b2Contact.e_continuousFlag
    }else {
      this.m_flags &= ~b2Contact.e_continuousFlag
    }
    if(aabbOverlap) {
      this.Evaluate();
      touching = this.m_manifold.m_pointCount > 0;
      for(var i = 0;i < this.m_manifold.m_pointCount;++i) {
        var mp2 = this.m_manifold.m_points[i];
        mp2.m_normalImpulse = 0;
        mp2.m_tangentImpulse = 0;
        var id2 = mp2.m_id;
        for(var j = 0;j < this.m_oldManifold.m_pointCount;++j) {
          var mp1 = this.m_oldManifold.m_points[j];
          if(mp1.m_id.key == id2.key) {
            mp2.m_normalImpulse = mp1.m_normalImpulse;
            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
            break
          }
        }
      }
    }else {
      this.m_manifold.m_pointCount = 0
    }
    if(touching != wasTouching) {
      bodyA.SetAwake(true);
      bodyB.SetAwake(true)
    }
  }
  if(touching) {
    this.m_flags |= b2Contact.e_touchingFlag
  }else {
    this.m_flags &= ~b2Contact.e_touchingFlag
  }
  if(wasTouching == false && touching == true) {
    listener.BeginContact(this)
  }
  if(wasTouching == true && touching == false) {
    listener.EndContact(this)
  }
  if((this.m_flags & b2Contact.e_sensorFlag) == 0) {
    listener.PreSolve(this, this.m_oldManifold)
  }
};
b2Contact.prototype.Evaluate = function() {
};
b2Contact.prototype.ComputeTOI = function(sweepA, sweepB) {
  b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
  b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
  b2Contact.s_input.sweepA = sweepA;
  b2Contact.s_input.sweepB = sweepB;
  b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
  return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input)
};
b2Contact.prototype.GetManifold = function() {
  return this.m_manifold
};
b2Contact.prototype.GetWorldManifold = function(worldManifold) {
  var bodyA = this.m_fixtureA.GetBody();
  var bodyB = this.m_fixtureB.GetBody();
  var shapeA = this.m_fixtureA.GetShape();
  var shapeB = this.m_fixtureB.GetShape();
  worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius)
};
b2Contact.prototype.IsTouching = function() {
  return(this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag
};
b2Contact.prototype.IsContinuous = function() {
  return(this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag
};
b2Contact.prototype.SetSensor = function(sensor) {
  if(sensor) {
    this.m_flags |= b2Contact.e_sensorFlag
  }else {
    this.m_flags &= ~b2Contact.e_sensorFlag
  }
};
b2Contact.prototype.IsSensor = function() {
  return(this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag
};
b2Contact.prototype.SetEnabled = function(flag) {
  if(flag) {
    this.m_flags |= b2Contact.e_enabledFlag
  }else {
    this.m_flags &= ~b2Contact.e_enabledFlag
  }
};
b2Contact.prototype.IsEnabled = function() {
  return(this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag
};
b2Contact.prototype.GetNext = function() {
  return this.m_next
};
b2Contact.prototype.GetFixtureA = function() {
  return this.m_fixtureA
};
b2Contact.prototype.GetFixtureB = function() {
  return this.m_fixtureB
};
b2Contact.prototype.FlagForFiltering = function() {
  this.m_flags |= b2Contact.e_filterFlag
};
b2Contact.prototype.m_flags = 0;
b2Contact.prototype.m_prev = null;
b2Contact.prototype.m_next = null;
b2Contact.prototype.m_nodeA = new b2ContactEdge;
b2Contact.prototype.m_nodeB = new b2ContactEdge;
b2Contact.prototype.m_fixtureA = null;
b2Contact.prototype.m_fixtureB = null;
b2Contact.prototype.m_manifold = new b2Manifold;
b2Contact.prototype.m_oldManifold = new b2Manifold;
b2Contact.prototype.m_toi = null;var b2ContactConstraint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraint.prototype.__constructor = function() {
  this.points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.points[i] = new b2ContactConstraintPoint
  }
};
b2ContactConstraint.prototype.__varz = function() {
  this.localPlaneNormal = new b2Vec2;
  this.localPoint = new b2Vec2;
  this.normal = new b2Vec2;
  this.normalMass = new b2Mat22;
  this.K = new b2Mat22
};
b2ContactConstraint.prototype.points = null;
b2ContactConstraint.prototype.localPlaneNormal = new b2Vec2;
b2ContactConstraint.prototype.localPoint = new b2Vec2;
b2ContactConstraint.prototype.normal = new b2Vec2;
b2ContactConstraint.prototype.normalMass = new b2Mat22;
b2ContactConstraint.prototype.K = new b2Mat22;
b2ContactConstraint.prototype.bodyA = null;
b2ContactConstraint.prototype.bodyB = null;
b2ContactConstraint.prototype.type = 0;
b2ContactConstraint.prototype.radius = null;
b2ContactConstraint.prototype.friction = null;
b2ContactConstraint.prototype.restitution = null;
b2ContactConstraint.prototype.pointCount = 0;
b2ContactConstraint.prototype.manifold = null;var b2ContactResult = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactResult.prototype.__constructor = function() {
};
b2ContactResult.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactResult.prototype.shape1 = null;
b2ContactResult.prototype.shape2 = null;
b2ContactResult.prototype.position = new b2Vec2;
b2ContactResult.prototype.normal = new b2Vec2;
b2ContactResult.prototype.normalImpulse = null;
b2ContactResult.prototype.tangentImpulse = null;
b2ContactResult.prototype.id = new b2ContactID;var b2PolygonContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonContact.prototype, b2Contact.prototype);
b2PolygonContact.prototype._super = b2Contact.prototype;
b2PolygonContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolygonContact.prototype.__varz = function() {
};
b2PolygonContact.Create = function(allocator) {
  return new b2PolygonContact
};
b2PolygonContact.Destroy = function(contact, allocator) {
};
b2PolygonContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolygonContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var ClipVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
ClipVertex.prototype.__constructor = function() {
};
ClipVertex.prototype.__varz = function() {
  this.v = new b2Vec2;
  this.id = new b2ContactID
};
ClipVertex.prototype.Set = function(other) {
  this.v.SetV(other.v);
  this.id.Set(other.id)
};
ClipVertex.prototype.v = new b2Vec2;
ClipVertex.prototype.id = new b2ContactID;var b2ContactFilter = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFilter.prototype.__constructor = function() {
};
b2ContactFilter.prototype.__varz = function() {
};
b2ContactFilter.b2_defaultFilter = new b2ContactFilter;
b2ContactFilter.prototype.ShouldCollide = function(fixtureA, fixtureB) {
  var filter1 = fixtureA.GetFilterData();
  var filter2 = fixtureB.GetFilterData();
  if(filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
    return filter1.groupIndex > 0
  }
  var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
  return collide
};
b2ContactFilter.prototype.RayCollide = function(userData, fixture) {
  if(!userData) {
    return true
  }
  return this.ShouldCollide(userData, fixture)
};var b2NullContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2NullContact.prototype, b2Contact.prototype);
b2NullContact.prototype._super = b2Contact.prototype;
b2NullContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2NullContact.prototype.__varz = function() {
};
b2NullContact.prototype.Evaluate = function() {
};var b2ContactListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactListener.prototype.__constructor = function() {
};
b2ContactListener.prototype.__varz = function() {
};
b2ContactListener.b2_defaultListener = new b2ContactListener;
b2ContactListener.prototype.BeginContact = function(contact) {
};
b2ContactListener.prototype.EndContact = function(contact) {
};
b2ContactListener.prototype.PreSolve = function(contact, oldManifold) {
};
b2ContactListener.prototype.PostSolve = function(contact, impulse) {
};var b2Island = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Island.prototype.__constructor = function() {
  this.m_bodies = new Array;
  this.m_contacts = new Array;
  this.m_joints = new Array
};
b2Island.prototype.__varz = function() {
};
b2Island.s_impulse = new b2ContactImpulse;
b2Island.prototype.Initialize = function(bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
  var i = 0;
  this.m_bodyCapacity = bodyCapacity;
  this.m_contactCapacity = contactCapacity;
  this.m_jointCapacity = jointCapacity;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_allocator = allocator;
  this.m_listener = listener;
  this.m_contactSolver = contactSolver;
  for(i = this.m_bodies.length;i < bodyCapacity;i++) {
    this.m_bodies[i] = null
  }
  for(i = this.m_contacts.length;i < contactCapacity;i++) {
    this.m_contacts[i] = null
  }
  for(i = this.m_joints.length;i < jointCapacity;i++) {
    this.m_joints[i] = null
  }
};
b2Island.prototype.Clear = function() {
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0
};
b2Island.prototype.Solve = function(step, gravity, allowSleep) {
  var i = 0;
  var j = 0;
  var b;
  var joint;
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() != b2Body.b2_dynamicBody) {
      continue
    }
    b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
    b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
    b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
    b.m_linearVelocity.Multiply(b2Math.Clamp(1 - step.dt * b.m_linearDamping, 0, 1));
    b.m_angularVelocity *= b2Math.Clamp(1 - step.dt * b.m_angularDamping, 0, 1)
  }
  this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  contactSolver.InitVelocityConstraints(step);
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.InitVelocityConstraints(step)
  }
  for(i = 0;i < step.velocityIterations;++i) {
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      joint.SolveVelocityConstraints(step)
    }
    contactSolver.SolveVelocityConstraints()
  }
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.FinalizeVelocityConstraints()
  }
  contactSolver.FinalizeVelocityConstraints();
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = step.dt * b.m_linearVelocity.x;
    var translationY = step.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt
    }
    var rotation = step.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * step.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
    b.m_sweep.a += step.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  for(i = 0;i < step.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints);
  if(allowSleep) {
    var minSleepTime = Number.MAX_VALUE;
    var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
    var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
    for(i = 0;i < this.m_bodyCount;++i) {
      b = this.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }else {
        b.m_sleepTime += step.dt;
        minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime)
      }
    }
    if(minSleepTime >= b2Settings.b2_timeToSleep) {
      for(i = 0;i < this.m_bodyCount;++i) {
        b = this.m_bodies[i];
        b.SetAwake(false)
      }
    }
  }
};
b2Island.prototype.SolveTOI = function(subStep) {
  var i = 0;
  var j = 0;
  this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  for(i = 0;i < this.m_jointCount;++i) {
    this.m_joints[i].InitVelocityConstraints(subStep)
  }
  for(i = 0;i < subStep.velocityIterations;++i) {
    contactSolver.SolveVelocityConstraints();
    for(j = 0;j < this.m_jointCount;++j) {
      this.m_joints[j].SolveVelocityConstraints(subStep)
    }
  }
  for(i = 0;i < this.m_bodyCount;++i) {
    var b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = subStep.dt * b.m_linearVelocity.x;
    var translationY = subStep.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt
    }
    var rotation = subStep.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * subStep.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
    b.m_sweep.a += subStep.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  var k_toiBaumgarte = 0.75;
  for(i = 0;i < subStep.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints)
};
b2Island.prototype.Report = function(constraints) {
  if(this.m_listener == null) {
    return
  }
  for(var i = 0;i < this.m_contactCount;++i) {
    var c = this.m_contacts[i];
    var cc = constraints[i];
    for(var j = 0;j < cc.pointCount;++j) {
      b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
      b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse
    }
    this.m_listener.PostSolve(c, b2Island.s_impulse)
  }
};
b2Island.prototype.AddBody = function(body) {
  body.m_islandIndex = this.m_bodyCount;
  this.m_bodies[this.m_bodyCount++] = body
};
b2Island.prototype.AddContact = function(contact) {
  this.m_contacts[this.m_contactCount++] = contact
};
b2Island.prototype.AddJoint = function(joint) {
  this.m_joints[this.m_jointCount++] = joint
};
b2Island.prototype.m_allocator = null;
b2Island.prototype.m_listener = null;
b2Island.prototype.m_contactSolver = null;
b2Island.prototype.m_bodies = null;
b2Island.prototype.m_contacts = null;
b2Island.prototype.m_joints = null;
b2Island.prototype.m_bodyCount = 0;
b2Island.prototype.m_jointCount = 0;
b2Island.prototype.m_contactCount = 0;
b2Island.prototype.m_bodyCapacity = 0;
b2Island.prototype.m_contactCapacity = 0;
b2Island.prototype.m_jointCapacity = 0;var b2PolyAndEdgeContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndEdgeContact.prototype, b2Contact.prototype);
b2PolyAndEdgeContact.prototype._super = b2Contact.prototype;
b2PolyAndEdgeContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndEdgeContact.prototype.__varz = function() {
};
b2PolyAndEdgeContact.Create = function(allocator) {
  return new b2PolyAndEdgeContact
};
b2PolyAndEdgeContact.Destroy = function(contact, allocator) {
};
b2PolyAndEdgeContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function(manifold, polygon, xf1, edge, xf2) {
};
b2PolyAndEdgeContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape)
};var b2Collision = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Collision.prototype.__constructor = function() {
};
b2Collision.prototype.__varz = function() {
};
b2Collision.MakeClipPointVector = function() {
  var r = new Array(2);
  r[0] = new ClipVertex;
  r[1] = new ClipVertex;
  return r
};
b2Collision.ClipSegmentToLine = function(vOut, vIn, normal, offset) {
  var cv;
  var numOut = 0;
  cv = vIn[0];
  var vIn0 = cv.v;
  cv = vIn[1];
  var vIn1 = cv.v;
  var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
  var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
  if(distance0 <= 0) {
    vOut[numOut++].Set(vIn[0])
  }
  if(distance1 <= 0) {
    vOut[numOut++].Set(vIn[1])
  }
  if(distance0 * distance1 < 0) {
    var interp = distance0 / (distance0 - distance1);
    cv = vOut[numOut];
    var tVec = cv.v;
    tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
    tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
    cv = vOut[numOut];
    var cv2;
    if(distance0 > 0) {
      cv2 = vIn[0];
      cv.id = cv2.id
    }else {
      cv2 = vIn[1];
      cv.id = cv2.id
    }
    ++numOut
  }
  return numOut
};
b2Collision.EdgeSeparation = function(poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1WorldX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1WorldY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var normal1X = tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY;
  var normal1Y = tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = vertices2[i];
    var dot = tVec.x * normal1X + tVec.y * normal1Y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  tVec = vertices1[edge1];
  tMat = xf1.R;
  var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tVec = vertices2[index];
  tMat = xf2.R;
  var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  v2X -= v1X;
  v2Y -= v1Y;
  var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
  return separation
};
b2Collision.FindMaxSeparation = function(edgeIndex, poly1, xf1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = poly2.m_centroid;
  var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf1.R;
  tVec = poly1.m_centroid;
  dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dLocal1X = dX * xf1.R.col1.x + dY * xf1.R.col1.y;
  var dLocal1Y = dX * xf1.R.col2.x + dY * xf1.R.col2.y;
  var edge = 0;
  var maxDot = -Number.MAX_VALUE;
  for(var i = 0;i < count1;++i) {
    tVec = normals1[i];
    var dot = tVec.x * dLocal1X + tVec.y * dLocal1Y;
    if(dot > maxDot) {
      maxDot = dot;
      edge = i
    }
  }
  var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
  var prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
  var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
  var nextEdge = edge + 1 < count1 ? edge + 1 : 0;
  var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
  var bestEdge = 0;
  var bestSeparation;
  var increment = 0;
  if(sPrev > s && sPrev > sNext) {
    increment = -1;
    bestEdge = prevEdge;
    bestSeparation = sPrev
  }else {
    if(sNext > s) {
      increment = 1;
      bestEdge = nextEdge;
      bestSeparation = sNext
    }else {
      edgeIndex[0] = edge;
      return s
    }
  }
  while(true) {
    if(increment == -1) {
      edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1
    }else {
      edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0
    }
    s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
    if(s > bestSeparation) {
      bestEdge = edge;
      bestSeparation = s
    }else {
      break
    }
  }
  edgeIndex[0] = bestEdge;
  return bestSeparation
};
b2Collision.FindIncidentEdge = function(c, poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var normals2 = poly2.m_normals;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var tX = tMat.col1.x * normal1X + tMat.col1.y * normal1Y;
  normal1Y = tMat.col2.x * normal1X + tMat.col2.y * normal1Y;
  normal1X = tX;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = normals2[i];
    var dot = normal1X * tVec.x + normal1Y * tVec.y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  var tClip;
  var i1 = index;
  var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
  tClip = c[0];
  tVec = vertices2[i1];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i1;
  tClip.id.features.incidentVertex = 0;
  tClip = c[1];
  tVec = vertices2[i2];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i2;
  tClip.id.features.incidentVertex = 1
};
b2Collision.CollidePolygons = function(manifold, polyA, xfA, polyB, xfB) {
  var cv;
  manifold.m_pointCount = 0;
  var totalRadius = polyA.m_radius + polyB.m_radius;
  var edgeA = 0;
  b2Collision.s_edgeAO[0] = edgeA;
  var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
  edgeA = b2Collision.s_edgeAO[0];
  if(separationA > totalRadius) {
    return
  }
  var edgeB = 0;
  b2Collision.s_edgeBO[0] = edgeB;
  var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
  edgeB = b2Collision.s_edgeBO[0];
  if(separationB > totalRadius) {
    return
  }
  var poly1;
  var poly2;
  var xf1;
  var xf2;
  var edge1 = 0;
  var flip = 0;
  var k_relativeTol = 0.98;
  var k_absoluteTol = 0.0010;
  var tMat;
  if(separationB > k_relativeTol * separationA + k_absoluteTol) {
    poly1 = polyB;
    poly2 = polyA;
    xf1 = xfB;
    xf2 = xfA;
    edge1 = edgeB;
    manifold.m_type = b2Manifold.e_faceB;
    flip = 1
  }else {
    poly1 = polyA;
    poly2 = polyB;
    xf1 = xfA;
    xf2 = xfB;
    edge1 = edgeA;
    manifold.m_type = b2Manifold.e_faceA;
    flip = 0
  }
  var incidentEdge = b2Collision.s_incidentEdge;
  b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var local_v11 = vertices1[edge1];
  var local_v12;
  if(edge1 + 1 < count1) {
    local_v12 = vertices1[parseInt(edge1 + 1)]
  }else {
    local_v12 = vertices1[0]
  }
  var localTangent = b2Collision.s_localTangent;
  localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
  localTangent.Normalize();
  var localNormal = b2Collision.s_localNormal;
  localNormal.x = localTangent.y;
  localNormal.y = -localTangent.x;
  var planePoint = b2Collision.s_planePoint;
  planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
  var tangent = b2Collision.s_tangent;
  tMat = xf1.R;
  tangent.x = tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y;
  tangent.y = tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y;
  var tangent2 = b2Collision.s_tangent2;
  tangent2.x = -tangent.x;
  tangent2.y = -tangent.y;
  var normal = b2Collision.s_normal;
  normal.x = tangent.y;
  normal.y = -tangent.x;
  var v11 = b2Collision.s_v11;
  var v12 = b2Collision.s_v12;
  v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
  v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
  v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
  v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
  var frontOffset = normal.x * v11.x + normal.y * v11.y;
  var sideOffset1 = -tangent.x * v11.x - tangent.y * v11.y + totalRadius;
  var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
  var clipPoints1 = b2Collision.s_clipPoints1;
  var clipPoints2 = b2Collision.s_clipPoints2;
  var np = 0;
  np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
  if(np < 2) {
    return
  }
  np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
  if(np < 2) {
    return
  }
  manifold.m_localPlaneNormal.SetV(localNormal);
  manifold.m_localPoint.SetV(planePoint);
  var pointCount = 0;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;++i) {
    cv = clipPoints2[i];
    var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
    if(separation <= totalRadius) {
      var cp = manifold.m_points[pointCount];
      tMat = xf2.R;
      var tX = cv.v.x - xf2.position.x;
      var tY = cv.v.y - xf2.position.y;
      cp.m_localPoint.x = tX * tMat.col1.x + tY * tMat.col1.y;
      cp.m_localPoint.y = tX * tMat.col2.x + tY * tMat.col2.y;
      cp.m_id.Set(cv.id);
      cp.m_id.features.flip = flip;
      ++pointCount
    }
  }
  manifold.m_pointCount = pointCount
};
b2Collision.CollideCircles = function(manifold, circle1, xf1, circle2, xf2) {
  manifold.m_pointCount = 0;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = circle1.m_p;
  var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf2.R;
  tVec = circle2.m_p;
  var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var distSqr = dX * dX + dY * dY;
  var radius = circle1.m_radius + circle2.m_radius;
  if(distSqr > radius * radius) {
    return
  }
  manifold.m_type = b2Manifold.e_circles;
  manifold.m_localPoint.SetV(circle1.m_p);
  manifold.m_localPlaneNormal.SetZero();
  manifold.m_pointCount = 1;
  manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
  manifold.m_points[0].m_id.key = 0
};
b2Collision.CollidePolygonAndCircle = function(manifold, polygon, xf1, circle, xf2) {
  manifold.m_pointCount = 0;
  var tPoint;
  var dX;
  var dY;
  var positionX;
  var positionY;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = circle.m_p;
  var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  dX = cX - xf1.position.x;
  dY = cY - xf1.position.y;
  tMat = xf1.R;
  var cLocalX = dX * tMat.col1.x + dY * tMat.col1.y;
  var cLocalY = dX * tMat.col2.x + dY * tMat.col2.y;
  var dist;
  var normalIndex = 0;
  var separation = -Number.MAX_VALUE;
  var radius = polygon.m_radius + circle.m_radius;
  var vertexCount = polygon.m_vertexCount;
  var vertices = polygon.m_vertices;
  var normals = polygon.m_normals;
  for(var i = 0;i < vertexCount;++i) {
    tVec = vertices[i];
    dX = cLocalX - tVec.x;
    dY = cLocalY - tVec.y;
    tVec = normals[i];
    var s = tVec.x * dX + tVec.y * dY;
    if(s > radius) {
      return
    }
    if(s > separation) {
      separation = s;
      normalIndex = i
    }
  }
  var vertIndex1 = normalIndex;
  var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
  var v1 = vertices[vertIndex1];
  var v2 = vertices[vertIndex2];
  if(separation < Number.MIN_VALUE) {
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
    manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
    manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
    return
  }
  var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
  var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
  if(u1 <= 0) {
    if((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) {
      return
    }
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.x = cLocalX - v1.x;
    manifold.m_localPlaneNormal.y = cLocalY - v1.y;
    manifold.m_localPlaneNormal.Normalize();
    manifold.m_localPoint.SetV(v1);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0
  }else {
    if(u2 <= 0) {
      if((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = cLocalX - v2.x;
      manifold.m_localPlaneNormal.y = cLocalY - v2.y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.SetV(v2);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }else {
      var faceCenterX = 0.5 * (v1.x + v2.x);
      var faceCenterY = 0.5 * (v1.y + v2.y);
      separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
      if(separation > radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
      manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.Set(faceCenterX, faceCenterY);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }
  }
};
b2Collision.TestOverlap = function(a, b) {
  var t1 = b.lowerBound;
  var t2 = a.upperBound;
  var d1X = t1.x - t2.x;
  var d1Y = t1.y - t2.y;
  t1 = a.lowerBound;
  t2 = b.upperBound;
  var d2X = t1.x - t2.x;
  var d2Y = t1.y - t2.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2Collision.b2_nullFeature = 255;
b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
b2Collision.s_edgeAO = new Array(1);
b2Collision.s_edgeBO = new Array(1);
b2Collision.s_localTangent = new b2Vec2;
b2Collision.s_localNormal = new b2Vec2;
b2Collision.s_planePoint = new b2Vec2;
b2Collision.s_normal = new b2Vec2;
b2Collision.s_tangent = new b2Vec2;
b2Collision.s_tangent2 = new b2Vec2;
b2Collision.s_v11 = new b2Vec2;
b2Collision.s_v12 = new b2Vec2;
b2Collision.b2CollidePolyTempVec = new b2Vec2;var b2PolyAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndCircleContact.prototype, b2Contact.prototype);
b2PolyAndCircleContact.prototype._super = b2Contact.prototype;
b2PolyAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndCircleContact.prototype.__varz = function() {
};
b2PolyAndCircleContact.Create = function(allocator) {
  return new b2PolyAndCircleContact
};
b2PolyAndCircleContact.Destroy = function(contact, allocator) {
};
b2PolyAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.m_body;
  var bB = this.m_fixtureB.m_body;
  b2Collision.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape)
};var b2ContactPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactPoint.prototype.__constructor = function() {
};
b2ContactPoint.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.velocity = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactPoint.prototype.shape1 = null;
b2ContactPoint.prototype.shape2 = null;
b2ContactPoint.prototype.position = new b2Vec2;
b2ContactPoint.prototype.velocity = new b2Vec2;
b2ContactPoint.prototype.normal = new b2Vec2;
b2ContactPoint.prototype.separation = null;
b2ContactPoint.prototype.friction = null;
b2ContactPoint.prototype.restitution = null;
b2ContactPoint.prototype.id = new b2ContactID;var b2CircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleContact.prototype, b2Contact.prototype);
b2CircleContact.prototype._super = b2Contact.prototype;
b2CircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2CircleContact.prototype.__varz = function() {
};
b2CircleContact.Create = function(allocator) {
  return new b2CircleContact
};
b2CircleContact.Destroy = function(contact, allocator) {
};
b2CircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2CircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2EdgeAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeAndCircleContact.prototype, b2Contact.prototype);
b2EdgeAndCircleContact.prototype._super = b2Contact.prototype;
b2EdgeAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2EdgeAndCircleContact.prototype.__varz = function() {
};
b2EdgeAndCircleContact.Create = function(allocator) {
  return new b2EdgeAndCircleContact
};
b2EdgeAndCircleContact.Destroy = function(contact, allocator) {
};
b2EdgeAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function(manifold, edge, xf1, circle, xf2) {
};
b2EdgeAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2ContactManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactManager.prototype.__constructor = function() {
  this.m_world = null;
  this.m_contactCount = 0;
  this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
  this.m_contactListener = b2ContactListener.b2_defaultListener;
  this.m_contactFactory = new b2ContactFactory(this.m_allocator);
  this.m_broadPhase = new b2DynamicTreeBroadPhase
};
b2ContactManager.prototype.__varz = function() {
};
b2ContactManager.s_evalCP = new b2ContactPoint;
b2ContactManager.prototype.AddPair = function(proxyUserDataA, proxyUserDataB) {
  var fixtureA = proxyUserDataA;
  var fixtureB = proxyUserDataB;
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA == bodyB) {
    return
  }
  var edge = bodyB.GetContactList();
  while(edge) {
    if(edge.other == bodyA) {
      var fA = edge.contact.GetFixtureA();
      var fB = edge.contact.GetFixtureB();
      if(fA == fixtureA && fB == fixtureB) {
        return
      }
      if(fA == fixtureB && fB == fixtureA) {
        return
      }
    }
    edge = edge.next
  }
  if(bodyB.ShouldCollide(bodyA) == false) {
    return
  }
  if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
    return
  }
  var c = this.m_contactFactory.Create(fixtureA, fixtureB);
  fixtureA = c.GetFixtureA();
  fixtureB = c.GetFixtureB();
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  c.m_prev = null;
  c.m_next = this.m_world.m_contactList;
  if(this.m_world.m_contactList != null) {
    this.m_world.m_contactList.m_prev = c
  }
  this.m_world.m_contactList = c;
  c.m_nodeA.contact = c;
  c.m_nodeA.other = bodyB;
  c.m_nodeA.prev = null;
  c.m_nodeA.next = bodyA.m_contactList;
  if(bodyA.m_contactList != null) {
    bodyA.m_contactList.prev = c.m_nodeA
  }
  bodyA.m_contactList = c.m_nodeA;
  c.m_nodeB.contact = c;
  c.m_nodeB.other = bodyA;
  c.m_nodeB.prev = null;
  c.m_nodeB.next = bodyB.m_contactList;
  if(bodyB.m_contactList != null) {
    bodyB.m_contactList.prev = c.m_nodeB
  }
  bodyB.m_contactList = c.m_nodeB;
  ++this.m_world.m_contactCount;
  return
};
b2ContactManager.prototype.FindNewContacts = function() {
  var that = this;
  this.m_broadPhase.UpdatePairs(function(a, b) {
    return that.AddPair(a, b)
  })
};
b2ContactManager.prototype.Destroy = function(c) {
  var fixtureA = c.GetFixtureA();
  var fixtureB = c.GetFixtureB();
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(c.IsTouching()) {
    this.m_contactListener.EndContact(c)
  }
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(c == this.m_world.m_contactList) {
    this.m_world.m_contactList = c.m_next
  }
  if(c.m_nodeA.prev) {
    c.m_nodeA.prev.next = c.m_nodeA.next
  }
  if(c.m_nodeA.next) {
    c.m_nodeA.next.prev = c.m_nodeA.prev
  }
  if(c.m_nodeA == bodyA.m_contactList) {
    bodyA.m_contactList = c.m_nodeA.next
  }
  if(c.m_nodeB.prev) {
    c.m_nodeB.prev.next = c.m_nodeB.next
  }
  if(c.m_nodeB.next) {
    c.m_nodeB.next.prev = c.m_nodeB.prev
  }
  if(c.m_nodeB == bodyB.m_contactList) {
    bodyB.m_contactList = c.m_nodeB.next
  }
  this.m_contactFactory.Destroy(c);
  --this.m_contactCount
};
b2ContactManager.prototype.Collide = function() {
  var c = this.m_world.m_contactList;
  while(c) {
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    var bodyA = fixtureA.GetBody();
    var bodyB = fixtureB.GetBody();
    if(bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
      c = c.GetNext();
      continue
    }
    if(c.m_flags & b2Contact.e_filterFlag) {
      if(bodyB.ShouldCollide(bodyA) == false) {
        var cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
        cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      c.m_flags &= ~b2Contact.e_filterFlag
    }
    var proxyA = fixtureA.m_proxy;
    var proxyB = fixtureB.m_proxy;
    var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
    if(overlap == false) {
      cNuke = c;
      c = cNuke.GetNext();
      this.Destroy(cNuke);
      continue
    }
    c.Update(this.m_contactListener);
    c = c.GetNext()
  }
};
b2ContactManager.prototype.m_world = null;
b2ContactManager.prototype.m_broadPhase = null;
b2ContactManager.prototype.m_contactList = null;
b2ContactManager.prototype.m_contactCount = 0;
b2ContactManager.prototype.m_contactFilter = null;
b2ContactManager.prototype.m_contactListener = null;
b2ContactManager.prototype.m_contactFactory = null;
b2ContactManager.prototype.m_allocator = null;var b2World = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2World.prototype.__constructor = function(gravity, doSleep) {
  this.m_destructionListener = null;
  this.m_debugDraw = null;
  this.m_bodyList = null;
  this.m_contactList = null;
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_controllerCount = 0;
  b2World.m_warmStarting = true;
  b2World.m_continuousPhysics = true;
  this.m_allowSleep = doSleep;
  this.m_gravity = gravity;
  this.m_inv_dt0 = 0;
  this.m_contactManager.m_world = this;
  var bd = new b2BodyDef;
  this.m_groundBody = this.CreateBody(bd)
};
b2World.prototype.__varz = function() {
  this.s_stack = new Array;
  this.m_contactManager = new b2ContactManager;
  this.m_contactSolver = new b2ContactSolver;
  this.m_island = new b2Island
};
b2World.s_timestep2 = new b2TimeStep;
b2World.s_backupA = new b2Sweep;
b2World.s_backupB = new b2Sweep;
b2World.s_timestep = new b2TimeStep;
b2World.s_queue = new Array;
b2World.e_newFixture = 1;
b2World.e_locked = 2;
b2World.s_xf = new b2Transform;
b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
b2World.m_warmStarting = null;
b2World.m_continuousPhysics = null;
b2World.prototype.Solve = function(step) {
  var b;
  for(var controller = this.m_controllerList;controller;controller = controller.m_next) {
    controller.Step(step)
  }
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag
  }
  for(var c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~b2Contact.e_islandFlag
  }
  for(var j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  var stackSize = this.m_bodyCount;
  var stack = this.s_stack;
  for(var seed = this.m_bodyList;seed;seed = seed.m_next) {
    if(seed.m_flags & b2Body.e_islandFlag) {
      continue
    }
    if(seed.IsAwake() == false || seed.IsActive() == false) {
      continue
    }
    if(seed.GetType() == b2Body.b2_staticBody) {
      continue
    }
    island.Clear();
    var stackCount = 0;
    stack[stackCount++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(stackCount > 0) {
      b = stack[--stackCount];
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      var other;
      for(var ce = b.m_contactList;ce;ce = ce.next) {
        if(ce.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(ce.contact);
        ce.contact.m_flags |= b2Contact.e_islandFlag;
        other = ce.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jn = b.m_jointList;jn;jn = jn.next) {
        if(jn.joint.m_islandFlag == true) {
          continue
        }
        other = jn.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jn.joint);
        jn.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    island.Solve(step, this.m_gravity, this.m_allowSleep);
    for(var i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        b.m_flags &= ~b2Body.e_islandFlag
      }
    }
  }
  for(i = 0;i < stack.length;++i) {
    if(!stack[i]) {
      break
    }
    stack[i] = null
  }
  for(b = this.m_bodyList;b;b = b.m_next) {
    if(b.IsAwake() == false || b.IsActive() == false) {
      continue
    }
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    b.SynchronizeFixtures()
  }
  this.m_contactManager.FindNewContacts()
};
b2World.prototype.SolveTOI = function(step) {
  var b;
  var fA;
  var fB;
  var bA;
  var bB;
  var cEdge;
  var j;
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  var queue = b2World.s_queue;
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag;
    b.m_sweep.t0 = 0
  }
  var c;
  for(c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
  }
  for(j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  for(;;) {
    var minContact = null;
    var minTOI = 1;
    for(c = this.m_contactList;c;c = c.m_next) {
      if(c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
        continue
      }
      var toi = 1;
      if(c.m_flags & b2Contact.e_toiFlag) {
        toi = c.m_toi
      }else {
        fA = c.m_fixtureA;
        fB = c.m_fixtureB;
        bA = fA.m_body;
        bB = fB.m_body;
        if((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
          continue
        }
        var t0 = bA.m_sweep.t0;
        if(bA.m_sweep.t0 < bB.m_sweep.t0) {
          t0 = bB.m_sweep.t0;
          bA.m_sweep.Advance(t0)
        }else {
          if(bB.m_sweep.t0 < bA.m_sweep.t0) {
            t0 = bA.m_sweep.t0;
            bB.m_sweep.Advance(t0)
          }
        }
        toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
        b2Settings.b2Assert(0 <= toi && toi <= 1);
        if(toi > 0 && toi < 1) {
          toi = (1 - toi) * t0 + toi;
          if(toi > 1) {
            toi = 1
          }
        }
        c.m_toi = toi;
        c.m_flags |= b2Contact.e_toiFlag
      }
      if(Number.MIN_VALUE < toi && toi < minTOI) {
        minContact = c;
        minTOI = toi
      }
    }
    if(minContact == null || 1 - 100 * Number.MIN_VALUE < minTOI) {
      break
    }
    fA = minContact.m_fixtureA;
    fB = minContact.m_fixtureB;
    bA = fA.m_body;
    bB = fB.m_body;
    b2World.s_backupA.Set(bA.m_sweep);
    b2World.s_backupB.Set(bB.m_sweep);
    bA.Advance(minTOI);
    bB.Advance(minTOI);
    minContact.Update(this.m_contactManager.m_contactListener);
    minContact.m_flags &= ~b2Contact.e_toiFlag;
    if(minContact.IsSensor() == true || minContact.IsEnabled() == false) {
      bA.m_sweep.Set(b2World.s_backupA);
      bB.m_sweep.Set(b2World.s_backupB);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      continue
    }
    if(minContact.IsTouching() == false) {
      continue
    }
    var seed = bA;
    if(seed.GetType() != b2Body.b2_dynamicBody) {
      seed = bB
    }
    island.Clear();
    var queueStart = 0;
    var queueSize = 0;
    queue[queueStart + queueSize++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(queueSize > 0) {
      b = queue[queueStart++];
      --queueSize;
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        if(island.m_contactCount == island.m_contactCapacity) {
          break
        }
        if(cEdge.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(cEdge.contact);
        cEdge.contact.m_flags |= b2Contact.e_islandFlag;
        var other = cEdge.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jEdge = b.m_jointList;jEdge;jEdge = jEdge.next) {
        if(island.m_jointCount == island.m_jointCapacity) {
          continue
        }
        if(jEdge.joint.m_islandFlag == true) {
          continue
        }
        other = jEdge.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jEdge.joint);
        jEdge.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    var subStep = b2World.s_timestep;
    subStep.warmStarting = false;
    subStep.dt = (1 - minTOI) * step.dt;
    subStep.inv_dt = 1 / subStep.dt;
    subStep.dtRatio = 0;
    subStep.velocityIterations = step.velocityIterations;
    subStep.positionIterations = step.positionIterations;
    island.SolveTOI(subStep);
    var i = 0;
    for(i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      b.m_flags &= ~b2Body.e_islandFlag;
      if(b.IsAwake() == false) {
        continue
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      b.SynchronizeFixtures();
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        cEdge.contact.m_flags &= ~b2Contact.e_toiFlag
      }
    }
    for(i = 0;i < island.m_contactCount;++i) {
      c = island.m_contacts[i];
      c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
    }
    for(i = 0;i < island.m_jointCount;++i) {
      j = island.m_joints[i];
      j.m_islandFlag = false
    }
    this.m_contactManager.FindNewContacts()
  }
};
b2World.prototype.DrawJoint = function(joint) {
  var b1 = joint.GetBodyA();
  var b2 = joint.GetBodyB();
  var xf1 = b1.m_xf;
  var xf2 = b2.m_xf;
  var x1 = xf1.position;
  var x2 = xf2.position;
  var p1 = joint.GetAnchorA();
  var p2 = joint.GetAnchorB();
  var color = b2World.s_jointColor;
  switch(joint.m_type) {
    case b2Joint.e_distanceJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    case b2Joint.e_pulleyJoint:
      var pulley = joint;
      var s1 = pulley.GetGroundAnchorA();
      var s2 = pulley.GetGroundAnchorB();
      this.m_debugDraw.DrawSegment(s1, p1, color);
      this.m_debugDraw.DrawSegment(s2, p2, color);
      this.m_debugDraw.DrawSegment(s1, s2, color);
      break;
    case b2Joint.e_mouseJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    default:
      if(b1 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x1, p1, color)
      }
      this.m_debugDraw.DrawSegment(p1, p2, color);
      if(b2 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x2, p2, color)
      }
  }
};
b2World.prototype.DrawShape = function(shape, xf, color) {
  switch(shape.m_type) {
    case b2Shape.e_circleShape:
      var circle = shape;
      var center = b2Math.MulX(xf, circle.m_p);
      var radius = circle.m_radius;
      var axis = xf.R.col1;
      this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
      break;
    case b2Shape.e_polygonShape:
      var i = 0;
      var poly = shape;
      var vertexCount = poly.GetVertexCount();
      var localVertices = poly.GetVertices();
      var vertices = new Array(vertexCount);
      for(i = 0;i < vertexCount;++i) {
        vertices[i] = b2Math.MulX(xf, localVertices[i])
      }
      this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
      break;
    case b2Shape.e_edgeShape:
      var edge = shape;
      this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
      break
  }
};
b2World.prototype.SetDestructionListener = function(listener) {
  this.m_destructionListener = listener
};
b2World.prototype.SetContactFilter = function(filter) {
  this.m_contactManager.m_contactFilter = filter
};
b2World.prototype.SetContactListener = function(listener) {
  this.m_contactManager.m_contactListener = listener
};
b2World.prototype.SetDebugDraw = function(debugDraw) {
  this.m_debugDraw = debugDraw
};
b2World.prototype.SetBroadPhase = function(broadPhase) {
  var oldBroadPhase = this.m_contactManager.m_broadPhase;
  this.m_contactManager.m_broadPhase = broadPhase;
  for(var b = this.m_bodyList;b;b = b.m_next) {
    for(var f = b.m_fixtureList;f;f = f.m_next) {
      f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f)
    }
  }
};
b2World.prototype.Validate = function() {
  this.m_contactManager.m_broadPhase.Validate()
};
b2World.prototype.GetProxyCount = function() {
  return this.m_contactManager.m_broadPhase.GetProxyCount()
};
b2World.prototype.CreateBody = function(def) {
  if(this.IsLocked() == true) {
    return null
  }
  var b = new b2Body(def, this);
  b.m_prev = null;
  b.m_next = this.m_bodyList;
  if(this.m_bodyList) {
    this.m_bodyList.m_prev = b
  }
  this.m_bodyList = b;
  ++this.m_bodyCount;
  return b
};
b2World.prototype.DestroyBody = function(b) {
  if(this.IsLocked() == true) {
    return
  }
  var jn = b.m_jointList;
  while(jn) {
    var jn0 = jn;
    jn = jn.next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeJoint(jn0.joint)
    }
    this.DestroyJoint(jn0.joint)
  }
  var coe = b.m_controllerList;
  while(coe) {
    var coe0 = coe;
    coe = coe.nextController;
    coe0.controller.RemoveBody(b)
  }
  var ce = b.m_contactList;
  while(ce) {
    var ce0 = ce;
    ce = ce.next;
    this.m_contactManager.Destroy(ce0.contact)
  }
  b.m_contactList = null;
  var f = b.m_fixtureList;
  while(f) {
    var f0 = f;
    f = f.m_next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeFixture(f0)
    }
    f0.DestroyProxy(this.m_contactManager.m_broadPhase);
    f0.Destroy()
  }
  b.m_fixtureList = null;
  b.m_fixtureCount = 0;
  if(b.m_prev) {
    b.m_prev.m_next = b.m_next
  }
  if(b.m_next) {
    b.m_next.m_prev = b.m_prev
  }
  if(b == this.m_bodyList) {
    this.m_bodyList = b.m_next
  }
  --this.m_bodyCount
};
b2World.prototype.CreateJoint = function(def) {
  var j = b2Joint.Create(def, null);
  j.m_prev = null;
  j.m_next = this.m_jointList;
  if(this.m_jointList) {
    this.m_jointList.m_prev = j
  }
  this.m_jointList = j;
  ++this.m_jointCount;
  j.m_edgeA.joint = j;
  j.m_edgeA.other = j.m_bodyB;
  j.m_edgeA.prev = null;
  j.m_edgeA.next = j.m_bodyA.m_jointList;
  if(j.m_bodyA.m_jointList) {
    j.m_bodyA.m_jointList.prev = j.m_edgeA
  }
  j.m_bodyA.m_jointList = j.m_edgeA;
  j.m_edgeB.joint = j;
  j.m_edgeB.other = j.m_bodyA;
  j.m_edgeB.prev = null;
  j.m_edgeB.next = j.m_bodyB.m_jointList;
  if(j.m_bodyB.m_jointList) {
    j.m_bodyB.m_jointList.prev = j.m_edgeB
  }
  j.m_bodyB.m_jointList = j.m_edgeB;
  var bodyA = def.bodyA;
  var bodyB = def.bodyB;
  if(def.collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
  return j
};
b2World.prototype.DestroyJoint = function(j) {
  var collideConnected = j.m_collideConnected;
  if(j.m_prev) {
    j.m_prev.m_next = j.m_next
  }
  if(j.m_next) {
    j.m_next.m_prev = j.m_prev
  }
  if(j == this.m_jointList) {
    this.m_jointList = j.m_next
  }
  var bodyA = j.m_bodyA;
  var bodyB = j.m_bodyB;
  bodyA.SetAwake(true);
  bodyB.SetAwake(true);
  if(j.m_edgeA.prev) {
    j.m_edgeA.prev.next = j.m_edgeA.next
  }
  if(j.m_edgeA.next) {
    j.m_edgeA.next.prev = j.m_edgeA.prev
  }
  if(j.m_edgeA == bodyA.m_jointList) {
    bodyA.m_jointList = j.m_edgeA.next
  }
  j.m_edgeA.prev = null;
  j.m_edgeA.next = null;
  if(j.m_edgeB.prev) {
    j.m_edgeB.prev.next = j.m_edgeB.next
  }
  if(j.m_edgeB.next) {
    j.m_edgeB.next.prev = j.m_edgeB.prev
  }
  if(j.m_edgeB == bodyB.m_jointList) {
    bodyB.m_jointList = j.m_edgeB.next
  }
  j.m_edgeB.prev = null;
  j.m_edgeB.next = null;
  b2Joint.Destroy(j, null);
  --this.m_jointCount;
  if(collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
};
b2World.prototype.AddController = function(c) {
  c.m_next = this.m_controllerList;
  c.m_prev = null;
  this.m_controllerList = c;
  c.m_world = this;
  this.m_controllerCount++;
  return c
};
b2World.prototype.RemoveController = function(c) {
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(this.m_controllerList == c) {
    this.m_controllerList = c.m_next
  }
  this.m_controllerCount--
};
b2World.prototype.CreateController = function(controller) {
  if(controller.m_world != this) {
    throw new Error("Controller can only be a member of one world");
  }
  controller.m_next = this.m_controllerList;
  controller.m_prev = null;
  if(this.m_controllerList) {
    this.m_controllerList.m_prev = controller
  }
  this.m_controllerList = controller;
  ++this.m_controllerCount;
  controller.m_world = this;
  return controller
};
b2World.prototype.DestroyController = function(controller) {
  controller.Clear();
  if(controller.m_next) {
    controller.m_next.m_prev = controller.m_prev
  }
  if(controller.m_prev) {
    controller.m_prev.m_next = controller.m_next
  }
  if(controller == this.m_controllerList) {
    this.m_controllerList = controller.m_next
  }
  --this.m_controllerCount
};
b2World.prototype.SetWarmStarting = function(flag) {
  b2World.m_warmStarting = flag
};
b2World.prototype.SetContinuousPhysics = function(flag) {
  b2World.m_continuousPhysics = flag
};
b2World.prototype.GetBodyCount = function() {
  return this.m_bodyCount
};
b2World.prototype.GetJointCount = function() {
  return this.m_jointCount
};
b2World.prototype.GetContactCount = function() {
  return this.m_contactCount
};
b2World.prototype.SetGravity = function(gravity) {
  this.m_gravity = gravity
};
b2World.prototype.GetGravity = function() {
  return this.m_gravity
};
b2World.prototype.GetGroundBody = function() {
  return this.m_groundBody
};
b2World.prototype.Step = function(dt, velocityIterations, positionIterations) {
  if(this.m_flags & b2World.e_newFixture) {
    this.m_contactManager.FindNewContacts();
    this.m_flags &= ~b2World.e_newFixture
  }
  this.m_flags |= b2World.e_locked;
  var step = b2World.s_timestep2;
  step.dt = dt;
  step.velocityIterations = velocityIterations;
  step.positionIterations = positionIterations;
  if(dt > 0) {
    step.inv_dt = 1 / dt
  }else {
    step.inv_dt = 0
  }
  step.dtRatio = this.m_inv_dt0 * dt;
  step.warmStarting = b2World.m_warmStarting;
  this.m_contactManager.Collide();
  if(step.dt > 0) {
    this.Solve(step)
  }
  if(b2World.m_continuousPhysics && step.dt > 0) {
    this.SolveTOI(step)
  }
  if(step.dt > 0) {
    this.m_inv_dt0 = step.inv_dt
  }
  this.m_flags &= ~b2World.e_locked
};
b2World.prototype.ClearForces = function() {
  for(var body = this.m_bodyList;body;body = body.m_next) {
    body.m_force.SetZero();
    body.m_torque = 0
  }
};
b2World.prototype.DrawDebugData = function() {
  if(this.m_debugDraw == null) {
    return
  }
  this.m_debugDraw.Clear();
  var flags = this.m_debugDraw.GetFlags();
  var i = 0;
  var b;
  var f;
  var s;
  var j;
  var bp;
  var invQ = new b2Vec2;
  var x1 = new b2Vec2;
  var x2 = new b2Vec2;
  var xf;
  var b1 = new b2AABB;
  var b2 = new b2AABB;
  var vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
  var color = new b2Color(0, 0, 0);
  if(flags & b2DebugDraw.e_shapeBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b.m_xf;
      for(f = b.GetFixtureList();f;f = f.m_next) {
        s = f.GetShape();
        if(b.IsActive() == false) {
          color.Set(0.5, 0.5, 0.3);
          this.DrawShape(s, xf, color)
        }else {
          if(b.GetType() == b2Body.b2_staticBody) {
            color.Set(0.5, 0.9, 0.5);
            this.DrawShape(s, xf, color)
          }else {
            if(b.GetType() == b2Body.b2_kinematicBody) {
              color.Set(0.5, 0.5, 0.9);
              this.DrawShape(s, xf, color)
            }else {
              if(b.IsAwake() == false) {
                color.Set(0.6, 0.6, 0.6);
                this.DrawShape(s, xf, color)
              }else {
                color.Set(0.9, 0.7, 0.7);
                this.DrawShape(s, xf, color)
              }
            }
          }
        }
      }
    }
  }
  if(flags & b2DebugDraw.e_jointBit) {
    for(j = this.m_jointList;j;j = j.m_next) {
      this.DrawJoint(j)
    }
  }
  if(flags & b2DebugDraw.e_controllerBit) {
    for(var c = this.m_controllerList;c;c = c.m_next) {
      c.Draw(this.m_debugDraw)
    }
  }
  if(flags & b2DebugDraw.e_pairBit) {
    color.Set(0.3, 0.9, 0.9);
    for(var contact = this.m_contactManager.m_contactList;contact;contact = contact.GetNext()) {
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      var cA = fixtureA.GetAABB().GetCenter();
      var cB = fixtureB.GetAABB().GetCenter();
      this.m_debugDraw.DrawSegment(cA, cB, color)
    }
  }
  if(flags & b2DebugDraw.e_aabbBit) {
    bp = this.m_contactManager.m_broadPhase;
    vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
    for(b = this.m_bodyList;b;b = b.GetNext()) {
      if(b.IsActive() == false) {
        continue
      }
      for(f = b.GetFixtureList();f;f = f.GetNext()) {
        var aabb = bp.GetFatAABB(f.m_proxy);
        vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
        vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
        vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
        vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
        this.m_debugDraw.DrawPolygon(vs, 4, color)
      }
    }
  }
  if(flags & b2DebugDraw.e_centerOfMassBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b2World.s_xf;
      xf.R = b.m_xf.R;
      xf.position = b.GetWorldCenter();
      this.m_debugDraw.DrawTransform(xf)
    }
  }
};
b2World.prototype.QueryAABB = function(callback, aabb) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    return callback(broadPhase.GetUserData(proxy))
  }
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryShape = function(callback, shape, transform) {
  if(transform == null) {
    transform = new b2Transform;
    transform.SetIdentity()
  }
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  shape.ComputeAABB(aabb, transform);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryPoint = function(callback, p) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(fixture.TestPoint(p)) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
  aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.RayCast = function(callback, point1, point2) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  var output = new b2RayCastOutput;
  function RayCastWrapper(input, proxy) {
    var userData = broadPhase.GetUserData(proxy);
    var fixture = userData;
    var hit = fixture.RayCast(output, input);
    if(hit) {
      var fraction = output.fraction;
      var point = new b2Vec2((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);
      return callback(fixture, point, output.normal, fraction)
    }
    return input.maxFraction
  }
  var input = new b2RayCastInput(point1, point2);
  broadPhase.RayCast(RayCastWrapper, input)
};
b2World.prototype.RayCastOne = function(point1, point2) {
  var result;
  function RayCastOneWrapper(fixture, point, normal, fraction) {
    result = fixture;
    return fraction
  }
  this.RayCast(RayCastOneWrapper, point1, point2);
  return result
};
b2World.prototype.RayCastAll = function(point1, point2) {
  var result = new Array;
  function RayCastAllWrapper(fixture, point, normal, fraction) {
    result[result.length] = fixture;
    return 1
  }
  this.RayCast(RayCastAllWrapper, point1, point2);
  return result
};
b2World.prototype.GetBodyList = function() {
  return this.m_bodyList
};
b2World.prototype.GetJointList = function() {
  return this.m_jointList
};
b2World.prototype.GetContactList = function() {
  return this.m_contactList
};
b2World.prototype.IsLocked = function() {
  return(this.m_flags & b2World.e_locked) > 0
};
b2World.prototype.s_stack = new Array;
b2World.prototype.m_flags = 0;
b2World.prototype.m_contactManager = new b2ContactManager;
b2World.prototype.m_contactSolver = new b2ContactSolver;
b2World.prototype.m_island = new b2Island;
b2World.prototype.m_bodyList = null;
b2World.prototype.m_jointList = null;
b2World.prototype.m_contactList = null;
b2World.prototype.m_bodyCount = 0;
b2World.prototype.m_contactCount = 0;
b2World.prototype.m_jointCount = 0;
b2World.prototype.m_controllerList = null;
b2World.prototype.m_controllerCount = 0;
b2World.prototype.m_gravity = null;
b2World.prototype.m_allowSleep = null;
b2World.prototype.m_groundBody = null;
b2World.prototype.m_destructionListener = null;
b2World.prototype.m_debugDraw = null;
b2World.prototype.m_inv_dt0 = null;if(typeof exports !== "undefined") {
  exports.b2BoundValues = b2BoundValues;
  exports.b2Math = b2Math;
  exports.b2DistanceOutput = b2DistanceOutput;
  exports.b2Mat33 = b2Mat33;
  exports.b2ContactPoint = b2ContactPoint;
  exports.b2PairManager = b2PairManager;
  exports.b2PositionSolverManifold = b2PositionSolverManifold;
  exports.b2OBB = b2OBB;
  exports.b2CircleContact = b2CircleContact;
  exports.b2PulleyJoint = b2PulleyJoint;
  exports.b2Pair = b2Pair;
  exports.b2TimeStep = b2TimeStep;
  exports.b2FixtureDef = b2FixtureDef;
  exports.b2World = b2World;
  exports.b2PrismaticJoint = b2PrismaticJoint;
  exports.b2Controller = b2Controller;
  exports.b2ContactID = b2ContactID;
  exports.b2RevoluteJoint = b2RevoluteJoint;
  exports.b2JointDef = b2JointDef;
  exports.b2Transform = b2Transform;
  exports.b2GravityController = b2GravityController;
  exports.b2EdgeAndCircleContact = b2EdgeAndCircleContact;
  exports.b2EdgeShape = b2EdgeShape;
  exports.b2BuoyancyController = b2BuoyancyController;
  exports.b2LineJointDef = b2LineJointDef;
  exports.b2Contact = b2Contact;
  exports.b2DistanceJoint = b2DistanceJoint;
  exports.b2Body = b2Body;
  exports.b2DestructionListener = b2DestructionListener;
  exports.b2PulleyJointDef = b2PulleyJointDef;
  exports.b2ContactEdge = b2ContactEdge;
  exports.b2ContactConstraint = b2ContactConstraint;
  exports.b2ContactImpulse = b2ContactImpulse;
  exports.b2DistanceJointDef = b2DistanceJointDef;
  exports.b2ContactResult = b2ContactResult;
  exports.b2EdgeChainDef = b2EdgeChainDef;
  exports.b2Vec2 = b2Vec2;
  exports.b2Vec3 = b2Vec3;
  exports.b2DistanceProxy = b2DistanceProxy;
  exports.b2FrictionJointDef = b2FrictionJointDef;
  exports.b2PolygonContact = b2PolygonContact;
  exports.b2TensorDampingController = b2TensorDampingController;
  exports.b2ContactFactory = b2ContactFactory;
  exports.b2WeldJointDef = b2WeldJointDef;
  exports.b2ConstantAccelController = b2ConstantAccelController;
  exports.b2GearJointDef = b2GearJointDef;
  exports.ClipVertex = ClipVertex;
  exports.b2SeparationFunction = b2SeparationFunction;
  exports.b2ManifoldPoint = b2ManifoldPoint;
  exports.b2Color = b2Color;
  exports.b2PolygonShape = b2PolygonShape;
  exports.b2DynamicTreePair = b2DynamicTreePair;
  exports.b2ContactConstraintPoint = b2ContactConstraintPoint;
  exports.b2FrictionJoint = b2FrictionJoint;
  exports.b2ContactFilter = b2ContactFilter;
  exports.b2ControllerEdge = b2ControllerEdge;
  exports.b2Distance = b2Distance;
  exports.b2Fixture = b2Fixture;
  exports.b2DynamicTreeNode = b2DynamicTreeNode;
  exports.b2MouseJoint = b2MouseJoint;
  exports.b2DistanceInput = b2DistanceInput;
  exports.b2BodyDef = b2BodyDef;
  exports.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;
  exports.b2Settings = b2Settings;
  exports.b2Proxy = b2Proxy;
  exports.b2Point = b2Point;
  exports.b2BroadPhase = b2BroadPhase;
  exports.b2Manifold = b2Manifold;
  exports.b2WorldManifold = b2WorldManifold;
  exports.b2PrismaticJointDef = b2PrismaticJointDef;
  exports.b2RayCastOutput = b2RayCastOutput;
  exports.b2ConstantForceController = b2ConstantForceController;
  exports.b2TimeOfImpact = b2TimeOfImpact;
  exports.b2CircleShape = b2CircleShape;
  exports.b2MassData = b2MassData;
  exports.b2Joint = b2Joint;
  exports.b2GearJoint = b2GearJoint;
  exports.b2DynamicTree = b2DynamicTree;
  exports.b2JointEdge = b2JointEdge;
  exports.b2LineJoint = b2LineJoint;
  exports.b2NullContact = b2NullContact;
  exports.b2ContactListener = b2ContactListener;
  exports.b2RayCastInput = b2RayCastInput;
  exports.b2TOIInput = b2TOIInput;
  exports.Features = Features;
  exports.b2FilterData = b2FilterData;
  exports.b2Island = b2Island;
  exports.b2ContactManager = b2ContactManager;
  exports.b2ContactSolver = b2ContactSolver;
  exports.b2Simplex = b2Simplex;
  exports.b2AABB = b2AABB;
  exports.b2Jacobian = b2Jacobian;
  exports.b2Bound = b2Bound;
  exports.b2RevoluteJointDef = b2RevoluteJointDef;
  exports.b2PolyAndEdgeContact = b2PolyAndEdgeContact;
  exports.b2SimplexVertex = b2SimplexVertex;
  exports.b2WeldJoint = b2WeldJoint;
  exports.b2Collision = b2Collision;
  exports.b2Mat22 = b2Mat22;
  exports.b2SimplexCache = b2SimplexCache;
  exports.b2PolyAndCircleContact = b2PolyAndCircleContact;
  exports.b2MouseJointDef = b2MouseJointDef;
  exports.b2Shape = b2Shape;
  exports.b2Segment = b2Segment;
  exports.b2ContactRegister = b2ContactRegister;
  exports.b2DebugDraw = b2DebugDraw;
  exports.b2Sweep = b2Sweep
}
;

}};
__resources__["/__builtin__/libs/cocos2d/ActionManager.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Timer = require('./Scheduler').Timer,
    Scheduler = require('./Scheduler').Scheduler;

var ActionManager = BObject.extend(/** @lends cocos.ActionManager# */{
    targets: null,
    currentTarget: null,
    currentTargetSalvaged: null,

    /**
     * <p>A singleton that manages all the actions. Normally you
     * won't need to use this singleton directly. 99% of the cases you will use the
     * cocos.nodes.Node interface, which uses this singleton. But there are some cases where
     * you might need to use this singleton. Examples:</p>
     *
     * <ul>
     * <li>When you want to run an action where the target is different from a cocos.nodes.Node</li>
     * <li>When you want to pause / resume the actions</li>
     * </ul>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        ActionManager.superclass.init.call(this);

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: 0, paused: false});
        this.targets = [];
    },

    /**
     * Adds an action with a target. If the target is already present, then the
     * action will be added to the existing target. If the target is not
     * present, a new instance of this target will be created either paused or
     * paused, and the action will be added to the newly created target. When
     * the target is paused, the queued actions won't be 'ticked'.
     *
     * @opt {cocos.nodes.Node} target Node to run the action on
     */
    addAction: function (opts) {

        var targetID = opts.target.get('id');
        var element = this.targets[targetID];

        if (!element) {
            element = this.targets[targetID] = {
                paused: false,
                target: opts.target,
                actions: []
            };
        }

        element.actions.push(opts.action);

        opts.action.startWithTarget(opts.target);
    },

    /**
     * Remove an action
     *
     * @param {cocos.actions.Action} action Action to remove
     */
    removeAction: function (action) {
        var targetID = action.originalTarget.get('id'),
            element = this.targets[targetID];

        if (!element) {
            return;
        }

        var actionIndex = element.actions.indexOf(action);

        if (actionIndex == -1) {
            return;
        }

        if (this.currentTarget == element) {
            element.currentActionSalvaged = true;
        } 
        
        element.actions[actionIndex] = null;
        element.actions.splice(actionIndex, 1); // Delete array item

        if (element.actions.length === 0) {
            if (this.currentTarget == element) {
                this.set('currentTargetSalvaged', true);
            }
        }
            
    },

    /**
     * Remove all actions for a cocos.nodes.Node
     *
     * @param {cocos.nodes.Node} target Node to remove all actions for
     */
    removeAllActionsFromTarget: function (target) {
        var targetID = target.get('id');

        var element = this.targets[targetID];
        if (!element) {
            return;
        }

        // Delete everything in array but don't replace it incase something else has a reference
        element.actions.splice(0, element.actions.length - 1);
    },

    /**
     * @private
     */
    update: function (dt) {
        var self = this;
        util.each(this.targets, function (currentTarget, i) {

            if (!currentTarget) {
                return;
            }
            self.currentTarget = currentTarget;

            if (!currentTarget.paused) {
                util.each(currentTarget.actions, function (currentAction, j) {
                    if (!currentAction) {
                        return;
                    }

                    currentTarget.currentAction = currentAction;
                    currentTarget.currentActionSalvaged = false;

                    currentTarget.currentAction.step(dt);

                    if (currentTarget.currentAction.get('isDone')) {
                        currentTarget.currentAction.stop();

                        var a = currentTarget.currentAction;
                        currentTarget.currentAction = null;
                        self.removeAction(a);
                    }

                    currentTarget.currentAction = null;

                });
            }

            if (self.currentTargetSalvaged && currentTarget.actions.length === 0) {
                self.targets[i] = null;
                delete self.targets[i];
            }
        });
    },

    pauseTarget: function (target) {
    },

	resumeTarget: function (target) {
		// TODO
	}
});

util.extend(ActionManager, /** @lends cocos.ActionManager */{
    /**
     * Singleton instance of cocos.ActionManager
     * @getter sharedManager
     * @type cocos.ActionManager
     */
    get_sharedManager: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.ActionManager = ActionManager;

}};
__resources__["/__builtin__/libs/cocos2d/actions/Action.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console;

/** 
 * @memberOf cocos.actions
 * @class Base class for Actions
 * @extends BObject
 * @constructor
 */
var Action = BObject.extend(/** @lends cocos.actions.Action# */{
    /**
     * The Node the action is being performed on
     * @type cocos.nodes.Node
     */
    target: null,
    originalTarget: null,

    /**
     * Called every frame with it's delta time.
     *
     * @param {Float} dt The delta time
     */
    step: function (dt) {
        console.log('Action.step() Override me');
    },

    /**
     * Called once per frame.
     *
     * @param {Float} time How much of the animation has played. 0.0 = just started, 1.0 just finished.
     */
    update: function (time) {
        console.log('Action.update() Override me');
    },

    /**
     * Called before the action start. It will also set the target.
     *
     * @param {cocos.nodes.Node} target The Node to run the action on
     */
    startWithTarget: function (target) {
        this.target = this.originalTarget = target;
    },

    /**
     * Called after the action has finished. It will set the 'target' to nil.
     * <strong>Important</strong>: You should never call cocos.actions.Action#stop manually.
     * Instead, use cocos.nodes.Node#stopAction(action)
     */
    stop: function () {
        this.target = null;
    },

    /**
     * @getter isDone
     * @type {Boolean} 
     */
    get_isDone: function (key) {
        return true;
    },


    /**
     * Returns a copy of this Action but in reverse
     *
     * @returns {cocos.actions.Action} A new Action in reverse
     */
    reverse: function () {
    }
});

var RepeatForever = Action.extend(/** @lends cocos.actions.RepeatForever# */{
    other: null,

    /**
     * @memberOf cocos.actions
     * @class Repeats an action forever. To repeat the an action for a limited
     * number of times use the cocos.Repeat action.
     * @extends cocos.actions.Action
     * @param {cocos.actions.Action} action An action to repeat forever
     * @constructs
     */
    init: function (action) {
        RepeatForever.superclass.init(this, action);

        this.other = action;
    },

    startWithTarget: function (target) {
        RepeatForever.superclass.startWithTarget.call(this, target);

        this.other.startWithTarget(this.target);
    },

    step: function (dt) {
        this.other.step(dt);
        if (this.other.get('isDone')) {
            var diff = dt - this.other.get('duration') - this.other.get('elapsed');
            this.other.startWithTarget(this.target);

            this.other.step(diff);
        }
    },

    get_isDone: function () {
        return false;
    },

    reverse: function () {
        return RepeatForever.create(this.other.reverse());
    },

    copy: function () {
        return RepeatForever.create(this.other.copy());
    }
});

var FiniteTimeAction = Action.extend(/** @lends cocos.actions.FiniteTimeAction# */{
    /**
     * Number of seconds to run the Action for
     * @type Float
     */
    duration: 2,

    /** 
     * Repeats an action a number of times. To repeat an action forever use the
     * cocos.RepeatForever action.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     */
    init: function () {
        FiniteTimeAction.superclass.init.call(this);
    },

    /** @ignore */
    reverse: function () {
        console.log('FiniteTimeAction.reverse() Override me');
    }
});

exports.Action = Action;
exports.RepeatForever = RepeatForever;
exports.FiniteTimeAction = FiniteTimeAction;

}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInstant.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    ccp = require('geometry').ccp;

var ActionInstant = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInstant */{
    /**
     * @memberOf cocos.actions
     * @class Base class for actions that triggers instantly. They have no duration.
     * @extends cocos.actions.FiniteTimeAction
     * @constructs
     */
    init: function (opts) {
        ActionInstant.superclass.init.call(this, opts);

        this.duration = 0;
    },
    get_isDone: function () {
        return true;
    },
    step: function (dt) {
        this.update(1);
    },
    update: function (t) {
        // ignore
    },
    reverse: function () {
        return this.copy();
    }
});

var FlipX = ActionInstant.extend(/** @lends cocos.actions.FlipX# */{
    flipX: false,

    /**
     * @memberOf cocos.actions
     * @class Flips a sprite horizontally
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipX Should the sprite be flipped
     */
    init: function (opts) {
        FlipX.superclass.init.call(this, opts);

        this.flipX = opts.flipX;
    },
    startWithTarget: function (target) {
        FlipX.superclass.startWithTarget.call(this, target);

        target.set('flipX', this.flipX);
    },
    reverse: function () {
        return FlipX.create({flipX: !this.flipX});
    },
    copy: function () {
        return FlipX.create({flipX: this.flipX});
    }
});

var FlipY = ActionInstant.extend(/** @lends cocos.actions.FlipY# */{
    flipY: false,

    /**
     * @memberOf cocos.actions
     * @class Flips a sprite vertically
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipY Should the sprite be flipped
     */
    init: function (opts) {
        FlipY.superclass.init.call(this, opts);

        this.flipY = opts.flipY;
    },
    startWithTarget: function (target) {
        FlipY.superclass.startWithTarget.call(this, target);

        target.set('flipY', this.flipY);
    },
    reverse: function () {
        return FlipY.create({flipY: !this.flipY});
    },
    copy: function () {
        return FlipY.create({flipY: this.flipY});
    }
});

exports.ActionInstant = ActionInstant;
exports.FlipX = FlipX;
exports.FlipY = FlipY;

}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInterval.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    ccp = require('geometry').ccp;

var ActionInterval = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInterval# */{
    /**
     * Number of seconds that have elapsed
     * @type Float
     */
    elapsed: 0.0,

    _firstTick: true,

    /**
     * Base class actions that do have a finite time duration. 
     *
     * Possible actions:
     *
     * - An action with a duration of 0 seconds
     * - An action with a duration of 35.5 seconds Infinite time actions are valid
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.FiniteTimeAction
     *
     * @opt {Float} duration Number of seconds to run action for
     */
    init: function (opts) {
        ActionInterval.superclass.init.call(this, opts);

        var dur = opts.duration || 0;
        if (dur === 0) {
            dur = 0.0000001;
        }

        this.set('duration', dur);
        this.set('elapsed', 0);
        this._firstTick = true;
    },

    get_isDone: function () {
        return (this.elapsed >= this.duration);
    },

    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        this.update(Math.min(1, this.elapsed / this.duration));
    },

    startWithTarget: function (target) {
        ActionInterval.superclass.startWithTarget.call(this, target);

        this.elapsed = 0.0;
        this._firstTick = true;
    },

    reverse: function () {
        throw "Reverse Action not implemented";
    }
});

var ScaleTo = ActionInterval.extend(/** @lends cocos.actions.ScaleTo# */{
    /**
     * Current X Scale
     * @type Float
     */
    scaleX: 1,

    /**
     * Current Y Scale
     * @type Float
     */
    scaleY: 1,

    /**
     * Initial X Scale
     * @type Float
     */
    startScaleX: 1,

    /**
     * Initial Y Scale
     * @type Float
     */
    startScaleY: 1,

    /**
     * Final X Scale
     * @type Float
     */
    endScaleX: 1,

    /**
     * Final Y Scale
     * @type Float
     */
    endScaleY: 1,

    /**
     * Delta X Scale
     * @type Float
     * @private
     */
    deltaX: 0.0,

    /**
     * Delta Y Scale
     * @type Float
     * @private
     */
    deltaY: 0.0,

    /**
     * Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node to
     * @opt {Float} [scaleX] Size to scale width of Node to
     * @opt {Float} [scaleY] Size to scale height of Node to
     */
    init: function (opts) {
        ScaleTo.superclass.init.call(this, opts);

        if (opts.scale !== undefined) {
            this.endScaleX = this.endScaleY = opts.scale;
        } else {
            this.endScaleX = opts.scaleX;
            this.endScaleY = opts.scaleY;
        }


    },

    startWithTarget: function (target) {
        ScaleTo.superclass.startWithTarget.call(this, target);

        this.startScaleX = this.target.get('scaleX');
        this.startScaleY = this.target.get('scaleY');
        this.deltaX = this.endScaleX - this.startScaleX;
        this.deltaY = this.endScaleY - this.startScaleY;
    },

    update: function (t) {
        if (!this.target) {
            return;
        }
        
        this.target.set('scaleX', this.startScaleX + this.deltaX * t);
        this.target.set('scaleY', this.startScaleY + this.deltaY * t);
    }
});

var ScaleBy = ScaleTo.extend(/** @lends cocos.actions.ScaleBy# */{
    /**
     * Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ScaleTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node by
     * @opt {Float} [scaleX] Size to scale width of Node by
     * @opt {Float} [scaleY] Size to scale height of Node by
     */
    init: function (opts) {
        ScaleBy.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        ScaleBy.superclass.startWithTarget.call(this, target);

        this.deltaX = this.startScaleX * this.endScaleX - this.startScaleX;
        this.deltaY = this.startScaleY * this.endScaleY - this.startScaleY;
    },

    reverse: function () {
        return ScaleBy.create({duration: this.duration, scaleX: 1 / this.endScaleX, scaleY: 1 / this.endScaleY});
    }
});


var RotateTo = ActionInterval.extend(/** @lends cocos.actions.RotateTo# */{
    /**
     * Final angle
     * @type Float
     */
    dstAngle: 0,

    /**
     * Initial angle
     * @type Float
     */
    startAngle: 0,

    /**
     * Angle delta
     * @type Float
     */
    diffAngle: 0,

    /**
     * Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     * 
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate to
     */
    init: function (opts) {
        RotateTo.superclass.init.call(this, opts);

        this.dstAngle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateTo.superclass.startWithTarget.call(this, target);

        this.startAngle = target.get('rotation');

        if (this.startAngle > 0) {
            this.startAngle = (this.startAngle % 360);
        } else {
            this.startAngle = (this.startAngle % -360);
        }

        this.diffAngle = this.dstAngle - this.startAngle;
        if (this.diffAngle > 180) {
            this.diffAngle -= 360;
        } else if (this.diffAngle < -180) {
            this.diffAngle += 360;
        }
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.diffAngle * t);
    }
});

var RotateBy = RotateTo.extend(/** @lends cocos.actions.RotateBy# */{
    /**
     * Number of degrees to rotate by
     * @type Float
     */
    angle: 0,

    /**
     * Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     *
     * @memberOf cocos.action
     * @constructs
     * @extends cocos.actions.RotateTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate by
     */
    init: function (opts) {
        RotateBy.superclass.init.call(this, opts);

        this.angle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateBy.superclass.startWithTarget.call(this, target);

        this.startAngle = this.target.get('rotation');
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.angle * t);
    },

    reverse: function () {
        return RotateBy.create({duration: this.duration, angle: -this.angle});
    },

    copy: function () {
        return RotateBy.create({duration: this.duration, angle: this.angle});
    }
});



var Sequence = ActionInterval.extend(/** @lends cocos.actions.Sequence# */{
    /**
     * Array of actions to run
     * @type cocos.Node[]
     */
    actions: null,

    /**
     * The array index of the currently running action
     * @type Integer
     */
    currentActionIndex: 0,

    /**
     * The duration when the current action finishes
     * @type Float
     */
    currentActionEndDuration: 0,

    /**
     * Runs a number of actions sequentially, one after another
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {cocos.actions.Action[]} Array of actions to run in sequence
     */
    init: function (opts) {
        Sequence.superclass.init.call(this, opts);

        this.actions = util.copy(opts.actions);
        this.actionSequence = {};
        
        util.each(this.actions, util.callback(this, function (action) {
            this.duration += action.duration;
        }));
    },

    startWithTarget: function (target) {
        Sequence.superclass.startWithTarget.call(this, target);

        this.currentActionIndex = 0;
        this.currentActionEndDuration = this.actions[0].get('duration');
        this.actions[0].startWithTarget(this.target);
    },

    stop: function () {
        util.each(this.actions, function (action) {
            action.stop();
        });

        Sequence.superclass.stop.call(this);
    },

    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        this.actions[this.currentActionIndex].step(dt);
        this.update(Math.min(1, this.elapsed / this.duration));
    },

    update: function (dt) {
        // Action finished onto the next one
        if (this.elapsed > this.currentActionEndDuration) {
            var previousAction = this.actions[this.currentActionIndex];
            previousAction.update(1.0);
            previousAction.stop();


            this.currentActionIndex++;

            if (this.currentActionIndex < this.actions.length) {
                var currentAction = this.actions[this.currentActionIndex];
                currentAction.startWithTarget(this.target);

                this.currentActionEndDuration += currentAction.duration;
            }
        }
    }
});

var Animate = ActionInterval.extend(/** @lends cocos.actions.Animate# */{
    animation: null,
    restoreOriginalFrame: true,
    origFrame: null,


    /**
     * Animates a sprite given the name of an Animation 
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {cocos.Animation} animation Animation to run
     * @opt {Boolean} [restoreOriginalFrame=true] Return to first frame when finished
     */
    init: function (opts) {
        this.animation = opts.animation;
        this.restoreOriginalFrame = opts.restoreOriginalFrame !== false;
        opts.duration = this.animation.frames.length * this.animation.delay;

        Animate.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        Animate.superclass.startWithTarget.call(this, target);

        if (this.restoreOriginalFrame) {
            this.set('origFrame', this.target.get('displayedFrame'));
        }
    },

    stop: function () {
        if (this.target && this.restoreOriginalFrame) {
            var sprite = this.target;
            sprite.set('displayFrame', this.origFrame);
        }

        Animate.superclass.stop.call(this);
    },

    update: function (t) {
        var frames = this.animation.get('frames'),
            numberOfFrames = frames.length,
            idx = Math.floor(t * numberOfFrames);

        if (idx >= numberOfFrames) {
            idx = numberOfFrames - 1;
        }

        var sprite = this.target;
        if (!sprite.isFrameDisplayed(frames[idx])) {
            sprite.set('displayFrame', frames[idx]);
        }
    },

    copy: function () {
        return Animate.create({animation: this.animation, restoreOriginalFrame: this.restoreOriginalFrame});
    }

});

exports.ActionInterval = ActionInterval;
exports.ScaleTo = ScaleTo;
exports.ScaleBy = ScaleBy;
exports.RotateTo = RotateTo;
exports.RotateBy = RotateBy;
exports.Sequence = Sequence;
exports.Animate = Animate;

}};
__resources__["/__builtin__/libs/cocos2d/actions/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'Action ActionInterval ActionInstant'.w();

/**
 * @memberOf cocos
 * @namespace Actions used to animate or change a Node
 */
var actions = {};

util.each(modules, function (mod, i) {
    util.extend(actions, require('./' + mod));
});

module.exports = actions;

}};
__resources__["/__builtin__/libs/cocos2d/Animation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var Animation = BObject.extend(/** @lends cocos.Animation# */{
    name: null,
    delay: 0.0,
    frames: null,

    /** 
     * A cocos.Animation object is used to perform animations on the Sprite objects.
     * 
     * The Animation object contains cocos.SpriteFrame objects, and a possible delay between the frames.
     * You can animate a cocos.Animation object by using the cocos.actions.Animate action.
     * 
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.SpriteFrame[]} frames Frames to animate
     * @opt {Float} [delay=0.0] Delay between each frame
     * 
     * @example
     * var animation = cocos.Animation.create({frames: [f1, f2, f3], delay: 0.1});
     * sprite.runAction(cocos.actions.Animate.create({animation: animation}));
     */
    init: function (opts) {
        Animation.superclass.init.call(this, opts);

        this.frames = opts.frames || [];
        this.delay  = opts.delay  || 0.0;
    }
});

exports.Animation = Animation;

}};
__resources__["/__builtin__/libs/cocos2d/AnimationCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Plist = require('Plist').Plist;

var AnimationCache = BObject.extend(/** @lends cocos.AnimationCache# */{
    /**
     * Cached animations
     * @type Object
     */
    animations: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        AnimationCache.superclass.init.call(this);

        this.set('animations', {});
    },

    /**
     * Add an animation to the cache
     *
     * @opt {String} name Unique name of the animation
     * @opt {cocos.Animcation} animation Animation to cache
     */
    addAnimation: function (opts) {
        var name = opts.name,
            animation = opts.animation;

        this.get('animations')[name] = animation;
    },

    /**
     * Remove an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     */
    removeAnimation: function (opts) {
        var name = opts.name;

        delete this.get('animations')[name];
    },

    /**
     * Get an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     * @returns {cocos.Animation} Cached animation
     */
    getAnimation: function (opts) {
        var name = opts.name;

        return this.get('animations')[name];
    }
});

/**
 * Class methods
 */
util.extend(AnimationCache, /** @lends cocos.AnimationCache */{
    /**
     * @getter sharedAnimationCache
     * @type cocos.AnimationCache
     */
    get_sharedAnimationCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.AnimationCache = AnimationCache;

}};
__resources__["/__builtin__/libs/cocos2d/Director.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    Scheduler = require('./Scheduler').Scheduler,
    EventDispatcher = require('./EventDispatcher').EventDispatcher,
    Scene = require('./nodes/Scene').Scene;

var Director = BObject.extend(/** @lends cocos.Director# */{
    backgroundColor: 'rgb(0, 0, 0)',
    canvas: null,
    context: null,
    sceneStack: null,
    winSize: null,
    isPaused: false,
    maxFrameRate: 30,
    displayFPS: false,

    // Time delta
    dt: 0,
    nextDeltaTimeZero: false,
    lastUpdate: 0,

    _nextScene: null,

    /**
     * <p>Creates and handles the main view and manages how and when to execute the
     * Scenes.</p>
     *
     * <p>This class is a singleton so don't instantiate it yourself, instead use
     * cocos.Director.get('sharedDirector') to return the instance.</p>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        Director.superclass.init.call(this);

        this.set('sceneStack', []);
    },

    /**
     * Append to a HTML element. It will create a canvas tag
     *
     * @param {HTMLElement} view Any HTML element to add the application to
     */
    attachInView: function (view) {
        if (!view.tagName) {
            throw "Director.attachInView must be given a HTML DOM Node";
        }

        while (view.firstChild) {
            view.removeChild(view.firstChild);
        }

        var canvas = document.createElement('canvas');
        this.set('canvas', canvas);
        canvas.setAttribute('width', view.clientWidth);
        canvas.setAttribute('height', view.clientHeight);

        var context = canvas.getContext('2d');
        this.set('context', context);

        if (FLIP_Y_AXIS) {
            context.translate(0, view.clientHeight);
            context.scale(1, -1);
        }

        view.appendChild(canvas);

        this.set('winSize', {width: view.clientWidth, height: view.clientHeight});


        // Setup event handling

        // Mouse events
        var eventDispatcher = EventDispatcher.get('sharedDispatcher');
        var self = this;
        function mouseDown(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            function mouseDragged(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                eventDispatcher.mouseDragged(evt);
            }
            function mouseUp(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                document.body.removeEventListener('mousemove', mouseDragged, false);
                document.body.removeEventListener('mouseup',   mouseUp,   false);


                eventDispatcher.mouseUp(evt);
            }

            document.body.addEventListener('mousemove', mouseDragged, false);
            document.body.addEventListener('mouseup',   mouseUp,   false);

            eventDispatcher.mouseDown(evt);
        }
        function mouseMoved(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            eventDispatcher.mouseMoved(evt);
        }
        canvas.addEventListener('mousedown', mouseDown, false);
        canvas.addEventListener('mousemove', mouseMoved, false);

        // Keyboard events
        function keyDown(evt) {
            this._keysDown = this._keysDown || {};
            eventDispatcher.keyDown(evt);
        }
        function keyUp(evt) {
            eventDispatcher.keyUp(evt);
        }
        /*
        function keyPress(evt) {
            eventDispatcher.keyPress(evt)
        }
        */
        document.documentElement.addEventListener('keydown', keyDown, false);
        document.documentElement.addEventListener('keyup', keyUp, false);
        /*
        document.documentElement.addEventListener('keypress', keyPress, false);
        */
    },

    /**
     * Enters the Director's main loop with the given Scene. Call it to run
     * only your FIRST scene. Don't call it if there is already a running
     * scene.
     *
     * @param {cocos.Scene} scene The scene to start
     */
    runWithScene: function (scene) {
        if (!(scene instanceof Scene)) {
            throw "Director.runWithScene must be given an instance of Scene";
        }

        if (this._runningScene) {
            throw "You can't run an scene if another Scene is running. Use replaceScene or pushScene instead";
        }

        this.pushScene(scene);
        this.startAnimation();
    },

    /**
     * Replaces the running scene with a new one. The running scene is
     * terminated. ONLY call it if there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to replace with
     */
    replaceScene: function (scene) {
        var index = this.sceneStack.length;

        this._sendCleanupToScene = true;
        this.sceneStack.pop();
        this.sceneStack.push(scene);
        this._nextScene = scene;
    },

    /**
     * Pops out a scene from the queue. This scene will replace the running
     * one. The running scene will be deleted. If there are no more scenes in
     * the stack the execution is terminated. ONLY call it if there is a
     * running scene.
     */
    popScene: function () {
    },

    /**
     * Suspends the execution of the running scene, pushing it on the stack of
     * suspended scenes. The new scene will be executed. Try to avoid big
     * stacks of pushed scenes to reduce memory allocation. ONLY call it if
     * there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to add to the stack
     */
    pushScene: function (scene) {
        this._nextScene = scene;
    },

    /**
     * The main loop is triggered again. Call this function only if
     * cocos.Directory#stopAnimation was called earlier.
     */
    startAnimation: function () {
        var animationInterval = 1.0 / this.get('maxFrameRate');
        this._animationTimer = setInterval(util.callback(this, 'drawScene'), animationInterval * 1000);
    },

    /**
     * Stops the animation. Nothing will be drawn. The main loop won't be
     * triggered anymore. If you want to pause your animation call
     * cocos.Directory#pause instead.
     */
    stopAnimation: function () {
    },

    /**
     * Calculate time since last call
     * @private
     */
    calculateDeltaTime: function () {
        var now = (new Date()).getTime() / 1000;

        if (this.nextDeltaTimeZero) {
            this.dt = 0;
            this.nextDeltaTimeZero = false;
        }

        this.dt = Math.max(0, now - this.lastUpdate);

        this.lastUpdate = now;
    },

    /**
     * The main run loop
     * @private
     */
    drawScene: function () {
        this.calculateDeltaTime();

        if (!this.isPaused) {
            Scheduler.get('sharedScheduler').tick(this.dt);
        }


        var context = this.get('context');
        context.fillStyle = this.get('backgroundColor');
        context.fillRect(0, 0, this.winSize.width, this.winSize.height);
        //this.canvas.width = this.canvas.width


        if (this._nextScene) {
            this.setNextScene();
        }

        var rect = new geo.Rect(0, 0, this.winSize.width, this.winSize.height);

        if (rect) {
            context.beginPath();
            context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
            context.clip();
            context.closePath();
        }

        this._runningScene.visit(context, rect);

        if (SHOW_REDRAW_REGIONS) {
            if (rect) {
                context.beginPath();
                context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                context.fillStyle = "rgba(255, 0, 0, 0.5)";
                //context.fill();
                context.closePath();
            }
        }

        if (this.get('displayFPS')) {
            this.showFPS();
        }
    },

    /**
     * Initialises the next scene
     * @private
     */
    setNextScene: function () {
        // TODO transitions

        if (this._runningScene) {
            this._runningScene.onExit();
            if (this._sendCleanupToScene) {
                this._runningScene.cleanup();
            }
        }

        this._runningScene = this._nextScene;

        this._nextScene = null;

        this._runningScene.onEnter();
    },

    convertEventToCanvas: function (evt) {
        var x = this.canvas.offsetLeft - document.documentElement.scrollLeft,
            y = this.canvas.offsetTop - document.documentElement.scrollTop;

        var o = this.canvas;
        while ((o = o.offsetParent)) {
            x += o.offsetLeft - o.scrollLeft;
            y += o.offsetTop - o.scrollTop;
        }

        var p = geo.ccpSub(evt.locationInWindow, ccp(x, y));
        if (FLIP_Y_AXIS) {
            p.y = this.canvas.height - p.y;
        }

        return p;
    },

    showFPS: function () {
        if (!this._fpsLabel) {
            var Label = require('./nodes/Label').Label;
            this._fpsLabel = Label.create({string: '', fontSize: 16});
            this._fpsLabel.set('anchorPoint', ccp(0, 1));
            this._frames = 0;
            this._accumDt = 0;
        }


        this._frames++;
        this._accumDt += this.get('dt');
        
        if (this._accumDt > 1.0 / 3.0)  {
            var frameRate = this._frames / this._accumDt;
            this._frames = 0;
            this._accumDt = 0;

            this._fpsLabel.set('string', 'FPS: ' + (Math.round(frameRate * 100) / 100).toString());
        }
		

        var s = this.get('winSize');
        this._fpsLabel.set('position', ccp(10, s.height - 10));

        this._fpsLabel.visit(this.get('context'));
    }

});

/**
 * Class methods
 */
util.extend(Director, /** @lends cocos.Director */{
    /**
     * A shared singleton instance of cocos.Director
     *
     * @getter sharedDirector
     * @type cocos.Director
     */
    get_sharedDirector: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.Director = Director;

}};
__resources__["/__builtin__/libs/cocos2d/EventDispatcher.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry');

var EventDispatcher = BObject.extend(/** @lends cocos.EventDispatcher# */{
    dispatchEvents: true,
    keyboardDelegates: null,
    mouseDelegates: null,
    _keysDown: null,
    
    /**
     * This singleton is responsible for dispatching Mouse and Keyboard events.
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        EventDispatcher.superclass.init.call(this);

        this.keyboardDelegates = [];
        this.mouseDelegates = [];

        this._keysDown = {};
    },

    addDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority,
            flags    = opts.flags,
            list     = opts.list;

        var listElement = {
            delegate: delegate,
            priority: priority,
            flags: flags
        };

        var added = false;
        for (var i = 0; i < list.length; i++) {
            var elem = list[i];
            if (priority < elem.priority) {
                // Priority is lower, so insert before elem
                list.splice(i, 0, listElement);
                added = true;
                break;
            }
        }

        // High priority; append to array
        if (!added) {
            list.push(listElement);
        }
    },

    removeDelegate: function (opts) {
        var delegate = opts.delegate,
            list = opts.list;

        var idx = -1,
            i;
        for (i = 0; i < list.length; i++) {
            var l = list[i];
            if (l.delegate == delegate) {
                idx = i;
                break;
            }
        }
        if (idx == -1) {
            return;
        }
        list.splice(idx, 1);
    },
    removeAllDelegates: function (opts) {
        var list = opts.list;

        list.splice(0, list.length - 1);
    },

    addMouseDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.mouseDelegates});
    },

    removeMouseDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.mouseDelegates});
    },

    removeAllMouseDelegate: function () {
        this.removeAllDelegates({list: this.mouseDelegates});
    },

    addKeyboardDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.keyboardDelegates});
    },

    removeKeyboardDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.keyboardDelegates});
    },

    removeAllKeyboardDelegate: function () {
        this.removeAllDelegates({list: this.keyboardDelegates});
    },



    // Mouse Events

    mouseDown: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDown) {
                var swallows = entry.delegate.mouseDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseMoved: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseMovePosition) {
            evt.deltaX = evt.clientX - this._previousMouseMovePosition.x;
            evt.deltaY = evt.clientY - this._previousMouseMovePosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseMoved) {
                var swallows = entry.delegate.mouseMoved(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseDragged: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseDragPosition) {
            evt.deltaX = evt.clientX - this._previousMouseDragPosition.x;
            evt.deltaY = evt.clientY - this._previousMouseDragPosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDragged) {
                var swallows = entry.delegate.mouseDragged(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseUp) {
                var swallows = entry.delegate.mouseUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    // Keyboard events
    keyDown: function (evt) {
        var kc = evt.keyCode;
        if (!this.dispatchEvents || this._keysDown[kc]) {
            return;
        }

        this._keysDown[kc] = true;

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyDown) {
                var swallows = entry.delegate.keyDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    keyUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        var kc = evt.keyCode;
        if (this._keysDown[kc]) {
            delete this._keysDown[kc];
        }

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyUp) {
                var swallows = entry.delegate.keyUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    }

});

/**
 * Class methods
 */
util.extend(EventDispatcher, /** @lends cocos.EventDispatcher */{
    /**
     * A shared singleton instance of cocos.EventDispatcher
     *
     * @getter sharedDispatcher
     * @type cocos.EventDispatcher
     */
    get_sharedDispatcher: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});
exports.EventDispatcher = EventDispatcher;

}};
__resources__["/__builtin__/libs/cocos2d/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'SpriteFrame SpriteFrameCache Director Animation AnimationCache Scheduler ActionManager TMXXMLParser'.w();

/**
 * @namespace All cocos2d objects live in this namespace
 */
var cocos = {
    nodes: require('./nodes'),
    actions: require('./actions')
};

util.each(modules, function (mod, i) {
    util.extend(cocos, require('./' + mod));
});

module.exports = cocos;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/BatchNode.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event'),
    geo = require('geometry'),
    ccp = geo.ccp,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    RenderTexture = require('./RenderTexture').RenderTexture,
	Node = require('./Node').Node;

var BatchNode = Node.extend(/** @lends cocos.nodes.BatchNode# */{
    partialDraw: false,
    contentRect: null,
    renderTexture: null,
    dirty: true,

    /**
     * Region to redraw
     * @type geometry.Rect
     */
    dirtyRegion: null,
    dynamicResize: false,

    /** @private
     * Areas that need redrawing
     *
     * Not implemented
     */
    _dirtyRects: null,


    /**
     * Draws all children to an in-memory canvas and only redraws when something changes
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {geometry.Size} size The size of the in-memory canvas used for drawing to
     * @opt {Boolean} [partialDraw=false] Draw only the area visible on screen. Small maps may be slower in some browsers if this is true.
     */
	init: function (opts) {
		BatchNode.superclass.init.call(this, opts);

        var size = opts.size || geo.sizeMake(1, 1);
        this.set('partialDraw', opts.partialDraw);

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));
        
		this._dirtyRects = [];
        this.set('contentRect', geo.rectMake(0, 0, size.width, size.height));
        this.renderTexture = RenderTexture.create(size);
        this.renderTexture.sprite.set('isRelativeAnchorPoint', false);
        this.addChild({child: this.renderTexture});
	},

    addChild: function (opts) {
        BatchNode.superclass.addChild.call(this, opts);

        var child = opts.child,
            z     = opts.z;

        if (child == this.renderTexture) {
            return;
        }

        // TODO handle texture resize

        // Watch for changes in child
        evt.addListener(child, 'istransformdirty_changed', util.callback(this, function () {
            this.addDirtyRegion(child.get('boundingBox'));
        }));
        evt.addListener(child, 'visible_changed', util.callback(this, function () {
            this.addDirtyRegion(child.get('boundingBox'));
        }));

        this.addDirtyRegion(child.get('boundingBox'));
    },

    removeChild: function (opts) {
        BatchNode.superclass.removeChild.call(this, opts);

        // TODO remove istransformdirty_changed and visible_changed listeners

        this.set('dirty', true);
    },

    addDirtyRegion: function (rect) {
        var region = this.get('dirtyRegion');
        if (!region) {
            region = util.copy(rect);
        } else {
            region = geo.rectUnion(region, rect);
        }

        this.set('dirtyRegion', region);
        this.set('dirty', true);
    },

    _resizeCanvas: function (oldSize) {
        var size = this.get('contentSize');

        if (geo.sizeEqualToSize(size, oldSize)) {
            return; // No change
        }


        this.renderTexture.set('contentSize', size);
        this.set('dirty', true);
    },

    update: function () {

    },

    visit: function (context) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        var rect = this.get('dirtyRegion');
        // Only redraw if something changed
        if (this.dirty) {

            if (rect) {
                if (this.get('partialDraw')) {
                    // Clip region to visible area
                    var s = require('../Director').Director.get('sharedDirector').get('winSize'),
                        p = this.get('position');
                    var r = new geo.Rect(
                        0, 0,
                        s.width, s.height
                    );
                    r = geo.rectApplyAffineTransform(r, this.worldToNodeTransform());
                    rect = geo.rectIntersection(r, rect);
                }

                this.renderTexture.clear(rect);

                this.renderTexture.context.save();
                this.renderTexture.context.beginPath();
                this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                this.renderTexture.context.clip();
                this.renderTexture.context.closePath();
            } else {
                this.renderTexture.clear();
            }

            for (var i = 0, childLen = this.children.length; i < childLen; i++) {
                var c = this.children[i];
                if (c == this.renderTexture) {
                    continue;
                }

                // Draw children inside rect
                if (!rect || geo.rectOverlapsRect(c.get('boundingBox'), rect)) {
                    c.visit(this.renderTexture.context, rect);
                }
            }

            if (SHOW_REDRAW_REGIONS) {
                if (rect) {
                    this.renderTexture.context.beginPath();
                    this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                    this.renderTexture.context.fillStyle = "rgba(0, 0, 255, 0.5)";
                    this.renderTexture.context.fill();
                    this.renderTexture.context.closePath();
                }
            }

            if (rect) {
                this.renderTexture.context.restore();
            }

            this.set('dirty', false);
            this.set('dirtyRegion', null);
        }

        this.renderTexture.visit(context);

        context.restore();
	},

	draw: function (ctx) {
    },

    onEnter: function () {
        if (this.get('partialDraw')) {
            evt.addListener(this.get('parent'), 'istransformdirty_changed', util.callback(this, function () {
                var box = this.get('visibleRect');
                this.addDirtyRegion(box);
            }));
        }
    }
});

var SpriteBatchNode = BatchNode.extend(/** @lends cocos.nodes.SpriteBatchNode# */{
    textureAtlas: null,

    /**
     * @memberOf cocos.nodes
     * @class A BatchNode that accepts only Sprite using the same texture
     * @extends cocos.nodes.BatchNode
     * @constructs
     *
     * @opt {String} file (Optional) Path to image to use as sprite atlas
     * @opt {Texture2D} texture (Optional) Texture to use as sprite atlas
     * @opt {cocos.TextureAtlas} textureAtlas (Optional) TextureAtlas to use as sprite atlas
     */
    init: function (opts) {
        SpriteBatchNode.superclass.init.call(this, opts);

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture;

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        }

        this.set('textureAtlas', textureAtlas);
    },

    /**
     * @getter texture
     * @type cocos.Texture2D
     */
    get_texture: function () {
		return this.textureAtlas ? this.textureAtlas.texture : null;
	}

});

exports.BatchNode = BatchNode;
exports.SpriteBatchNode = SpriteBatchNode;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'Node Layer Scene Label Sprite TMXTiledMap BatchNode RenderTexture Menu MenuItem'.w();

/** 
 * @memberOf cocos
 * @namespace All cocos2d nodes. i.e. anything that can be added to a Scene
 */
var nodes = {};

util.each(modules, function (mod, i) {
    util.extend(nodes, require('./' + mod));
});

module.exports = nodes;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Label.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Director = require('../Director').Director,
    Node = require('./Node').Node,
    ccp = require('geometry').ccp;

var Label = Node.extend(/** @lends cocos.nodes.Label# */{
    string:   '',
    fontName: 'Helvetica',
    fontSize: 16,
    fontColor: 'white',

    /**
     * Renders a simple text label
     *
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} [string=""] The text string to draw
     * @opt {Float} [fontSize=16] The size of the font
     * @opt {String} [fontName="Helvetica"] The name of the font to use
     * @opt {String} [fontColor="white"] The color of the text
     */
    init: function (opts) {
        Label.superclass.init.call(this, opts);

        util.each('fontSize fontName fontColor string'.w(), util.callback(this, function (name) {
            // Set property on init
            if (opts[name]) {
                this.set(name, opts[name]);
            }

            // Update content size
            this._updateLabelContentSize();
        }));
    },

    /** 
     * String of the font name and size to use in a format &lt;canvas&gt; understands
     *
     * @getter font
     * @type String
     */
    get_font: function (key) {
        return this.get('fontSize') + 'px ' + this.get('fontName');
    },

    draw: function (context) {
        if (FLIP_Y_AXIS) {
            context.save();

            // Flip Y axis
            context.scale(1, -1);
            context.translate(0, -this.get('fontSize'));
        }


        context.fillStyle = this.get('fontColor');
        context.font = this.get('font');
        context.textBaseline = 'top';
        if (context.fillText) {
            context.fillText(this.get('string'), 0, 0);
        } else if (context.mozDrawText) {
            context.mozDrawText(this.get('string'));
        }

        if (FLIP_Y_AXIS) {
            context.restore();
        }
    },

    /**
     * @private
     */
    _updateLabelContentSize: function () {
        var ctx = Director.get('sharedDirector').get('context');
        var size = {width: 0, height: this.get('fontSize')};

        var prevFont = ctx.font;
        ctx.font = this.get('font');

        if (ctx.measureText) {
            var txtSize = ctx.measureText(this.get('string'));
            size.width = txtSize.width;
        } else if (ctx.mozMeasureText) {
            size.width = ctx.mozMeasureText(this.get('string'));
        }

        ctx.font = prevFont;

        this.set('contentSize', size);
    }
});

module.exports.Label = Label;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Layer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node,
    util = require('util'),
    evt = require('event'),
    Director = require('../Director').Director,
    ccp    = require('geometry').ccp,
    EventDispatcher = require('../EventDispatcher').EventDispatcher;

var Layer = Node.extend(/** @lends cocos.nodes.Layer# */{
    isMouseEnabled: false,
    isKeyboardEnabled: false,
    mouseDelegatePriority: 0,
    keyboardDelegatePriority: 0,

    /** 
     * A fullscreen Node. You need at least 1 layer in your app to add other nodes to.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Layer.superclass.init.call(this);

        var s = Director.get('sharedDirector').get('winSize');

        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = ccp(0.5, 0.5);
        this.set('contentSize', s);

        evt.addListener(this, 'ismouseenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isMouseEnabled) {
                    EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
                }
            }
        }));


        evt.addListener(this, 'iskeyboardenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isKeyboardEnabled) {
                    EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
                }
            }
        }));
    },

    onEnter: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
        }

        Layer.superclass.onEnter.call(this);
    },

    onExit: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
        }

        Layer.superclass.onExit.call(this);
    }
});

module.exports.Layer = Layer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Menu.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Layer = require('./Layer').Layer,
    Director = require('../Director').Director,
    MenuItem = require('./MenuItem').MenuItem,
    geom = require('geometry'), ccp = geom.ccp;

/** @private
 * @constant */
var kMenuStateWaiting = 0;

/** @private
 * @constant */
var kMenuStateTrackingTouch = 1;
	

var Menu = Layer.extend(/** @lends cocos.nodes.Menu# */{
	mouseDelegatePriority: (-Number.MAX_VALUE + 1),
	state: kMenuStateWaiting,
	selectedItem: null,
	opacuty: 255,
	color: null,

    /**
     * A fullscreen node used to render a selection of menu options
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Layer
     *
     * @opt {cocos.nodes.MenuItem[]} items An array of MenuItems to draw on the menu
     */
	init: function (opts) {
		Menu.superclass.init.call(this, opts);

		var items = opts.items;

		this.set('isMouseEnabled', true);
		
        var s = Director.get('sharedDirector').get('winSize');

		this.set('isRelativeAnchorPoint', false);
		this.anchorPoint = ccp(0.5, 0.5);
		this.set('contentSize', s);

		this.set('position', ccp(s.width / 2, s.height / 2));


		if (items) {
			var z = 0;
			util.each(items, util.callback(this, function (item) {
				this.addChild({child: item, z: z++});
			}));
		}

        
	},

	addChild: function (opts) {
		if (!opts.child instanceof MenuItem) {
			throw "Menu only supports MenuItem objects as children";
		}

        Menu.superclass.addChild.call(this, opts);
    },

    itemForMouseEvent: function (event) {
        var location = event.locationInCanvas;

        var children = this.get('children');
        for (var i = 0, len = children.length; i < len; i++) {
            var item = children[i];

            if (item.get('visible') && item.get('isEnabled')) {
                var local = item.convertToNodeSpace(location);
                
                var r = item.get('rect');
                r.origin = ccp(0, 0);

                if (geom.rectContainsPoint(r, local)) {
                    return item;
                }

            }
        }

        return null;
    },

    mouseUp: function (event) {
        if (this.selectedItem) {
            this.selectedItem.set('isSelected', false);
            this.selectedItem.activate();

            return true;
        }

        if (this.state != kMenuStateWaiting) {
            this.set('state', kMenuStateWaiting);
        }

        return false;

    },
    mouseDown: function (event) {
        if (this.state != kMenuStateWaiting || !this.visible) {
            return false;
        }

        var selectedItem = this.itemForMouseEvent(event);
        this.set('selectedItem', selectedItem);
        if (selectedItem) {
            selectedItem.set('isSelected', true);
            this.set('state', kMenuStateTrackingTouch);

            return true;
        }

        return false;
    },

    mouseDragged: function (event) {
        var currentItem = this.itemForMouseEvent(event);

        if (currentItem != this.selectedItem) {
            if (this.selectedItem) {
                this.selectedItem.set('isSelected', false);
            }
            this.set('selectedItem', currentItem);
            if (this.selectedItem) {
                this.selectedItem.set('isSelected', true);
            }
        }

        if (currentItem && this.state == kMenuStateTrackingTouch) {
            return true;
        }

        return false;
        
    }

});

exports.Menu = Menu;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/MenuItem.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Node = require('./Node').Node,
    Sprite = require('./Sprite').Sprite,
    rectMake = require('geometry').rectMake,
    ccp = require('geometry').ccp;

var MenuItem = Node.extend(/** @lends cocos.nodes.MenuItem# */{
	isEnabled: true,
	isSelected: false,
	callback: null,

    /**
     * Base class for any buttons or options in a menu
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Function} callback Function to call when menu item is activated
     */
	init: function (opts) {
		MenuItem.superclass.init.call(this, opts);

		var callback = opts.callback;

		this.set('anchorPoint', ccp(0.5, 0.5));
		this.set('callback', callback);
	},

	activate: function () {
		if (this.isEnabled && this.callback) {
			this.callback(this);
		}
	},

    /**
     * @getter rect
     * @type geometry.Rect
     */
	get_rect: function () {
		return rectMake(
			this.position.x - this.contentSize.width  * this.anchorPoint.x,
			this.position.y - this.contentSize.height * this.anchorPoint.y,
			this.contentSize.width,
			this.contentSize.height
		);
	}
});

var MenuItemSprite = MenuItem.extend(/** @lends cocos.nodes.MenuItemSprite# */{
	normalImage: null,
	selectedImage: null,
	disabledImage: null,

    /**
     * A menu item that accepts any cocos.nodes.Node
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItem
     *
     * @opt {cocos.nodes.Node} normalImage Main Node to draw
     * @opt {cocos.nodes.Node} selectedImage Node to draw when menu item is selected
     * @opt {cocos.nodes.Node} disabledImage Node to draw when menu item is disabled
     */
	init: function (opts) {
		MenuItemSprite.superclass.init.call(this, opts);

		var normalImage   = opts.normalImage,
			selectedImage = opts.selectedImage,
			disabledImage = opts.disabledImage;

		this.set('normalImage', normalImage);
		this.set('selectedImage', selectedImage);
		this.set('disabledImage', disabledImage);

		this.set('contentSize', normalImage.get('contentSize'));
	},

	draw: function (ctx) {
		if (this.isEnabled) {
			if (this.isSelected) {
				this.selectedImage.draw(ctx);
			} else {
				this.normalImage.draw(ctx);
			}
		} else {
			if (this.disabledImage) {
				this.disabledImage.draw(ctx);
			} else {
				this.normalImage.draw(ctx);
			}
		}
	}
});

var MenuItemImage = MenuItemSprite.extend(/** @lends cocos.nodes.MenuItemImage# */{

    /**
     * MenuItem that accepts image files
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItemSprite
     *
     * @opt {String} normalImage Main image file to draw
     * @opt {String} selectedImage Image file to draw when menu item is selected
     * @opt {String} disabledImage Image file to draw when menu item is disabled
     */
	init: function (opts) {
		var normalI   = opts.normalImage,
			selectedI = opts.selectedImage,
			disabledI = opts.disabledImage,
			callback  = opts.callback;

		var normalImage = Sprite.create({file: normalI}),
			selectedImage = Sprite.create({file: selectedI}),
			disabledImage = null;

		if (disabledI) {
			disabledImage = Sprite.create({file: disabledI});
		}

		return MenuItemImage.superclass.init.call(this, {normalImage: normalImage, selectedImage: selectedImage, disabledImage: disabledImage, callback: callback});
    }
});

exports.MenuItem = MenuItem;
exports.MenuItemImage = MenuItemImage;
exports.MenuItemSprite = MenuItemSprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Node.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event'),
    Scheduler = require('../Scheduler').Scheduler,
    ActionManager = require('../ActionManager').ActionManager,
    geo = require('geometry'), ccp = geo.ccp;

var Node = BObject.extend(/** @lends cocos.nodes.Node# */{
    isCocosNode: true,

    /**
     * Is the node visible
     * @type boolean
     */
    visible: true,

    /**
     * Position relative to parent node
     * @type geometry.Point
     */
    position: null,

    /**
     * Parent node
     * @type cocos.nodes.Node
     */
    parent: null,

    /**
     * Unique tag to identify the node
     * @type *
     */
    tag: null,

    /**
     * Size of the node
     * @type geometry.Size
     */
    contentSize: null,

    /**
     * Nodes Z index. i.e. draw order
     * @type Integer
     */
    zOrder: 0,

    /**
     * Anchor point for scaling and rotation. 0x0 is top left and 1x1 is bottom right
     * @type geometry.Point
     */
    anchorPoint: null,

    /**
     * Anchor point for scaling and rotation in pixels from top left
     * @type geometry.Point
     */
    anchorPointInPixels: null,

    /**
     * Rotation angle in degrees
     * @type Float
     */
    rotation: 0,

    /**
     * X scale factor
     * @type Float
     */
    scaleX: 1,

    /**
     * Y scale factor
     * @type Float
     */
    scaleY: 1,
    isRunning: false,
    isRelativeAnchorPoint: true,

    isTransformDirty: true,
    isInverseDirty: true,
    inverse: null,
    transformMatrix: null,

    /**
     * The child Nodes
     * @type cocos.nodes.Node[]
     */
    children: null,

    /**
     * @memberOf cocos.nodes
     * @class The base class all visual elements extend from
     * @extends BObject
     * @constructs
     */
    init: function () {
        Node.superclass.init.call(this);
        this.set('contentSize', {width: 0, height: 0});
        this.anchorPoint = ccp(0.5, 0.5);
        this.anchorPointInPixels = ccp(0, 0);
        this.position = ccp(0, 0);
        this.children = [];

        util.each(['scaleX', 'scaleY', 'rotation', 'position', 'anchorPoint', 'contentSize', 'isRelativeAnchorPoint'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._dirtyTransform));
        }));
        evt.addListener(this, 'anchorpoint_changed', util.callback(this, this._updateAnchorPointInPixels));
        evt.addListener(this, 'contentsize_changed', util.callback(this, this._updateAnchorPointInPixels));
    },

    /**
     * Calculates the anchor point in pixels and updates the
     * anchorPointInPixels property
     * @private
     */
    _updateAnchorPointInPixels: function () {
        var ap = this.get('anchorPoint'),
            cs = this.get('contentSize');
        this.set('anchorPointInPixels', ccp(cs.width * ap.x, cs.height * ap.y));
    },

    /**
     * Add a child Node
     *
     * @opt {cocos.nodes.Node} child The child node to add
     * @opt {Integer} [z] Z Index for the child
     * @opt {Integer|String} [tag] A tag to reference the child with
     * @returns {cocos.nodes.Node} The node the child was added to. i.e. 'this'
     */
    addChild: function (opts) {
        if (opts.isCocosNode) {
            return this.addChild({child: opts});
        }

        var child = opts.child,
            z = opts.z,
            tag = opts.tag;

        if (z === undefined || z === null) {
            z = child.get('zOrder');
        }

        //this.insertChild({child: child, z:z});
        var added = false;

        
        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }

        child.set('tag', tag);
        child.set('zOrder', z);
        child.set('parent', this);

        if (this.isRunning) {
            child.onEnter();
        }

        return this;
    },
    getChild: function (opts) {
        var tag = opts.tag;

        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].tag == tag) {
                return this.children[i];
            }
        }

        return null;
    },

    removeChild: function (opts) {
        var child = opts.child,
            cleanup = opts.cleanup;

        if (!child) {
            return;
        }

        var children = this.get('children'),
            idx = children.indexOf(child);

        if (idx > -1) {
            this.detatchChild({child: child, cleanup: cleanup});
        }
    },

    detatchChild: function (opts) {
        var child = opts.child,
            cleanup = opts.cleanup;

        var children = this.get('children'),
            isRunning = this.get('isRunning'),
            idx = children.indexOf(child);

        if (isRunning) {
            child.onExit();
        }

        if (cleanup) {
            child.cleanup();
        }

        child.set('parent', null);
        children.splice(idx, 1);
    },

    reorderChild: function (opts) {
        var child = opts.child,
            z     = opts.z;

        var pos = this.children.indexOf(child);
        if (pos == -1) {
            throw "Node isn't a child of this node";
        }

        child.set('zOrder', z);

        // Remove child
        this.children.splice(pos, 1);

        // Add child back at correct location
        var added = false;
        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }
    },

    /**
     * Draws the node. Override to do custom drawing. If it's less efficient to
     * draw only the area inside the rect then don't bother. The result will be
     * clipped to that area anyway.
     *
     * @param {CanvasRenderingContext2D|WebGLRenderingContext} context Canvas rendering context
     * @param {geometry.Rect} rect Rectangular region that needs redrawing. Limit drawing to this area only if it's more efficient to do so.
     */
    draw: function (context, rect) {
        // All draw code goes here
    },

    /**
     * @getter scale
     * @type Float
     */
    get_scale: function () {
        if (this.scaleX != this.scaleY) {
            throw "scaleX and scaleY aren't identical";
        }

        return this.scaleX;
    },

    /**
     * @setter scale
     * @type Float
     */
    set_scale: function (val) {
        this.set('scaleX', val);
        this.set('scaleY', val);
    },

    scheduleUpdate: function (opts) {
        opts = opts || {};
        var priority = opts.priority || 0;

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: priority, paused: !this.get('isRunning')});
    },

    /**
     * Triggered when the node is added to a scene
     *
     * @event
     */
    onEnter: function () {
        util.each(this.children, function (child) {
            child.onEnter();
        });

        this.resumeSchedulerAndActions();
        this.set('isRunning', true);
    },

    /**
     * Triggered when the node is removed from a scene
     *
     * @event
     */
    onExit: function () {
        this.pauseSchedulerAndActions();
        this.set('isRunning', false);

        util.each(this.children, function (child) {
            child.onExit();
        });
    },

    cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllSelectors();
        util.each(this.children, function (child) {
            child.cleanup();
        });
    },

    resumeSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').resumeTarget(this);
        ActionManager.get('sharedManager').resumeTarget(this);
    },
    pauseSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').pauseTarget(this);
        ActionManager.get('sharedManager').pauseTarget(this);
    },
    unscheduleAllSelectors: function () {
        Scheduler.get('sharedScheduler').unscheduleAllSelectorsForTarget(this);
    },
    stopAllActions: function () {
        ActionManager.get('sharedManager').removeAllActionsFromTarget(this);
    },

    visit: function (context, rect) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        // Adjust redraw region by nodes position
        if (rect) {
            var pos = this.get('position');
            rect = new geo.Rect(rect.origin.x - pos.x, rect.origin.y - pos.y, rect.size.width, rect.size.height);
        }

        // Draw background nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder < 0) {
                child.visit(context, rect);
            }
        });

        this.draw(context, rect);

        // Draw foreground nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder >= 0) {
                child.visit(context, rect);
            }
        });

        context.restore();
    },
    transform: function (context) {
        // Translate
        if (this.isRelativeAnchorPoint && (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels !== 0)) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }

        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels !== 0) {
            context.translate(Math.round(this.position.x + this.anchorPointInPixels.x), Math.round(this.position.y + this.anchorPointInPixels.y));
        } else {
            context.translate(Math.round(this.position.x), Math.round(this.position.y));
        }

        // Rotate
        context.rotate(geo.degreesToRadians(this.get('rotation')));

        // Scale
        context.scale(this.scaleX, this.scaleY);
 
        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels !== 0) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }
    },

    runAction: function (action) {
        ActionManager.get('sharedManager').addAction({action: action, target: this, paused: this.get('isRunning')});
    },

    nodeToParentTransform: function () {
        if (this.isTransformDirty) {
            this.transformMatrix = geo.affineTransformIdentity();

            if (!this.isRelativeAnchorPoint && !geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.anchorPointInPixels.x, this.anchorPointInPixels.y);
            }
            
            if (!geo.pointEqualToPoint(this.position, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.position.x, this.position.y);
            }

            if (this.rotation !== 0) {
                this.transformMatrix = geo.affineTransformRotate(this.transformMatrix, -geo.degreesToRadians(this.rotation));
            }
            if (!(this.scaleX == 1 && this.scaleY == 1)) {
                this.transformMatrix = geo.affineTransformScale(this.transformMatrix, this.scaleX, this.scaleY);
            }
            
            if (!geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, -this.anchorPointInPixels.x, -this.anchorPointInPixels.y);
            }
            
            this.set('isTransformDirty', false);
                
        }

        return this.transformMatrix;
    },

    parentToNodeTransform: function () {
        // TODO
    },

    nodeToWorldTransform: function () {
        var t = this.nodeToParentTransform();

        var p;
        for (p = this.get('parent'); p; p = p.get('parent')) {
            t = geo.affineTransformConcat(t, p.nodeToParentTransform());
        }

        return t;
    },

    worldToNodeTransform: function () {
        return geo.affineTransformInvert(this.nodeToWorldTransform());
    },

    convertToNodeSpace: function (worldPoint) {
        return geo.pointApplyAffineTransform(worldPoint, this.worldToNodeTransform());
    },

    /**
     * @getter boundingBox
     * @type geometry.Rect
     */
    get_boundingBox: function () {
        var cs = this.get('contentSize');
        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToParentTransform());
        return rect;
    },

    /**
     * @getter worldBoundingBox
     * @type geometry.Rect
     */
    get_worldBoundingBox: function () {
        var cs = this.get('contentSize');

        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToWorldTransform());
        return rect;
    },

    /**
     * The area of the node currently visible on screen. Returns an rect even
     * if visible is false.
     *
     * @getter visibleRect
     * @type geometry.Rect
     */
    get_visibleRect: function () {
        var s = require('../Director').Director.get('sharedDirector').get('winSize');
        var rect = new geo.Rect(
            0, 0,
            s.width, s.height
        );

        return geo.rectApplyAffineTransform(rect, this.worldToNodeTransform());
    },

    /**
     * @private
     */
    _dirtyTransform: function () {
        this.set('isTransformDirty', true);
    }
});

module.exports.Node = Node;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/RenderTexture.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event'),
    Node = require('./Node').Node,
    geo = require('geometry'),
    Sprite = require('./Sprite').Sprite,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    ccp = geo.ccp;

var RenderTexture = Node.extend(/** @lends cocos.nodes.RenderTexture# */{
    canvas: null,
    context: null,
    sprite: null,

    /** 
     * An in-memory canvas which can be drawn to in the background before drawing on screen
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Integer} width The width of the canvas
     * @opt {Integer} height The height of the canvas
     */
    init: function (opts) {
        RenderTexture.superclass.init.call(this, opts);

        var width = opts.width,
            height = opts.height;

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));

        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d');

        var atlas = TextureAtlas.create({canvas: this.canvas});
        this.sprite = Sprite.create({textureAtlas: atlas, rect: {origin: ccp(0, 0), size: {width: width, height: height}}});

        this.set('contentSize', geo.sizeMake(width, height));
        this.addChild(this.sprite);
        this.set('anchorPoint', ccp(0, 0));
        this.sprite.set('anchorPoint', ccp(0, 0));

    },

    /**
     * @private
     */
    _resizeCanvas: function () {
        var size = this.get('contentSize'),
            canvas = this.get('canvas');

        canvas.width  = size.width;
        canvas.height = size.height;
        if (FLIP_Y_AXIS) {
            this.context.scale(1, -1);
            this.context.translate(0, -canvas.height);
        }

        var s = this.get('sprite');
        if (s) {
            s.set('textureRect', {rect: geo.rectMake(0, 0, size.width, size.height)});
        }
    },

    /**
     * Clear the canvas
     */
    clear: function (rect) {
        if (rect) {
            this.context.clearRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
        } else {
            this.canvas.width = this.canvas.width;
            if (FLIP_Y_AXIS) {
                this.context.scale(1, -1);
                this.context.translate(0, -this.canvas.height);
            }
        }
    }
});

module.exports.RenderTexture = RenderTexture;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Scene.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node;

var Scene = Node.extend(/** @lends cocos.nodes.Scene */{
    /**
     * Everything in your view will be a child of this object. You need at least 1 scene per app.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Scene.superclass.init.call(this);
    }

});

module.exports.Scene = Scene;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Sprite.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event'),
    Director = require('../Director').Director,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    Node = require('./Node').Node,
    geo = require('geometry'),
    ccp = geo.ccp;

var Sprite = Node.extend(/** @lends cocos.nodes.Sprite# */{
    textureAtlas: null,
    rect: null,
    dirty: true,
    recursiveDirty: true,
    quad: null,
    flipX: false,
    flipY: false,
    offsetPosition: null,
    unflippedOffsetPositionFromCenter: null,
    untrimmedSize: null,

    /**
     * A small 2D graphics than can be animated
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file Path to image to use as sprite atlas
     * @opt {Rect} [rect] The rect in the sprite atlas image file to use as the sprite
     */
    init: function (opts) {
        Sprite.superclass.init.call(this, opts);

        opts = opts || {};

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture,
            frame        = opts.frame,
            spritesheet  = opts.spritesheet,
            rect         = opts.rect;

        this.set('offsetPosition', ccp(0, 0));
        this.set('unflippedOffsetPositionFromCenter', ccp(0, 0));


        if (frame) {
            texture = frame.get('texture');
            rect    = frame.get('rect');
        }

        util.each(['scale', 'scaleX', 'scaleY', 'rect', 'flipX', 'flipY'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._updateQuad));
        }));
        evt.addListener(this, 'textureatlas_changed', util.callback(this, this._updateTextureQuad));

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        } else if (spritesheet) {
            textureAtlas = spritesheet.get('textureAtlas');
            this.set('useSpriteSheet', true);
        } else if (!textureAtlas) {
            //throw "Sprite has no texture";
        }

        if (!rect && textureAtlas) {
            rect = {origin: ccp(0, 0), size: {width: textureAtlas.texture.size.width, height: textureAtlas.texture.size.height}};
        }

        if (rect) {
            this.set('rect', rect);
            this.set('contentSize', rect.size);

            this.quad = {
                drawRect: {origin: ccp(0, 0), size: rect.size},
                textureRect: rect
            };
        }

        this.set('textureAtlas', textureAtlas);

        if (frame) {
            this.set('displayFrame', frame);
        }
    },

    /**
     * @private
     */
    _updateTextureQuad: function (obj, key, texture, oldTexture) {
        if (oldTexture) {
            oldTexture.removeQuad({quad: this.get('quad')});
        }

        if (texture) {
            texture.insertQuad({quad: this.get('quad')});
        }
    },

    /**
     * @setter textureCoords
     * @type geometry.Rect
     */
    set_textureCoords: function (rect) {
        var quad = this.get('quad');
        if (!quad) {
            quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        quad.textureRect = util.copy(rect);

        this.set('quad', quad);
    },

    /**
     * @setter textureRect
     * @type geometry.Rect
     */
    set_textureRect: function (opts) {
        var rect = opts.rect,
            rotated = !!opts.rotated,
            untrimmedSize = opts.untrimmedSize || rect.size;

        this.set('contentSize', untrimmedSize);
        this.set('rect', util.copy(rect));
        this.set('textureCoords', rect);

        var quad = this.get('quad');

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = this.get('offsetPosition');
        offsetPosition.x =  relativeOffset.x + (this.get('contentSize').width  - rect.size.width) / 2;
        offsetPosition.y = -relativeOffset.y + (this.get('contentSize').height - rect.size.height) / 2;

        quad.drawRect.origin = util.copy(offsetPosition);
        quad.drawRect.size = util.copy(rect.size);
        if (this.flipX) {
            quad.drawRect.size.width *= -1;
            quad.drawRect.origin.x = -rect.size.width;
        }
        if (this.flipY) {
            quad.drawRect.size.height *= -1;
            quad.drawRect.origin.y = -rect.size.height;
        }

        this.set('quad', quad);
    },

    /**
     * @private
     */
    _updateQuad: function () {
        if (!this.quad) {
            this.quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = this.get('offsetPosition');
        offsetPosition.x = relativeOffset.x + (this.get('contentSize').width  - this.get('rect').size.width) / 2;
        offsetPosition.y = relativeOffset.y + (this.get('contentSize').height - this.get('rect').size.height) / 2;

        this.quad.textureRect = util.copy(this.rect);
        this.quad.drawRect.origin = util.copy(offsetPosition);
        this.quad.drawRect.size = util.copy(this.rect.size);

        if (this.flipX) {
            this.quad.drawRect.size.width *= -1;
            this.quad.drawRect.origin.x = -this.rect.size.width;
        }
        if (this.flipY) {
            this.quad.drawRect.size.height *= -1;
            this.quad.drawRect.origin.y = -this.rect.size.height;
        }
    },

    updateTransform: function (ctx) {
        if (!this.useSpriteSheet) {
            throw "updateTransform is only valid when Sprite is being rendered using a SpriteSheet";
        }

        if (!this.visible) {
            this.set('dirty', false);
            this.set('recursiveDirty', false);
            return;
        }

        // TextureAtlas has hard reference to this quad so we can just update it directly
        this.quad.drawRect.origin = {
            x: this.position.x - this.anchorPointInPixels.x * this.scaleX,
            y: this.position.y - this.anchorPointInPixels.y * this.scaleY
        };
        this.quad.drawRect.size = {
            width: this.rect.size.width * this.scaleX,
            height: this.rect.size.height * this.scaleY
        };

        this.set('dirty', false);
        this.set('recursiveDirty', false);
    },

    draw: function (ctx) {
        if (!this.quad) {
            return;
        }
        this.get('textureAtlas').drawQuad(ctx, this.quad);
    },

    isFrameDisplayed: function (frame) {
        if (!this.rect || !this.textureAtlas) {
            return false;
        }
        return (frame.texture === this.textureAtlas.texture && geo.rectEqualToRect(frame.rect, this.rect));
    },


    /**
     * @setter displayFrame
     * @type cocos.SpriteFrame
     */
    set_displayFrame: function (frame) {
        if (!frame) {
            delete this.quad;
            return;
        }
        this.set('unflippedOffsetPositionFromCenter', util.copy(frame.offset));


        // change texture
        if (!this.textureAtlas || frame.texture !== this.textureAtlas.texture) {
            this.set('textureAtlas', TextureAtlas.create({texture: frame.texture}));
        }

        this.set('textureRect', {rect: frame.rect, rotated: frame.rotated, untrimmedSize: frame.originalSize});
    }
});

module.exports.Sprite = Sprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXLayer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    SpriteBatchNode = require('./BatchNode').SpriteBatchNode,
    Sprite = require('./Sprite').Sprite,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    geo    = require('geometry'),
    ccp    = geo.ccp,
    Node = require('./Node').Node;

var TMXLayer = SpriteBatchNode.extend(/** @lends cocos.nodes.TMXLayer# */{
    layerSize: null,
    layerName: '',
    tiles: null,
    tilset: null,
    layerOrientation: 0,
    mapTileSize: null,
    properties: null,

    /** 
     * A tile map layer loaded from a TMX file. This will probably automatically be made by cocos.TMXTiledMap
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.SpriteBatchNode
     *
     * @opt {cocos.TMXTilesetInfo} tilesetInfo
     * @opt {cocos.TMXLayerInfo} layerInfo
     * @opt {cocos.TMXMapInfo} mapInfo
     */
    init: function (opts) {
        var tilesetInfo = opts.tilesetInfo,
            layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo;

        var size = layerInfo.get('layerSize'),
            totalNumberOfTiles = size.width * size.height;

        var tex = null;
        if (tilesetInfo) {
            tex = tilesetInfo.sourceImage;
        }

        TMXLayer.superclass.init.call(this, {file: tex});

		this.set('anchorPoint', ccp(0, 0));

        this.layerName = layerInfo.get('name');
        this.layerSize = layerInfo.get('layerSize');
        this.tiles = layerInfo.get('tiles');
        this.minGID = layerInfo.get('minGID');
        this.maxGID = layerInfo.get('maxGID');
        this.opacity = layerInfo.get('opacity');
        this.properties = util.copy(layerInfo.properties);

        this.tileset = tilesetInfo;
        this.mapTileSize = mapInfo.get('tileSize');
        this.layerOrientation = mapInfo.get('orientation');

        var offset = this.calculateLayerOffset(layerInfo.get('offset'));
        this.set('position', offset);

        this.set('contentSize', geo.sizeMake(this.layerSize.width * this.mapTileSize.width, (this.layerSize.height * (this.mapTileSize.height - 1)) + this.tileset.tileSize.height));
    },

    calculateLayerOffset: function (pos) {
        var ret = ccp(0, 0);

        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            ret = ccp(pos.x * this.mapTileSize.width, pos.y * this.mapTileSize.height);
            break;
        case TMXOrientationIso:
            // TODO
            break;
        case TMXOrientationHex:
            // TODO
            break;
        }

        return ret;
    },

    setupTiles: function () {
        this.tileset.bindTo('imageSize', this.get('texture'), 'contentSize');


        for (var y = 0; y < this.layerSize.height; y++) {
            for (var x = 0; x < this.layerSize.width; x++) {
                
                var pos = x + this.layerSize.width * y,
                    gid = this.tiles[pos];
                
                if (gid !== 0) {
                    this.appendTile({gid: gid, position: ccp(x, y)});
                    
                    // Optimization: update min and max GID rendered by the layer
                    this.minGID = Math.min(gid, this.minGID);
                    this.maxGID = Math.max(gid, this.maxGID);
                }
            }
        }
    },
    appendTile: function (opts) {
        var gid = opts.gid,
            pos = opts.position;

        var z = pos.x + pos.y * this.layerSize.width;
            
        var rect = this.tileset.rectForGID(gid);
        var tile = Sprite.create({rect: rect, textureAtlas: this.textureAtlas});
        tile.set('position', this.positionAt(pos));
        tile.set('anchorPoint', ccp(0, 0));
        tile.set('opacity', this.get('opacity'));
        
        this.addChild({child: tile, z: 0, tag: z});
    },
    positionAt: function (pos) {
        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            return this.positionForOrthoAt(pos);
        case TMXOrientationIso:
            return this.positionForIsoAt(pos);
        /*
        case TMXOrientationHex:
            // TODO
        */
        default:
            return ccp(0, 0);
        }
    },
    positionForOrthoAt: function (pos) {
        var overlap = this.mapTileSize.height - this.tileset.tileSize.height;
        var x = Math.floor(pos.x * this.mapTileSize.width + 0.49);
        var y;
        if (FLIP_Y_AXIS) {
            y = Math.floor((this.get('layerSize').height - pos.y - 1) * this.mapTileSize.height + 0.49);
        } else {
            y = Math.floor(pos.y * this.mapTileSize.height + 0.49) + overlap;
        }
        return ccp(x, y);
    },

    positionForIsoAt: function (pos) {
        var mapTileSize = this.get('mapTileSize'),
            layerSize = this.get('layerSize');

        if (FLIP_Y_AXIS) {
            return ccp(
                mapTileSize.width  / 2 * (layerSize.width + pos.x - pos.y - 1),
                mapTileSize.height / 2 * ((layerSize.height * 2 - pos.x - pos.y) - 2)
            );
        } else {
            throw "Isometric tiles without FLIP_Y_AXIS is currently unsupported";
        }
    },


    tileGID: function (pos) {
        var tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);

        return this.tiles[tilePos];
    },
    removeTile: function (pos) {
        var gid = this.tileGID(pos);
        if (gid === 0) {
            // Tile is already blank
            return;
        }

        var tiles = this.get('tiles'),
            tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);


        tiles[tilePos] = 0;

        var sprite = this.getChild({tag: tilePos});
        if (sprite) {
            this.removeChild({child: sprite});
        }
    }
});

exports.TMXLayer = TMXLayer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXTiledMap.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    Node = require('./Node').Node,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    TMXLayer   = require('./TMXLayer').TMXLayer,
    TMXMapInfo = require('../TMXXMLParser').TMXMapInfo;

var TMXTiledMap = Node.extend(/** @lends cocos.nodes.TMXTiledMap# */{
    mapSize: null,
    tileSize: null,
    mapOrientation: 0,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * A TMX Map loaded from a .tmx file
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file The file path of the TMX map to load
     */
    init: function (opts) {
        TMXTiledMap.superclass.init.call(this, opts);

        this.set('anchorPoint', ccp(0, 0));

        var mapInfo = TMXMapInfo.create(opts.file);

        this.mapSize        = mapInfo.get('mapSize');
        this.tileSize       = mapInfo.get('tileSize');
        this.mapOrientation = mapInfo.get('orientation');
        this.objectGroups   = mapInfo.get('objectGroups');
        this.properties     = mapInfo.get('properties');
        this.tileProperties = mapInfo.get('tileProperties');

        // Add layers to map
        var idx = 0;
        util.each(mapInfo.layers, util.callback(this, function (layerInfo) {
            if (layerInfo.get('visible')) {
                var child = this.parseLayer({layerInfo: layerInfo, mapInfo: mapInfo});
                this.addChild({child: child, z: idx, tag: idx});

                var childSize   = child.get('contentSize');
                var currentSize = this.get('contentSize');
                currentSize.width  = Math.max(currentSize.width,  childSize.width);
                currentSize.height = Math.max(currentSize.height, childSize.height);
                this.set('contentSize', currentSize);

                idx++;
            }
        }));
    },
    
    parseLayer: function (opts) {
        var tileset = this.tilesetForLayer(opts);
        var layer = TMXLayer.create({tilesetInfo: tileset, layerInfo: opts.layerInfo, mapInfo: opts.mapInfo});

        layer.setupTiles();

        return layer;
    },

    tilesetForLayer: function (opts) {
        var layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo,
            size = layerInfo.get('layerSize');

        // Reverse loop
        var tileset;
        for (var i = mapInfo.tilesets.length - 1; i >= 0; i--) {
            tileset = mapInfo.tilesets[i];

            for (var y = 0; y < size.height; y++) {
                for (var x = 0; x < size.width; x++) {
                    var pos = x + size.width * y, 
                        gid = layerInfo.tiles[pos];

                    if (gid !== 0 && gid >= tileset.firstGID) {
                        return tileset;
                    }
                } // for (var x
            } // for (var y
        } // for (var i

        //console.log("cocos2d: Warning: TMX Layer '%s' has no tiles", layerInfo.name);
        return tileset;
    },
    
    /**
     * Return the ObjectGroup for the secific group
     *
     * @opt {String} name The object group name
     * @returns {cocos.TMXObjectGroup} The object group
     */
    objectGroupNamed: function(opts) {
        var objectGroupName = opts.name,
            objectGroup = null;

        this.objectGroups.forEach(function(item) {

            if(item.name == objectGroupName) {
                objectGroup = item;
            }
        });
        if(objectGroup != null) {
            return objectGroup;
        }
    }
});

exports.TMXTiledMap = TMXTiledMap;


}};
__resources__["/__builtin__/libs/cocos2d/Scheduler.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

/** @ignore */
function HashUpdateEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

/** @ignore */
function HashMethodEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

var Timer = BObject.extend(/** @lends cocos.Timer# */{
    callback: null,
    interval: 0,
    elapsed: -1,

    /**
     * Runs a function repeatedly at a fixed interval
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {Function} callback The function to run at each interval
     * @opt {Float} interval Number of milliseconds to wait between each exectuion of callback
     */
    init: function (opts) {
        Timer.superclass.init(this, opts);

        this.set('callback', opts.callback);
        this.set('interval', opts.interval || 0);
        this.set('elapsed', -1);
    },

    /**
     * @private
     */
    update: function (dt) {
        if (this.elapsed == -1) {
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        if (this.elapsed >= this.interval) {
            this.callback(this.elapsed);
            this.elapsed = 0;
        }
    }
});


var Scheduler = BObject.extend(/** @lends cocos.Scheduler# */{
    updates0: null,
    updatesNeg: null,
    updatesPos: null,
    hashForUpdates: null,
    hashForMethods: null,
    timeScale: 1.0,

    /**
     * Runs the timers
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     * @private
     */
    init: function () {
        this.updates0 = [];
        this.updatesNeg = [];
        this.updatesPos = [];
        this.hashForUpdates = {};
        this.hashForMethods = {};
    },

    schedule: function (opts) {
        var target   = opts.target,
            method   = opts.method,
            interval = opts.interval,
            paused   = opts.paused || false;

        var element = this.hashForMethods[target.get('id')];

        if (!element) {
            element = new HashMethodEntry();
            this.hashForMethods[target.get('id')] = element;
            element.target = target;
            element.paused = paused;
        } else if (element.paused != paused) {
            throw "cocos.Scheduler. Trying to schedule a method with a pause value different than the target";
        }

        var timer = Timer.create({callback: util.callback(target, method), interval: interval});
        element.timers.push(timer);
    },

    scheduleUpdate: function (opts) {
        var target   = opts.target,
            priority = opts.priority,
            paused   = opts.paused;

        var i, len;
        var entry = {target: target, priority: priority, paused: paused};
        var added = false;

        if (priority === 0) {
            this.updates0.push(entry);
        } else if (priority < 0) {
            for (i = 0, len = this.updatesNeg.length; i < len; i++) {
                if (priority < this.updatesNeg[i].priority) {
                    this.updatesNeg.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesNeg.push(entry);
            }
        } else /* priority > 0 */{
            for (i = 0, len = this.updatesPos.length; i < len; i++) {
                if (priority < this.updatesPos[i].priority) {
                    this.updatesPos.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesPos.push(entry);
            }
        }

        this.hashForUpdates[target.get('id')] = entry;
    },

    tick: function (dt) {
        var i, len, x;
        if (this.timeScale != 1.0) {
            dt *= this.timeScale;
        }

        var entry;
        for (i = 0, len = this.updatesNeg.length; i < len; i++) {
            entry = this.updatesNeg[i];
            if (!entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updates0.length; i < len; i++) {
            entry = this.updates0[i];
            if (!entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updatesPos.length; i < len; i++) {
            entry = this.updatesPos[i];
            if (!entry.paused) {
                entry.target.update(dt);
            }
        }

        for (x in this.hashForMethods) {
            if (this.hashForMethods.hasOwnProperty(x)) {
                entry = this.hashForMethods[x];
                for (i = 0, len = entry.timers.length; i < len; i++) {
                    var timer = entry.timers[i];
                    timer.update(dt);
                }
            }
        }

	},

    unscheduleAllSelectorsForTarget: function (target) {
    },

    pauseTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = true;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        if (elementUpdate) {
            elementUpdate.paused = true;
        }
    },

	resumeTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = false;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        //console.log('foo', target.get('id'), elementUpdate);
        if (elementUpdate) {
            elementUpdate.paused = false;
        }
	}
});

util.extend(Scheduler, /** @lends cocos.Scheduler */{
    /**
     * A shared singleton instance of cocos.Scheduler
     * @getter sharedScheduler 
     * @type cocos.Scheduler
     */
    get_sharedScheduler: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.Timer = Timer;
exports.Scheduler = Scheduler;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrame.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp;

var SpriteFrame = BObject.extend(/** @lends cocos.SpriteFrame# */{
    rect: null,
    rotated: false,
    offset: null,
    originalSize: null,
    texture: null,

    /**
     * Represents a single frame of animation for a cocos.Sprite
     *
     * <p>A SpriteFrame has:<br>
     * - texture: A Texture2D that will be used by the Sprite<br>
     * - rectangle: A rectangle of the texture</p>
     *
     * <p>You can modify the frame of a Sprite by doing:</p>
     * 
     * <code>var frame = SpriteFrame.create({texture: texture, rect: rect});
     * sprite.set('displayFrame', frame);</code>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.Texture2D} texture The texture to draw this frame using
     * @opt {geometry.Rect} rect The rectangle inside the texture to draw
     */
    init: function (opts) {
        SpriteFrame.superclass.init(this, opts);

        this.texture      = opts.texture;
        this.rect         = opts.rect;
        this.rotated      = !!opts.rotate;
        this.offset       = opts.offset || ccp(0, 0);
        this.originalSize = opts.originalSize || util.copy(this.rect.size);
    },

    /**
     * @ignore
     */
    toString: function () {
        return "[object SpriteFrame | TextureName=" + this.texture.get('name') + ", Rect = (" + this.rect.origin.x + ", " + this.rect.origin.y + ", " + this.rect.size.width + ", " + this.rect.size.height + ")]";
    },

    /**
     * Make a copy of this frame
     *
     * @returns {cocos.SpriteFrame} Exact copy of this object
     */
    copy: function () {
        return SpriteFrame.create({rect: this.rect, rotated: this.rotated, offset: this.offset, originalSize: this.originalSize, texture: this.texture});
    }

});

exports.SpriteFrame = SpriteFrame;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrameCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    Plist = require('Plist').Plist,
    SpriteFrame = require('./SpriteFrame').SpriteFrame,
    Texture2D = require('./Texture2D').Texture2D;

var SpriteFrameCache = BObject.extend(/** @lends cocos.SpriteFrameCache# */{
    /**
     * List of sprite frames
     * @type Object
     */
    spriteFrames: null,

    /**
     * List of sprite frame aliases
     * @type Object
     */
    spriteFrameAliases: null,


    /**
     * @memberOf cocos
     * @extends BObject
     * @constructs
     * @singleton
     */
    init: function () {
        SpriteFrameCache.superclass.init.call(this);

        this.set('spriteFrames', {});
        this.set('spriteFrameAliases', {});
    },

    /**
     * Add SpriteFrame(s) to the cache
     *
     * @param {String} opts.file The filename of a Zwoptex .plist containing the frame definiitons.
     */
    addSpriteFrames: function (opts) {
        var plistPath = opts.file,
            plist = Plist.create({file: plistPath}),
            plistData = plist.get('data');


        var metaDataDict = plistData.metadata,
            framesDict = plistData.frames;

        var format = 0,
            texturePath = null;

        if (metaDataDict) {
            format = metaDataDict.format;
            // Get texture path from meta data
            texturePath = metaDataDict.textureFileName;
        }

        if (!texturePath) {
            // No texture path so assuming it's the same name as the .plist but ending in .png
            texturePath = plistPath.replace(/\.plist$/i, '.png');
        }


        var texture = Texture2D.create({file: texturePath});

        // Add frames
        for (var frameDictKey in framesDict) {
            if (framesDict.hasOwnProperty(frameDictKey)) {
                var frameDict = framesDict[frameDictKey],
                    spriteFrame = null;

                switch (format) {
                case 0:
                    var x = frameDict.x,
                        y =  frameDict.y,
                        w =  frameDict.width,
                        h =  frameDict.height,
                        ox = frameDict.offsetX,
                        oy = frameDict.offsetY,
                        ow = frameDict.originalWidth,
                        oh = frameDict.originalHeight;

                    // check ow/oh
                    if (!ow || !oh) {
                        //console.log("cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist");
                    }

                    if (FLIP_Y_AXIS) {
                        oy *= -1;
                    }

                    // abs ow/oh
                    ow = Math.abs(ow);
                    oh = Math.abs(oh);

                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(x, y, w, h),
                                                       rotate: false,
                                                       offset: geo.ccp(ox, oy),
                                                 originalSize: geo.sizeMake(ow, oh)});
                    break;

                case 1:
                case 2:
                    var frame      = geo.rectFromString(frameDict.frame),
                        rotated    = !!frameDict.rotated,
                        offset     = geo.pointFromString(frameDict.offset),
                        sourceSize = geo.sizeFromString(frameDict.sourceSize);

                    if (FLIP_Y_AXIS) {
                        offset.y *= -1;
                    }


                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: frame,
                                                       rotate: rotated,
                                                       offset: offset,
                                                 originalSize: sourceSize});
                    break;

                case 3:
                    var spriteSize       = geo.sizeFromString(frameDict.spriteSize),
                        spriteOffset     = geo.pointFromString(frameDict.spriteOffset),
                        spriteSourceSize = geo.sizeFromString(frameDict.spriteSourceSize),
                        textureRect      = geo.rectFromString(frameDict.textureRect),
                        textureRotated   = frameDict.textureRotated;
                    

                    if (FLIP_Y_AXIS) {
                        spriteOffset.y *= -1;
                    }

                    // get aliases
                    var aliases = frameDict.aliases;
                    for (var i = 0, len = aliases.length; i < len; i++) {
                        var alias = aliases[i];
                        this.get('spriteFrameAliases')[frameDictKey] = alias;
                    }
                    
                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
                                                       rotate: textureRotated,
                                                       offset: spriteOffset,
                                                 originalSize: spriteSourceSize});
                    break;

                default:
                    throw "Unsupported Zwoptex format: " + format;
                }

                // Add sprite frame
                this.get('spriteFrames')[frameDictKey] = spriteFrame;
            }
        }
    },

    /**
     * Get a single SpriteFrame
     *
     * @param {String} opts.name The name of the sprite frame
     * @returns {cocos.SpriteFrame} The sprite frame
     */
    getSpriteFrame: function (opts) {
        var name = opts.name;

        var frame = this.get('spriteFrames')[name];

        if (!frame) {
            // No frame, look for an alias
            var key = this.get('spriteFrameAliases')[name];

            if (key) {
                frame = this.get('spriteFrames')[key];
            }

            if (!frame) {
                throw "Unable to find frame: " + name;
            }
        }

        return frame;
    }
});

/**
 * Class methods
 */
util.extend(SpriteFrameCache, /** @lends cocos.SpriteFrameCache */{
    /**
     * @field
     * @name cocos.SpriteFrameCache.sharedSpriteFrameCache
     * @type cocos.SpriteFrameCache
     */
    get_sharedSpriteFrameCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.SpriteFrameCache = SpriteFrameCache;

}};
__resources__["/__builtin__/libs/cocos2d/Texture2D.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var Texture2D = BObject.extend(/** @lends cocos.Texture2D# */{
	imgElement: null,
	size: null,
    name: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} [file] The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     */
	init: function (opts) {
		var file = opts.file,
			data = opts.data,
			texture = opts.texture;

		if (file) {
            this.name = file;
			data = resource(file);
		} else if (texture) {
            this.name = texture.get('name');
			data = texture.get('imgElement');
		}

		this.size = {width: 0, height: 0};

		this.set('imgElement', data);
		this.set('size', {width: this.imgElement.width, height: this.imgElement.height});
	},

	drawAtPoint: function (ctx, point) {
		ctx.drawImage(this.imgElement, point.x, point.y);
	},
	drawInRect: function (ctx, rect) {
		ctx.drawImage(this.imgElement,
			rect.origin.x, rect.origin.y,
			rect.size.width, rect.size.height
		);
	},

    /**
     * @getter data
     * @type {String} Base64 encoded image data
     */
    get_data: function () {
        return this.imgElement ? this.imgElement.src : null;
	},

    /**
     * @getter contentSize
     * @type {geometry.Size} Size of the texture
     */
    get_contentSize: function () {
		return this.size;
    }
});

exports.Texture2D = Texture2D;

}};
__resources__["/__builtin__/libs/cocos2d/TextureAtlas.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
	Texture2D = require('./Texture2D').Texture2D;


/* QUAD STRUCTURE
 quad = {
	 drawRect: <rect>, // Where the quad is drawn to
	 textureRect: <rect>  // The slice of the texture to draw in drawRect
 }
*/

var TextureAtlas = BObject.extend(/** @lends cocos.TextureAtlas# */{
	quads: null,
	imgElement: null,
	texture: null,

    /**
     * A single texture that can represent lots of smaller images
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} file The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     * @opt {CanvasElement} [canvas] A canvas to use as a texture
     */
	init: function (opts) {
		var file = opts.file,
			data = opts.data,
			texture = opts.texture,
			canvas = opts.canvas;

        if (canvas) {
            // If we've been given a canvas element then we'll use that for our image
            this.imgElement = canvas;
        } else {
            texture = Texture2D.create({texture: texture, file: file, data: data});
			this.set('texture', texture);
			this.imgElement = texture.get('imgElement');
        }

		this.quads = [];
	},

	insertQuad: function (opts) {
		var quad = opts.quad,
			index = opts.index || 0;

		this.quads.splice(index, 0, quad);
	},
	removeQuad: function (opts) {
		var index = opts.index;

		this.quads.splice(index, 1);
	},


	drawQuads: function (ctx) {
		util.each(this.quads, util.callback(this, function (quad) {
            if (!quad) {
                return;
            }

			this.drawQuad(ctx, quad);
		}));
	},

	drawQuad: function (ctx, quad) {
        var sx = quad.textureRect.origin.x,
            sy = quad.textureRect.origin.y,
            sw = quad.textureRect.size.width, 
            sh = quad.textureRect.size.height;

        var dx = quad.drawRect.origin.x,
            dy = quad.drawRect.origin.y,
            dw = quad.drawRect.size.width, 
            dh = quad.drawRect.size.height;


        var scaleX = 1;
        var scaleY = 1;

        if (FLIP_Y_AXIS) {
            dy -= dh;
            dh *= -1;
        }

            
        if (dw < 0) {
            dw *= -1;
            scaleX = -1;
        }
            
        if (dh < 0) {
            dh *= -1;
            scaleY = -1;
        }

        ctx.scale(scaleX, scaleY);

        var img = this.get('imgElement');
		ctx.drawImage(img, 
			sx, sy, // Draw slice from x,y
			sw, sh, // Draw slice size
			dx, dy, // Draw at 0, 0
			dw, dh  // Draw size
		);
        ctx.scale(1, 1);
	}
});

exports.TextureAtlas = TextureAtlas;

}};
__resources__["/__builtin__/libs/cocos2d/TMXOrientation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

/**
 * @memberOf cocos
 * @namespace
 */
var TMXOrientation = /** @lends cocos.TMXOrientation */{
    /**
     * Orthogonal orientation
     * @constant
     */
	TMXOrientationOrtho: 1,

    /**
     * Hexagonal orientation
     * @constant
     */
	TMXOrientationHex: 2,

    /**
     * Isometric orientation
     * @constant
     */
	TMXOrientationIso: 3
};

module.exports = TMXOrientation;

}};
__resources__["/__builtin__/libs/cocos2d/TMXXMLParser.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray DOMParser*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path'),
    ccp = require('geometry').ccp,
    base64 = require('base64'),
    gzip   = require('gzip'),
    TMXOrientationOrtho = require('./TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex = require('./TMXOrientation').TMXOrientationHex,
    TMXOrientationIso = require('./TMXOrientation').TMXOrientationIso;

var TMXTilesetInfo = BObject.extend(/** @lends cocos.TMXTilesetInfo# */{
    name: '',
    firstGID: 0,
    tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXTilesetInfo.superclass.init.call(this);
    },

    rectForGID: function (gid) {
        var rect = {size: {}, origin: ccp(0, 0)};
        rect.size = util.copy(this.tileSize);
        
        gid = gid - this.firstGID;

        var imgSize = this.get('imageSize');
        
        var maxX = Math.floor((imgSize.width - this.margin * 2 + this.spacing) / (this.tileSize.width + this.spacing));
        
        rect.origin.x = (gid % maxX) * (this.tileSize.width + this.spacing) + this.margin;
        rect.origin.y = Math.floor(gid / maxX) * (this.tileSize.height + this.spacing) + this.margin;
        
        return rect;
    }
});

var TMXLayerInfo = BObject.extend(/** @lends cocos.TMXLayerInfo# */{
    name: '',
    layerSize: null,
    tiles: null,
    visible: true,
    opacity: 255,
    minGID: 100000,
    maxGID: 0,
    properties: null,
    offset: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXLayerInfo.superclass.init.call(this);

        this.properties = {};
        this.offset = ccp(0, 0);
    }
});

var TMXObjectGroup = BObject.extend(/** @lends cocos.TMXObjectGroup# */{
    name: '',
    properties: null,
    offset: null,
    objects: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXObjectGroup.superclass.init.call(this);

        this.properties = {};
        this.objects = {};
        this.offset = ccp(0, 0);
    },

    /**
     * return the value for the specific property name
     *
     * @opt {String} name Property name
     * @returns {String} Property value
     */
    propertyNamed: function(opts) {
        var propertyName = opts.name
        return this.properties[propertyName];
    },

    /**
     * Return the object for the specific object name. It will return the 1st
     * object found on the array for the given name.
     *
     * @opt {String} name Object name
     * @returns {Object} Object
     */
    objectNamed: function(opts) {
        var objectName = opts.name;
        var object = null;
        
        this.objects.forEach(function(item) {
         
            if(item.name == objectName) {
                object = item;
            }
        });
        if(object != null) {
            return object;
        }
    }
});

var TMXMapInfo = BObject.extend(/** @lends cocos.TMXMapInfo# */{
    filename: '',
    orientation: 0,
    mapSize: null,
    tileSize: null,
    layer: null,
    tilesets: null,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @param {String} tmxFile The file path of the TMX file to load
     */
    init: function (tmxFile) {
        TMXMapInfo.superclass.init.call(this, tmxFile);

        this.tilesets = [];
        this.layers = [];
        this.objectGroups = [];
        this.properties = {};
        this.tileProperties = {};
        this.filename = tmxFile;

        this.parseXMLFile(tmxFile);
    },

    parseXMLFile: function (xmlFile) {
        var parser = new DOMParser(),
            doc = parser.parseFromString(resource(xmlFile), 'text/xml');

        // PARSE <map>
        var map = doc.documentElement;

        // Set Orientation
        switch (map.getAttribute('orientation')) {
        case 'orthogonal':
            this.orientation = TMXOrientationOrtho;
            break;
        case 'isometric':
            this.orientation = TMXOrientationIso;
            break;
        case 'hexagonal':
            this.orientation = TMXOrientationHex;
            break;
        default:
            throw "cocos2d: TMXFomat: Unsupported orientation: " + map.getAttribute('orientation');
        }
        this.mapSize = {width: parseInt(map.getAttribute('width'), 10), height: parseInt(map.getAttribute('height'), 10)};
        this.tileSize = {width: parseInt(map.getAttribute('tilewidth'), 10), height: parseInt(map.getAttribute('tileheight'), 10)};


        // PARSE <tilesets>
        var tilesets = map.getElementsByTagName('tileset');
        var i, len, s;
        for (i = 0, len = tilesets.length; i < len; i++) {
            var t = tilesets[i];

            var tileset = TMXTilesetInfo.create();
            tileset.set('name', t.getAttribute('name'));
            tileset.set('firstGID', parseInt(t.getAttribute('firstgid'), 10));
            if (t.getAttribute('spacing')) {
                tileset.set('spacing', parseInt(t.getAttribute('spacing'), 10));
            }
            if (t.getAttribute('margin')) {
                tileset.set('margin', parseInt(t.getAttribute('margin'), 10));
            }

            s = {};
            s.width = parseInt(t.getAttribute('tilewidth'), 10);
            s.height = parseInt(t.getAttribute('tileheight'), 10);
            tileset.set('tileSize', s);

            // PARSE <image> We assume there's only 1
            var image = t.getElementsByTagName('image')[0];
            tileset.set('sourceImage', path.join(path.dirname(this.filename), image.getAttribute('source')));

            this.tilesets.push(tileset);
        }

        // PARSE <layers>
        var layers = map.getElementsByTagName('layer');
        for (i = 0, len = layers.length; i < len; i++) {
            var l = layers[i];
            var data = l.getElementsByTagName('data')[0];
            var layer = TMXLayerInfo.create();

            layer.set('name', l.getAttribute('name'));
            if (l.getAttribute('visible') !== false) {
                layer.set('visible', true);
            } else {
                layer.set('visible', !!parseInt(l.getAttribute('visible'), 10));
            }

            s = {};
            s.width = parseInt(l.getAttribute('width'), 10);
            s.height = parseInt(l.getAttribute('height'), 10);
            layer.set('layerSize', s);

            var opacity = l.getAttribute('opacity');
            if (opacity === undefined) {
                layer.set('opacity', 255);
            } else {
                layer.set('opacity', 255 * parseFloat(opacity));
            }

            var x = parseInt(l.getAttribute('x'), 10),
                y = parseInt(l.getAttribute('y'), 10);
            if (isNaN(x)) {
                x = 0;
            }
            if (isNaN(y)) {
                y = 0;
            }
            layer.set('offset', ccp(x, y));


            // Firefox has a 4KB limit on node values. It will split larger
            // nodes up into multiple nodes. So, we'll stitch them back
            // together.
            var nodeValue = '';
            for (var j = 0, jen = data.childNodes.length; j < jen; j++) {
                nodeValue += data.childNodes[j].nodeValue;
            }

            // Unpack the tilemap data
            var compression = data.getAttribute('compression');
            switch (compression) {
            case 'gzip':
                layer.set('tiles', gzip.unzipBase64AsArray(nodeValue, 4));
                break;
                
            // Uncompressed
            case null:
            case '': 
                layer.set('tiles', base64.decodeAsArray(nodeValue, 4));
                break;

            default: 
                throw "Unsupported TMX Tile Map compression: " + compression;
            }

            this.layers.push(layer);
        }

        // TODO PARSE <tile>

        // PARSE <objectgroup>
        var objectgroups = map.getElementsByTagName('objectgroup');
        for (i = 0, len = objectgroups.length; i < len; i++) {
            var g = objectgroups[i],
                objectGroup = TMXObjectGroup.create();

            objectGroup.set('name', g.getAttribute('name'));
            
            var properties = g.querySelectorAll('objectgroup > properties property'),
                propertiesValue = {};
            
            for(j = 0; j < properties.length; j++) {
                var property = properties[j];
                if(property.getAttribute('name')) {
                    propertiesValue[property.getAttribute('name')] = property.getAttribute('value');
                }
            }
           
            objectGroup.set('properties', propertiesValue);

            var objectsArray = [],
                objects = g.querySelectorAll('object');

            for(j = 0; j < objects.length; j++) {
                var object = objects[j];
                var objectValue = {
                    x       : parseInt(object.getAttribute('x'), 10),
                    y       : parseInt(object.getAttribute('y'), 10),
                    width   : parseInt(object.getAttribute('width'), 10),
                    height  : parseInt(object.getAttribute('height'), 10)
                };
                if(object.getAttribute('name')) {
                    objectValue.name = object.getAttribute('name');
                }
                if(object.getAttribute('type')) {
                    objectValue.name = object.getAttribute('type');
                }
                properties = object.querySelectorAll('property');
                for(var k = 0; k < properties.length; k++) {
                    property = properties[k];
                    if(property.getAttribute('name')) {
                        objectValue[property.getAttribute('name')] = property.getAttribute('value');
                    }
                }
                objectsArray.push(objectValue);

            }
            objectGroup.set('objects', objectsArray);
            this.objectGroups.push(objectGroup);
        }
    }
});

exports.TMXMapInfo = TMXMapInfo;
exports.TMXLayerInfo = TMXLayerInfo;
exports.TMXTilesetInfo = TMXTilesetInfo;
exports.TMXObjectGroup = TMXObjectGroup;
}};
__resources__["/__builtin__/libs/geometry.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var RE_PAIR = /\{\s*([\d.\-]+)\s*,\s*([\d.\-]+)\s*\}/,
    RE_DOUBLE_PAIR = /\{\s*(\{[\s\d,.\-]+\})\s*,\s*(\{[\s\d,.\-]+\})\s*\}/;

/** @namespace */
var geometry = {
    /**
     * @class
     * A 2D point in space
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     */
    Point: function (x, y) {
        /**
         * X coordinate
         * @type Float
         */
        this.x = x;

        /**
         * Y coordinate
         * @type Float
         */
        this.y = y;
    },

    /**
     * @class
     * A 2D size
     *
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Size: function (w, h) {
        /**
         * Width
         * @type Float
         */
        this.width = w;

        /**
         * Height
         * @type Float
         */
        this.height = h;
    },

    /**
     * @class
     * A rectangle
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Rect: function (x, y, w, h) {
        /**
         * Coordinate in 2D space
         * @type {geometry.Point}
         */
        this.origin = new geometry.Point(x, y);

        /**
         * Size in 2D space
         * @type {geometry.Size}
         */
        this.size   = new geometry.Size(w, h);
    },

    /**
     * @class
     * Transform matrix
     *
     * @param {Float} a
     * @param {Float} b
     * @param {Float} c
     * @param {Float} d
     * @param {Float} tx
     * @param {Float} ty
     */
    TransformMatrix: function (a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    },

    /**
     * Creates a geometry.Point instance
     *
     * @param {Float} x X coordinate
     * @param {Float} y Y coordinate
     * @returns {geometry.Point} 
     */
    ccp: function (x, y) {
        return module.exports.pointMake(x, y);
    },

    /**
     * Add the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpAdd: function (p1, p2) {
        return geometry.ccp(p1.x + p2.x, p1.y + p2.y);
    },

    /**
     * Subtract the values of two points
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpSub: function (p1, p2) {
        return geometry.ccp(p1.x - p2.x, p1.y - p2.y);
    },

    /**
     * Muliply the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpMult: function (p1, p2) {
        return geometry.ccp(p1.x * p2.x, p1.y * p2.y);
    },


    /**
     * Invert the values of a geometry.Point
     *
     * @param {geometry.Point} p Point to invert
     * @returns {geometry.Point} New point
     */
    ccpNeg: function (p) {
        return geometry.ccp(-p.x, -p.y);
    },

    /**
     * Round values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpRound: function (p) {
        return geometry.ccp(Math.round(p.x), Math.round(p.y));
    },

    /**
     * Round up values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpCeil: function (p) {
        return geometry.ccp(Math.ceil(p.x), Math.ceil(p.y));
    },

    /**
     * Round down values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpFloor: function (p) {
        return geometry.ccp(Math.floor(p.x), Math.floor(p.y));
    },

    /**
     * A point at 0x0
     *
     * @returns {geometry.Point} New point at 0x0
     */
    PointZero: function () {
        return geometry.ccp(0, 0);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectMake: function (x, y, w, h) {
        return new geometry.Rect(x, y, w, h);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectFromString: function (str) {
        var matches = str.match(RE_DOUBLE_PAIR),
            p = geometry.pointFromString(matches[1]),
            s = geometry.sizeFromString(matches[2]);

        return geometry.rectMake(p.x, p.y, s.width, s.height);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeMake: function (w, h) {
        return new geometry.Size(w, h);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeFromString: function (str) {
        var matches = str.match(RE_PAIR),
            w = parseFloat(matches[1]),
            h = parseFloat(matches[2]);

        return geometry.sizeMake(w, h);
    },

    /**
     * @returns {geometry.Point}
     */
    pointMake: function (x, y) {
        return new geometry.Point(x, y);
    },

    /**
     * @returns {geometry.Point}
     */
    pointFromString: function (str) {
        var matches = str.match(RE_PAIR),
            x = parseFloat(matches[1]),
            y = parseFloat(matches[2]);

        return geometry.pointMake(x, y);
    },

    /**
     * @returns {Boolean}
     */
    rectContainsPoint: function (r, p) {
        return ((p.x >= r.origin.x && p.x <= r.origin.x + r.size.width) &&
                (p.y >= r.origin.y && p.y <= r.origin.y + r.size.height));
    },

    /**
     * Returns the smallest rectangle that contains the two source rectangles.
     *
     * @param {geometry.Rect} r1
     * @param {geometry.Rect} r2
     * @returns {geometry.Rect}
     */
    rectUnion: function (r1, r2) {
        var rect = new geometry.Rect(0, 0, 0, 0);

        rect.origin.x = Math.min(r1.origin.x, r2.origin.x);
        rect.origin.y = Math.min(r1.origin.y, r2.origin.y);
        rect.size.width = Math.max(r1.origin.x + r1.size.width, r2.origin.x + r2.size.width) - rect.origin.x;
        rect.size.height = Math.max(r1.origin.y + r1.size.height, r2.origin.y + r2.size.height) - rect.origin.y;

        return rect;
    },

    /**
     * @returns {Boolean}
     */
    rectOverlapsRect: function (r1, r2) {
        if (r1.origin.x + r1.size.width < r2.origin.x) {
            return false;
        }
        if (r2.origin.x + r2.size.width < r1.origin.x) {
            return false;
        }
        if (r1.origin.y + r1.size.height < r2.origin.y) {
            return false;
        }
        if (r2.origin.y + r2.size.height < r1.origin.y) {
            return false;
        }

        return true;
    },

    /**
     * Returns the overlapping portion of 2 rectangles
     *
     * @param {geometry.Rect} lhsRect First rectangle
     * @param {geometry.Rect} rhsRect Second rectangle
     * @returns {geometry.Rect} The overlapping portion of the 2 rectangles
     */
    rectIntersection: function (lhsRect, rhsRect) {

        var intersection = new geometry.Rect(
            Math.max(geometry.rectGetMinX(lhsRect), geometry.rectGetMinX(rhsRect)),
            Math.max(geometry.rectGetMinY(lhsRect), geometry.rectGetMinY(rhsRect)),
            0,
            0
        );

        intersection.size.width = Math.min(geometry.rectGetMaxX(lhsRect), geometry.rectGetMaxX(rhsRect)) - geometry.rectGetMinX(intersection);
        intersection.size.height = Math.min(geometry.rectGetMaxY(lhsRect), geometry.rectGetMaxY(rhsRect)) - geometry.rectGetMinY(intersection);

        return intersection;
    },

    /**
     * @returns {Boolean}
     */
    pointEqualToPoint: function (point1, point2) {
        return (point1.x == point2.x && point1.y == point2.y);
    },

    /**
     * @returns {Boolean}
     */
    sizeEqualToSize: function (size1, size2) {
        return (size1.width == size2.width && size1.height == size2.height);
    },

    /**
     * @returns {Boolean}
     */
    rectEqualToRect: function (rect1, rect2) {
        return (module.exports.sizeEqualToSize(rect1.size, rect2.size) && module.exports.pointEqualToPoint(rect1.origin, rect2.origin));
    },

    /**
     * @returns {Float}
     */
    rectGetMinX: function (rect) {
        return rect.origin.x;
    },

    /**
     * @returns {Float}
     */
    rectGetMinY: function (rect) {
        return rect.origin.y;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxX: function (rect) {
        return rect.origin.x + rect.size.width;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxY: function (rect) {
        return rect.origin.y + rect.size.height;
    },

    boundingRectMake: function (p1, p2, p3, p4) {
        var minX = Math.min(p1.x, p2.x, p3.x, p4.x);
        var minY = Math.min(p1.y, p2.y, p3.y, p4.y);
        var maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
        var maxY = Math.max(p1.y, p2.y, p3.y, p4.y);

        return new geometry.Rect(minX, minY, (maxX - minX), (maxY - minY));
    },

    /**
     * @returns {geometry.Point}
     */
    pointApplyAffineTransform: function (point, t) {

        /*
        aPoint.x * aTransform.a + aPoint.y * aTransform.c + aTransform.tx,
        aPoint.x * aTransform.b + aPoint.y * aTransform.d + aTransform.ty
        */

        return new geometry.Point(t.a * point.x + t.c * point.y + t.tx, t.b * point.x + t.d * point.y + t.ty);

    },

    /**
     * Apply a transform matrix to a rectangle
     *
     * @param {geometry.Rect} rect Rectangle to transform
     * @param {geometry.TransformMatrix} trans TransformMatrix to apply to rectangle
     * @returns {geometry.Rect} A new transformed rectangle
     */
    rectApplyAffineTransform: function (rect, trans) {

        var p1 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMinY(rect));
        var p2 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMinY(rect));
        var p3 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMaxY(rect));
        var p4 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMaxY(rect));

        p1 = geometry.pointApplyAffineTransform(p1, trans);
        p2 = geometry.pointApplyAffineTransform(p2, trans);
        p3 = geometry.pointApplyAffineTransform(p3, trans);
        p4 = geometry.pointApplyAffineTransform(p4, trans);

        return geometry.boundingRectMake(p1, p2, p3, p4);
    },

    /**
     * Inverts a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to invert
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformInvert: function (trans) {
        var determinant = 1 / (trans.a * trans.d - trans.b * trans.c);

        return new geometry.TransformMatrix(
            determinant * trans.d,
            -determinant * trans.b,
            -determinant * trans.c,
            determinant * trans.a,
            determinant * (trans.c * trans.ty - trans.d * trans.tx),
            determinant * (trans.b * trans.tx - trans.a * trans.ty)
        );
    },

    /**
     * Multiply 2 transform matrices together
     * @param {geometry.TransformMatrix} lhs Left matrix
     * @param {geometry.TransformMatrix} rhs Right matrix
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformConcat: function (lhs, rhs) {
        return new geometry.TransformMatrix(
            lhs.a * rhs.a + lhs.b * rhs.c,
            lhs.a * rhs.b + lhs.b * rhs.d,
            lhs.c * rhs.a + lhs.d * rhs.c,
            lhs.c * rhs.b + lhs.d * rhs.d,
            lhs.tx * rhs.a + lhs.ty * rhs.c + rhs.tx,
            lhs.tx * rhs.b + lhs.ty * rhs.d + rhs.ty
        );
    },

    /**
     * @returns {Float}
     */
    degreesToRadians: function (angle) {
        return angle / 180.0 * Math.PI;
    },

    /**
     * @returns {Float}
     */
    radiansToDegrees: function (angle) {
        return angle * (180.0 / Math.PI);
    },

    /**
     * Translate (move) a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to translate
     * @param {Float} tx Amount to translate along X axis
     * @param {Float} ty Amount to translate along Y axis
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformTranslate: function (trans, tx, ty) {
        var newTrans = util.copy(trans);
        newTrans.tx = trans.tx + trans.a * tx + trans.c * ty;
        newTrans.ty = trans.ty + trans.b * tx + trans.d * ty;
        return newTrans;
    },

    /**
     * Rotate a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to rotate
     * @param {Float} angle Angle in radians
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformRotate: function (trans, angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle);

        return new geometry.TransformMatrix(
            trans.a * cos + trans.c * sin,
            trans.b * cos + trans.d * sin,
            trans.c * cos - trans.a * sin,
            trans.d * cos - trans.b * sin,
            trans.tx,
            trans.ty
        );
    },

    /**
     * Scale a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to scale
     * @param {Float} sx X scale factor
     * @param {Float} [sy=sx] Y scale factor
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformScale: function (trans, sx, sy) {
        if (sy === undefined) {
            sy = sx;
        }

        return new geometry.TransformMatrix(trans.a * sx, trans.b * sx, trans.c * sy, trans.d * sy, trans.tx, trans.ty);
    },

    /**
     * @returns {geometry.TransformMatrix} identity matrix
     */
    affineTransformIdentity: function () {
        return new geometry.TransformMatrix(1, 0, 0, 1, 0, 0);
    }
};

module.exports = geometry;

}};
__resources__["/__builtin__/libs/gzip.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * @fileoverview 
 */

/** @ignore */
var JXG = require('./JXGUtil');

/**
 * @namespace
 * Wrappers around JXG's GZip utils
 * @see JXG.Util
 */
var gzip = {
    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @returns {String} Unpacked byte string
     */
    unzip: function(input) {
        return (new JXG.Util.Unzip(input)).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @returns {String} Unpacked byte string
     */
    unzipBase64: function(input) {
        return (new JXG.Util.Unzip(JXG.Util.Base64.decodeAsArray(input))).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipBase64AsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzipBase64(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipAsArray: function (input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzip(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    }

};

module.exports = gzip;

}};
__resources__["/__builtin__/libs/JXGUtil.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
    Copyright 2008,2009
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @fileoverview Utilities for uncompressing and base64 decoding
 */

/** @namespace */
var JXG = {};

/**
  * @class Util class
  * Class for gunzipping, unzipping and base64 decoding of files.
  * It is used for reading GEONExT, Geogebra and Intergeo files.
  *
  * Only Huffman codes are decoded in gunzip.
  * The code is based on the source code for gunzip.c by Pasi Ojala 
  * @see <a href="http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c">http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c</a>
  * @see <a href="http://www.cs.tut.fi/~albert">http://www.cs.tut.fi/~albert</a>
  */
JXG.Util = {};
                                 
/**
 * Unzip zip files
 */
JXG.Util.Unzip = function (barray){
    var outputArr = [],
        output = "",
        debug = false,
        gpflags,
        files = 0,
        unzipped = [],
        crc,
        buf32k = new Array(32768),
        bIdx = 0,
        modeZIP=false,

        CRC, SIZE,
    
        bitReverse = [
        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
    ],
    
    cplens = [
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ],

    cplext = [
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
    ], /* 99==invalid */

    cpdist = [
        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,
        0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,
        0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,
        0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001
    ],

    cpdext = [
        0,  0,  0,  0,  1,  1,  2,  2,
        3,  3,  4,  4,  5,  5,  6,  6,
        7,  7,  8,  8,  9,  9, 10, 10,
        11, 11, 12, 12, 13, 13
    ],
    
    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
    
    bA = barray,

    bytepos=0,
    bitpos=0,
    bb = 1,
    bits=0,
    
    NAMEMAX = 256,
    
    nameBuf = [],
    
    fileout;
    
    function readByte(){
        bits+=8;
        if (bytepos<bA.length){
            //if (debug)
            //    document.write(bytepos+": "+bA[bytepos]+"<br>");
            return bA[bytepos++];
        } else
            return -1;
    };

    function byteAlign(){
        bb = 1;
    };
    
    function readBit(){
        var carry;
        bits++;
        carry = (bb & 1);
        bb >>= 1;
        if (bb==0){
            bb = readByte();
            carry = (bb & 1);
            bb = (bb>>1) | 0x80;
        }
        return carry;
    };

    function readBits(a) {
        var res = 0,
            i = a;
    
        while(i--) {
            res = (res<<1) | readBit();
        }
        if(a) {
            res = bitReverse[res]>>(8-a);
        }
        return res;
    };
        
    function flushBuffer(){
        //document.write('FLUSHBUFFER:'+buf32k);
        bIdx = 0;
    };
    function addBuffer(a){
        SIZE++;
        //CRC=updcrc(a,crc);
        buf32k[bIdx++] = a;
        outputArr.push(String.fromCharCode(a));
        //output+=String.fromCharCode(a);
        if(bIdx==0x8000){
            //document.write('ADDBUFFER:'+buf32k);
            bIdx=0;
        }
    };
    
    function HufNode() {
        this.b0=0;
        this.b1=0;
        this.jump = null;
        this.jumppos = -1;
    };

    var LITERALS = 288;
    
    var literalTree = new Array(LITERALS);
    var distanceTree = new Array(32);
    var treepos=0;
    var Places = null;
    var Places2 = null;
    
    var impDistanceTree = new Array(64);
    var impLengthTree = new Array(64);
    
    var len = 0;
    var fpos = new Array(17);
    fpos[0]=0;
    var flens;
    var fmax;
    
    function IsPat() {
        while (1) {
            if (fpos[len] >= fmax)
                return -1;
            if (flens[fpos[len]] == len)
                return fpos[len]++;
            fpos[len]++;
        }
    };

    function Rec() {
        var curplace = Places[treepos];
        var tmp;
        if (debug)
    		document.write("<br>len:"+len+" treepos:"+treepos);
        if(len==17) { //war 17
            return -1;
        }
        treepos++;
        len++;
    	
        tmp = IsPat();
        if (debug)
        	document.write("<br>IsPat "+tmp);
        if(tmp >= 0) {
            curplace.b0 = tmp;    /* leaf cell for 0-bit */
            if (debug)
            	document.write("<br>b0 "+curplace.b0);
        } else {
        /* Not a Leaf cell */
        curplace.b0 = 0x8000;
        if (debug)
        	document.write("<br>b0 "+curplace.b0);
        if(Rec())
            return -1;
        }
        tmp = IsPat();
        if(tmp >= 0) {
            curplace.b1 = tmp;    /* leaf cell for 1-bit */
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = null;    /* Just for the display routine */
        } else {
            /* Not a Leaf cell */
            curplace.b1 = 0x8000;
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = Places[treepos];
            curplace.jumppos = treepos;
            if(Rec())
                return -1;
        }
        len--;
        return 0;
    };

    function CreateTree(currentTree, numval, lengths, show) {
        var i;
        /* Create the Huffman decode tree/table */
        //document.write("<br>createtree<br>");
        if (debug)
        	document.write("currentTree "+currentTree+" numval "+numval+" lengths "+lengths+" show "+show);
        Places = currentTree;
        treepos=0;
        flens = lengths;
        fmax  = numval;
        for (i=0;i<17;i++)
            fpos[i] = 0;
        len = 0;
        if(Rec()) {
            //fprintf(stderr, "invalid huffman tree\n");
            if (debug)
            	alert("invalid huffman tree\n");
            return -1;
        }
        if (debug){
        	document.write('<br>Tree: '+Places.length);
        	for (var a=0;a<32;a++){
            	document.write("Places["+a+"].b0="+Places[a].b0+"<br>");
            	document.write("Places["+a+"].b1="+Places[a].b1+"<br>");
        	}
        }

        return 0;
    };
    
    function DecodeValue(currentTree) {
        var len, i,
            xtreepos=0,
            X = currentTree[xtreepos],
            b;

        /* decode one symbol of the data */
        while(1) {
            b=readBit();
            if (debug)
            	document.write("b="+b);
            if(b) {
                if(!(X.b1 & 0x8000)){
                	if (debug)
                    	document.write("ret1");
                    return X.b1;    /* If leaf node, return data */
                }
                X = X.jump;
                len = currentTree.length;
                for (i=0;i<len;i++){
                    if (currentTree[i]===X){
                        xtreepos=i;
                        break;
                    }
                }
                //xtreepos++;
            } else {
                if(!(X.b0 & 0x8000)){
                	if (debug)
                    	document.write("ret2");
                    return X.b0;    /* If leaf node, return data */
                }
                //X++; //??????????????????
                xtreepos++;
                X = currentTree[xtreepos];
            }
        }
        if (debug)
        	document.write("ret3");
        return -1;
    };
    
    function DeflateLoop() {
    var last, c, type, i, len;

    do {
        /*if((last = readBit())){
            fprintf(errfp, "Last Block: ");
        } else {
            fprintf(errfp, "Not Last Block: ");
        }*/
        last = readBit();
        type = readBits(2);
        switch(type) {
            case 0:
            	if (debug)
                	alert("Stored\n");
                break;
            case 1:
            	if (debug)
                	alert("Fixed Huffman codes\n");
                break;
            case 2:
            	if (debug)
                	alert("Dynamic Huffman codes\n");
                break;
            case 3:
            	if (debug)
                	alert("Reserved block type!!\n");
                break;
            default:
            	if (debug)
                	alert("Unexpected value %d!\n", type);
                break;
        }

        if(type==0) {
            var blockLen, cSum;

            // Stored 
            byteAlign();
            blockLen = readByte();
            blockLen |= (readByte()<<8);

            cSum = readByte();
            cSum |= (readByte()<<8);

            if(((blockLen ^ ~cSum) & 0xffff)) {
                document.write("BlockLen checksum mismatch\n");
            }
            while(blockLen--) {
                c = readByte();
                addBuffer(c);
            }
        } else if(type==1) {
            var j;

            /* Fixed Huffman tables -- fixed decode routine */
            while(1) {
            /*
                256    0000000        0
                :   :     :
                279    0010111        23
                0   00110000    48
                :    :      :
                143    10111111    191
                280 11000000    192
                :    :      :
                287 11000111    199
                144    110010000    400
                :    :       :
                255    111111111    511
    
                Note the bit order!
                */

            j = (bitReverse[readBits(7)]>>1);
            if(j > 23) {
                j = (j<<1) | readBit();    /* 48..255 */

                if(j > 199) {    /* 200..255 */
                    j -= 128;    /*  72..127 */
                    j = (j<<1) | readBit();        /* 144..255 << */
                } else {        /*  48..199 */
                    j -= 48;    /*   0..151 */
                    if(j > 143) {
                        j = j+136;    /* 280..287 << */
                        /*   0..143 << */
                    }
                }
            } else {    /*   0..23 */
                j += 256;    /* 256..279 << */
            }
            if(j < 256) {
                addBuffer(j);
                //document.write("out:"+String.fromCharCode(j));
                /*fprintf(errfp, "@%d %02x\n", SIZE, j);*/
            } else if(j == 256) {
                /* EOF */
                break;
            } else {
                var len, dist;

                j -= 256 + 1;    /* bytes + EOF */
                len = readBits(cplext[j]) + cplens[j];

                j = bitReverse[readBits(5)]>>3;
                if(cpdext[j] > 8) {
                    dist = readBits(8);
                    dist |= (readBits(cpdext[j]-8)<<8);
                } else {
                    dist = readBits(cpdext[j]);
                }
                dist += cpdist[j];

                /*fprintf(errfp, "@%d (l%02x,d%04x)\n", SIZE, len, dist);*/
                for(j=0;j<len;j++) {
                    var c = buf32k[(bIdx - dist) & 0x7fff];
                    addBuffer(c);
                }
            }
            } // while
        } else if(type==2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288+32);    // "static" just to preserve stack
    
            // Dynamic Huffman tables 
    
            literalCodes = 257 + readBits(5);
            distCodes = 1 + readBits(5);
            lenCodes = 4 + readBits(4);
            //document.write("<br>param: "+literalCodes+" "+distCodes+" "+lenCodes+"<br>");
            for(j=0; j<19; j++) {
                ll[j] = 0;
            }
    
            // Get the decode tree code lengths
    
            //document.write("<br>");
            for(j=0; j<lenCodes; j++) {
                ll[border[j]] = readBits(3);
                //document.write(ll[border[j]]+" ");
            }
            //fprintf(errfp, "\n");
            //document.write('<br>ll:'+ll);
            len = distanceTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            if(CreateTree(distanceTree, 19, ll, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug){
            	document.write("<br>distanceTree");
            	for(var a=0;a<distanceTree.length;a++){
                	document.write("<br>"+distanceTree[a].b0+" "+distanceTree[a].b1+" "+distanceTree[a].jump+" "+distanceTree[a].jumppos);
                	/*if (distanceTree[a].jumppos!=-1)
                    	document.write(" "+distanceTree[a].jump.b0+" "+distanceTree[a].jump.b1);
                	*/
            	}
            }
            //document.write('<BR>tree created');
    
            //read in literal and distance code lengths
            n = literalCodes + distCodes;
            i = 0;
            var z=-1;
            if (debug)
            	document.write("<br>n="+n+" bits: "+bits+"<br>");
            while(i < n) {
                z++;
                j = DecodeValue(distanceTree);
                if (debug)
                	document.write("<br>"+z+" i:"+i+" decode: "+j+"    bits "+bits+"<br>");
                if(j<16) {    // length of code in bits (0..15)
                       ll[i++] = j;
                } else if(j==16) {    // repeat last length 3 to 6 times 
                       var l;
                    j = 3 + readBits(2);
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    l = i ? ll[i-1] : 0;
                    while(j--) {
                        ll[i++] = l;
                    }
                } else {
                    if(j==17) {        // 3 to 10 zero length codes
                        j = 3 + readBits(3);
                    } else {        // j == 18: 11 to 138 zero length codes 
                        j = 11 + readBits(7);
                    }
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    while(j--) {
                        ll[i++] = 0;
                    }
                }
            }
            /*for(j=0; j<literalCodes+distCodes; j++) {
                //fprintf(errfp, "%d ", ll[j]);
                if ((j&7)==7)
                    fprintf(errfp, "\n");
            }
            fprintf(errfp, "\n");*/
            // Can overwrite tree decode tree as it is not used anymore
            len = literalTree.length;
            for (i=0; i<len; i++)
                literalTree[i]=new HufNode();
            if(CreateTree(literalTree, literalCodes, ll, 0)) {
                flushBuffer();
                return 1;
            }
            len = literalTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            var ll2 = new Array();
            for (i=literalCodes; i <ll.length; i++){
                ll2[i-literalCodes]=ll[i];
            }    
            if(CreateTree(distanceTree, distCodes, ll2, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug)
           		document.write("<br>literalTree");
            while(1) {
                j = DecodeValue(literalTree);
                if(j >= 256) {        // In C64: if carry set
                    var len, dist;
                    j -= 256;
                    if(j == 0) {
                        // EOF
                        break;
                    }
                    j--;
                    len = readBits(cplext[j]) + cplens[j];
    
                    j = DecodeValue(distanceTree);
                    if(cpdext[j] > 8) {
                        dist = readBits(8);
                        dist |= (readBits(cpdext[j]-8)<<8);
                    } else {
                        dist = readBits(cpdext[j]);
                    }
                    dist += cpdist[j];
                    while(len--) {
                        var c = buf32k[(bIdx - dist) & 0x7fff];
                        addBuffer(c);
                    }
                } else {
                    addBuffer(j);
                }
            }
        }
    } while(!last);
    flushBuffer();

    byteAlign();
    return 0;
};

JXG.Util.Unzip.prototype.unzipFile = function(name) {
    var i;
	this.unzip();
	//alert(unzipped[0][1]);
	for (i=0;i<unzipped.length;i++){
		if(unzipped[i][1]==name) {
			return unzipped[i][0];
		}
	}
	
  };
    
    
JXG.Util.Unzip.prototype.unzip = function() {
	//convertToByteArray(input);
	if (debug)
		alert(bA);
	/*for (i=0;i<bA.length*8;i++){
		document.write(readBit());
		if ((i+1)%8==0)
			document.write(" ");
	}*/
	/*for (i=0;i<bA.length;i++){
		document.write(readByte()+" ");
		if ((i+1)%8==0)
			document.write(" ");
	}
	for (i=0;i<bA.length;i++){
		document.write(bA[i]+" ");
		if ((i+1)%16==0)
			document.write("<br>");
	}	
	*/
	//alert(bA);
	nextFile();
	return unzipped;
  };
    
 function nextFile(){
 	if (debug)
 		alert("NEXTFILE");
 	outputArr = [];
 	var tmp = [];
 	modeZIP = false;
	tmp[0] = readByte();
	tmp[1] = readByte();
	if (debug)
		alert("type: "+tmp[0]+" "+tmp[1]);
	if (tmp[0] == parseInt("78",16) && tmp[1] == parseInt("da",16)){ //GZIP
		if (debug)
			alert("GEONExT-GZIP");
		DeflateLoop();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "geonext.gxt";
    	files++;
	}
	if (tmp[0] == parseInt("1f",16) && tmp[1] == parseInt("8b",16)){ //GZIP
		if (debug)
			alert("GZIP");
		//DeflateLoop();
		skipdir();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "file";
    	files++;
	}
	if (tmp[0] == parseInt("50",16) && tmp[1] == parseInt("4b",16)){ //ZIP
		modeZIP = true;
		tmp[2] = readByte();
		tmp[3] = readByte();
		if (tmp[2] == parseInt("3",16) && tmp[3] == parseInt("4",16)){
			//MODE_ZIP
			tmp[0] = readByte();
			tmp[1] = readByte();
			if (debug)
				alert("ZIP-Version: "+tmp[1]+" "+tmp[0]/10+"."+tmp[0]%10);
			
			gpflags = readByte();
			gpflags |= (readByte()<<8);
			if (debug)
				alert("gpflags: "+gpflags);
			
			var method = readByte();
			method |= (readByte()<<8);
			if (debug)
				alert("method: "+method);
			
			readByte();
			readByte();
			readByte();
			readByte();
			
			var crc = readByte();
			crc |= (readByte()<<8);
			crc |= (readByte()<<16);
			crc |= (readByte()<<24);
			
			var compSize = readByte();
			compSize |= (readByte()<<8);
			compSize |= (readByte()<<16);
			compSize |= (readByte()<<24);
			
			var size = readByte();
			size |= (readByte()<<8);
			size |= (readByte()<<16);
			size |= (readByte()<<24);
			
			if (debug)
				alert("local CRC: "+crc+"\nlocal Size: "+size+"\nlocal CompSize: "+compSize);
			
			var filelen = readByte();
			filelen |= (readByte()<<8);
			
			var extralen = readByte();
			extralen |= (readByte()<<8);
			
			if (debug)
				alert("filelen "+filelen);
			i = 0;
			nameBuf = [];
			while (filelen--){ 
				var c = readByte();
				if (c == "/" | c ==":"){
					i = 0;
				} else if (i < NAMEMAX-1)
					nameBuf[i++] = String.fromCharCode(c);
			}
			if (debug)
				alert("nameBuf: "+nameBuf);
			
			//nameBuf[i] = "\0";
			if (!fileout)
				fileout = nameBuf;
			
			var i = 0;
			while (i < extralen){
				c = readByte();
				i++;
			}
				
			CRC = 0xffffffff;
			SIZE = 0;
			
			if (size = 0 && fileOut.charAt(fileout.length-1)=="/"){
				//skipdir
				if (debug)
					alert("skipdir");
			}
			if (method == 8){
				DeflateLoop();
				if (debug)
					alert(outputArr.join(''));
				unzipped[files] = new Array(2);
				unzipped[files][0] = outputArr.join('');
    			unzipped[files][1] = nameBuf.join('');
    			files++;
				//return outputArr.join('');
			}
			skipdir();
		}
	}
 };
	
function skipdir(){
    var crc, 
        tmp = [],
        compSize, size, os, i, c;
    
	if ((gpflags & 8)) {
		tmp[0] = readByte();
		tmp[1] = readByte();
		tmp[2] = readByte();
		tmp[3] = readByte();
		
		if (tmp[0] == parseInt("50",16) && 
            tmp[1] == parseInt("4b",16) && 
            tmp[2] == parseInt("07",16) && 
            tmp[3] == parseInt("08",16))
        {
            crc = readByte();
            crc |= (readByte()<<8);
            crc |= (readByte()<<16);
            crc |= (readByte()<<24);
		} else {
			crc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);
		}
		
		compSize = readByte();
		compSize |= (readByte()<<8);
		compSize |= (readByte()<<16);
		compSize |= (readByte()<<24);
		
		size = readByte();
		size |= (readByte()<<8);
		size |= (readByte()<<16);
		size |= (readByte()<<24);
		
		if (debug)
			alert("CRC:");
	}

	if (modeZIP)
		nextFile();
	
	tmp[0] = readByte();
	if (tmp[0] != 8) {
		if (debug)
			alert("Unknown compression method!");
        return 0;	
	}
	
	gpflags = readByte();
	if (debug){
		if ((gpflags & ~(parseInt("1f",16))))
			alert("Unknown flags set!");
	}
	
	readByte();
	readByte();
	readByte();
	readByte();
	
	readByte();
	os = readByte();
	
	if ((gpflags & 4)){
		tmp[0] = readByte();
		tmp[2] = readByte();
		len = tmp[0] + 256*tmp[1];
		if (debug)
			alert("Extra field size: "+len);
		for (i=0;i<len;i++)
			readByte();
	}
	
	if ((gpflags & 8)){
		i=0;
		nameBuf=[];
		while (c=readByte()){
			if(c == "7" || c == ":")
				i=0;
			if (i<NAMEMAX-1)
				nameBuf[i++] = c;
		}
		//nameBuf[i] = "\0";
		if (debug)
			alert("original file name: "+nameBuf);
	}
		
	if ((gpflags & 16)){
		while (c=readByte()){
			//FILE COMMENT
		}
	}
	
	if ((gpflags & 2)){
		readByte();
		readByte();
	}
	
	DeflateLoop();
	
	crc = readByte();
	crc |= (readByte()<<8);
	crc |= (readByte()<<16);
	crc |= (readByte()<<24);
	
	size = readByte();
	size |= (readByte()<<8);
	size |= (readByte()<<16);
	size |= (readByte()<<24);
	
	if (modeZIP)
		nextFile();
	
};

};

/**
*  Base64 encoding / decoding
*  @see <a href="http://www.webtoolkit.info/">http://www.webtoolkit.info/</A>
*/
JXG.Util.Base64 = {

    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode : function (input) {
        var output = [],
            chr1, chr2, chr3, enc1, enc2, enc3, enc4,
            i = 0;

        input = JXG.Util.Base64._utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output.push([this._keyStr.charAt(enc1),
                         this._keyStr.charAt(enc2),
                         this._keyStr.charAt(enc3),
                         this._keyStr.charAt(enc4)].join(''));
        }

        return output.join('');
    },

    // public method for decoding
    decode : function (input, utf8) {
        var output = [],
            chr1, chr2, chr3,
            enc1, enc2, enc3, enc4,
            i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output.push(String.fromCharCode(chr1));

            if (enc3 != 64) {
                output.push(String.fromCharCode(chr2));
            }
            if (enc4 != 64) {
                output.push(String.fromCharCode(chr3));
            }
        }
        
        output = output.join(''); 
        
        if (utf8) {
            output = JXG.Util.Base64._utf8_decode(output);
        }
        return output;

    },

    // private method for UTF-8 encoding
    _utf8_encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
        var string = [],
            i = 0,
            c = 0, c2 = 0, c3 = 0;

        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string.push(String.fromCharCode(c));
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                i += 3;
            }
        }
        return string.join('');
    },
    
    _destrip: function (stripped, wrap){
        var lines = [], lineno, i,
            destripped = [];
        
        if (wrap==null) 
            wrap = 76;
            
        stripped.replace(/ /g, "");
        lineno = stripped.length / wrap;
        for (i = 0; i < lineno; i++)
            lines[i]=stripped.substr(i * wrap, wrap);
        if (lineno != stripped.length / wrap)
            lines[lines.length]=stripped.substr(lineno * wrap, stripped.length-(lineno * wrap));
            
        for (i = 0; i < lines.length; i++)
            destripped.push(lines[i]);
        return destripped.join('\n');
    },
    
    decodeAsArray: function (input){
        var dec = this.decode(input),
            ar = [], i;
        for (i=0;i<dec.length;i++){
            ar[i]=dec.charCodeAt(i);
        }
        return ar;
    },
    
    decodeGEONExT : function (input) {
        return decodeAsArray(destrip(input),false);
    }
};

/**
 * @private
 */
JXG.Util.asciiCharCodeAt = function(str,i){
	var c = str.charCodeAt(i);
	if (c>255){
    	switch (c) {
			case 8364: c=128;
	    	break;
	    	case 8218: c=130;
	    	break;
	    	case 402: c=131;
	    	break;
	    	case 8222: c=132;
	    	break;
	    	case 8230: c=133;
	    	break;
	    	case 8224: c=134;
	    	break;
	    	case 8225: c=135;
	    	break;
	    	case 710: c=136;
	    	break;
	    	case 8240: c=137;
	    	break;
	    	case 352: c=138;
	    	break;
	    	case 8249: c=139;
	    	break;
	    	case 338: c=140;
	    	break;
	    	case 381: c=142;
	    	break;
	    	case 8216: c=145;
	    	break;
	    	case 8217: c=146;
	    	break;
	    	case 8220: c=147;
	    	break;
	    	case 8221: c=148;
	    	break;
	    	case 8226: c=149;
	    	break;
	    	case 8211: c=150;
	    	break;
	    	case 8212: c=151;
	    	break;
	    	case 732: c=152;
	    	break;
	    	case 8482: c=153;
	    	break;
	    	case 353: c=154;
	    	break;
	    	case 8250: c=155;
	    	break;
	    	case 339: c=156;
	    	break;
	    	case 382: c=158;
	    	break;
	    	case 376: c=159;
	    	break;
	    	default:
	    	break;
	    }
	}
	return c;
};

/**
 * Decoding string into utf-8
 * @param {String} string to decode
 * @return {String} utf8 decoded string
 */
JXG.Util.utf8Decode = function(utftext) {
  var string = [];
  var i = 0;
  var c = 0, c1 = 0, c2 = 0;

  while ( i < utftext.length ) {
    c = utftext.charCodeAt(i);

    if (c < 128) {
      string.push(String.fromCharCode(c));
      i++;
    } else if((c > 191) && (c < 224)) {
      c2 = utftext.charCodeAt(i+1);
      string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
      i += 2;
    } else {
      c2 = utftext.charCodeAt(i+1);
      c3 = utftext.charCodeAt(i+2);
      string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
      i += 3;
    }
  };
  return string.join('');
};

// Added to exports for Cocos2d
module.exports = JXG;

}};
__resources__["/__builtin__/libs/Plist.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * XML Node types
 */
var ELEMENT_NODE                = 1,
    ATTRIBUTE_NODE              = 2,
    TEXT_NODE                   = 3,
    CDATA_SECTION_NODE          = 4,
    ENTITY_REFERENCE_NODE       = 5,
    ENTITY_NODE                 = 6,
    PROCESSING_INSTRUCTION_NODE = 7,
    COMMENT_NODE                = 8,
    DOCUMENT_NODE               = 9,
    DOCUMENT_TYPE_NODE          = 10,
    DOCUMENT_FRAGMENT_NODE      = 11,
    NOTATION_NODE               = 12;


var Plist = BObject.extend (/** @lends Plist# */{
    /**
     * The unserialized data inside the Plist file
     * @type Object
     */
    data: null,

    /**
     * An object representation of an XML Property List file
     *
     * @constructs
     * @extends BObject
     * @param {Options} opts Options
     * @config {String} [file] The path to a .plist file
     * @config {String} [data] The contents of a .plist file
     */
    init: function(opts) {
        var file = opts['file'],
            data = opts['data'];

        if (file && !data) {
            data = resource(file);
        }


        var parser = new DOMParser(),
            doc = parser.parseFromString(data, 'text/xml'),
            plist = doc.documentElement;

        if (plist.tagName != 'plist') {
            throw "Not a plist file";
        }


        // Get first real node
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType == ELEMENT_NODE) {
                break;
            }
        }

        this.set('data', this.parseNode_(node));
    },


    /**
     * @private
     * Parses an XML node inside the Plist file
     * @returns {Object/Array/String/Integer/Float} A JS representation of the node value
     */
    parseNode_: function(node) {
        var data = null;
        switch(node.tagName) {
        case 'dict':
            data = this.parseDict_(node); 
            break;
        case 'array':
            data = this.parseArray_(node); 
            break;
        case 'string':
            // FIXME - This needs to handle Firefox's 4KB nodeValue limit
            data = node.firstChild.nodeValue;
            break
        case 'false':
            data = false;
            break
        case 'true':
            data = true;
            break
        case 'real':
            data = parseFloat(node.firstChild.nodeValue);
            break
        case 'integer':
            data = parseInt(node.firstChild.nodeValue, 10);
            break
        }

        return data;
    },

    /**
     * @private
     * Parses a <dict> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Object} A simple key/value JS Object representing the <dict>
     */
    parseDict_: function(node) {
        var data = {};

        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            // Grab the key, next noe should be the value
            if (child.tagName == 'key') {
                key = child.firstChild.nodeValue;
            } else {
                // Parse the value node
                data[key] = this.parseNode_(child);
            }
        }


        return data;
    },

    /**
     * @private
     * Parses an <array> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Array} A simple JS Array representing the <array>
     */
    parseArray_: function(node) {
        var data = [];

        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            data.push(this.parseNode_(child));
        }

        return data;
    }
});


exports.Plist = Plist;

}};
__resources__["/__builtin__/libs/qunit.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
 * QUnit - A JavaScript Unit Testing Framework
 * 
 * http://docs.jquery.com/QUnit
 *
 * Copyright (c) 2011 John Resig, Jörn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * or GPL (GPL-LICENSE.txt) licenses.
 */

(function(window) {

var defined = {
	setTimeout: typeof window.setTimeout !== "undefined",
	sessionStorage: (function() {
		try {
			return !!sessionStorage.getItem;
		} catch(e){
			return false;
		}
  })()
}

var testId = 0;

var Test = function(name, testName, expected, testEnvironmentArg, async, callback) {
	this.name = name;
	this.testName = testName;
	this.expected = expected;
	this.testEnvironmentArg = testEnvironmentArg;
	this.async = async;
	this.callback = callback;
	this.assertions = [];
};
Test.prototype = {
	init: function() {
		var tests = id("qunit-tests");
		if (tests) {
			var b = document.createElement("strong");
				b.innerHTML = "Running " + this.name;
			var li = document.createElement("li");
				li.appendChild( b );
				li.id = this.id = "test-output" + testId++;
			tests.appendChild( li );
		}
	},
	setup: function() {
		if (this.module != config.previousModule) {
			if ( config.previousModule ) {
				QUnit.moduleDone( {
					name: config.previousModule,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all
				} );
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0 };
			QUnit.moduleStart( {
				name: this.module
			} );
		}

		config.current = this;
		this.testEnvironment = extend({
			setup: function() {},
			teardown: function() {}
		}, this.moduleTestEnvironment);
		if (this.testEnvironmentArg) {
			extend(this.testEnvironment, this.testEnvironmentArg);
		}

		QUnit.testStart( {
			name: this.testName
		} );

		// allow utility functions to access the current test environment
		// TODO why??
		QUnit.current_testEnvironment = this.testEnvironment;
		
		try {
			if ( !config.pollution ) {
				saveGlobal();
			}

			this.testEnvironment.setup.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Setup failed on " + this.testName + ": " + e.message );
		}
	},
	run: function() {
		if ( this.async ) {
			QUnit.stop();
		}

		if ( config.notrycatch ) {
			this.callback.call(this.testEnvironment);
			return;
		}
		try {
			this.callback.call(this.testEnvironment);
		} catch(e) {
			fail("Test " + this.testName + " died, exception and test follows", e, this.callback);
			QUnit.ok( false, "Died on test #" + (this.assertions.length + 1) + ": " + e.message + " - " + QUnit.jsDump.parse(e) );
			// else next test will carry the responsibility
			saveGlobal();

			// Restart the tests if they're blocking
			if ( config.blocking ) {
				start();
			}
		}
	},
	teardown: function() {
		try {
			checkPollution();
			this.testEnvironment.teardown.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Teardown failed on " + this.testName + ": " + e.message );
		}
	},
	finish: function() {
		if ( this.expected && this.expected != this.assertions.length ) {
			QUnit.ok( false, "Expected " + this.expected + " assertions, but " + this.assertions.length + " were run" );
		}
		
		var good = 0, bad = 0,
			tests = id("qunit-tests");

		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		if ( tests ) {
			var ol  = document.createElement("ol");

			for ( var i = 0; i < this.assertions.length; i++ ) {
				var assertion = this.assertions[i];

				var li = document.createElement("li");
				li.className = assertion.result ? "pass" : "fail";
				li.innerHTML = assertion.message || (assertion.result ? "okay" : "failed");
				ol.appendChild( li );

				if ( assertion.result ) {
					good++;
				} else {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}

			// store result when possible
			defined.sessionStorage && sessionStorage.setItem("qunit-" + this.testName, bad);

			if (bad == 0) {
				ol.style.display = "none";
			}

			var b = document.createElement("strong");
			b.innerHTML = this.name + " <b class='counts'>(<b class='failed'>" + bad + "</b>, <b class='passed'>" + good + "</b>, " + this.assertions.length + ")</b>";
			
			addEvent(b, "click", function() {
				var next = b.nextSibling, display = next.style.display;
				next.style.display = display === "none" ? "block" : "none";
			});
			
			addEvent(b, "dblclick", function(e) {
				var target = e && e.target ? e.target : window.event.srcElement;
				if ( target.nodeName.toLowerCase() == "span" || target.nodeName.toLowerCase() == "b" ) {
					target = target.parentNode;
				}
				if ( window.location && target.nodeName.toLowerCase() === "strong" ) {
					window.location.search = "?" + encodeURIComponent(getText([target]).replace(/\(.+\)$/, "").replace(/(^\s*|\s*$)/g, ""));
				}
			});

			var li = id(this.id);
			li.className = bad ? "fail" : "pass";
			li.style.display = resultDisplayStyle(!bad);
			li.removeChild( li.firstChild );
			li.appendChild( b );
			li.appendChild( ol );

		} else {
			for ( var i = 0; i < this.assertions.length; i++ ) {
				if ( !this.assertions[i].result ) {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}
		}

		try {
			QUnit.reset();
		} catch(e) {
			fail("reset() failed, following Test " + this.testName + ", exception and reset fn follows", e, QUnit.reset);
		}

		QUnit.testDone( {
			name: this.testName,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length
		} );
	},
	
	queue: function() {
		var test = this;
		synchronize(function() {
			test.init();
		});
		function run() {
			// each of these can by async
			synchronize(function() {
				test.setup();
			});
			synchronize(function() {
				test.run();
			});
			synchronize(function() {
				test.teardown();
			});
			synchronize(function() {
				test.finish();
			});
		}
		// defer when previous test run passed, if storage is available
		var bad = defined.sessionStorage && +sessionStorage.getItem("qunit-" + this.testName);
		if (bad) {
			run();
		} else {
			synchronize(run);
		};
	}
	
}

var QUnit = {

	// call on start of module test to prepend name to all tests
	module: function(name, testEnvironment) {
		config.currentModule = name;
		config.currentModuleTestEnviroment = testEnvironment;
	},

	asyncTest: function(testName, expected, callback) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = 0;
		}

		QUnit.test(testName, expected, callback, true);
	},
	
	test: function(testName, expected, callback, async) {
		var name = '<span class="test-name">' + testName + '</span>', testEnvironmentArg;

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}
		// is 2nd argument a testEnvironment?
		if ( expected && typeof expected === 'object') {
			testEnvironmentArg =  expected;
			expected = null;
		}

		if ( config.currentModule ) {
			name = '<span class="module-name">' + config.currentModule + "</span>: " + name;
		}

		if ( !validTest(config.currentModule + ": " + testName) ) {
			return;
		}
		
		var test = new Test(name, testName, expected, testEnvironmentArg, async, callback);
		test.module = config.currentModule;
		test.moduleTestEnvironment = config.currentModuleTestEnviroment;
		test.queue();
	},
	
	/**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through.
	 */
	expect: function(asserts) {
		config.current.expected = asserts;
	},

	/**
	 * Asserts true.
	 * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
	 */
	ok: function(a, msg) {
		a = !!a;
		var details = {
			result: a,
			message: msg
		};
		msg = escapeHtml(msg);
		QUnit.log(details);
		config.current.assertions.push({
			result: a,
			message: msg
		});
	},

	/**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equal( format("Received {0} bytes.", 2), "Received 2 bytes." );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 */
	equal: function(actual, expected, message) {
		QUnit.push(expected == actual, actual, expected, message);
	},

	notEqual: function(actual, expected, message) {
		QUnit.push(expected != actual, actual, expected, message);
	},
	
	deepEqual: function(actual, expected, message) {
		QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
	},

	notDeepEqual: function(actual, expected, message) {
		QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
	},

	strictEqual: function(actual, expected, message) {
		QUnit.push(expected === actual, actual, expected, message);
	},

	notStrictEqual: function(actual, expected, message) {
		QUnit.push(expected !== actual, actual, expected, message);
	},

	raises: function(block, expected, message) {
		var actual, ok = false;
	
		if (typeof expected === 'string') {
			message = expected;
			expected = null;
		}
	
		try {
			block();
		} catch (e) {
			actual = e;
		}
	
		if (actual) {
			// we don't want to validate thrown error
			if (!expected) {
				ok = true;
			// expected is a regexp	
			} else if (QUnit.objectType(expected) === "regexp") {
				ok = expected.test(actual);
			// expected is a constructor	
			} else if (actual instanceof expected) {
				ok = true;
			// expected is a validation function which returns true is validation passed	
			} else if (expected.call({}, actual) === true) {
				ok = true;
			}
		}
			
		QUnit.ok(ok, message);
	},

	start: function() {
		config.semaphore--;
		if (config.semaphore > 0) {
			// don't start until equal number of stop-calls
			return;
		}
		if (config.semaphore < 0) {
			// ignore if start is called more often then stop
			config.semaphore = 0;
		}
		// A slight delay, to avoid any current callbacks
		if ( defined.setTimeout ) {
			window.setTimeout(function() {
				if ( config.timeout ) {
					clearTimeout(config.timeout);
				}

				config.blocking = false;
				process();
			}, 13);
		} else {
			config.blocking = false;
			process();
		}
	},
	
	stop: function(timeout) {
		config.semaphore++;
		config.blocking = true;

		if ( timeout && defined.setTimeout ) {
			clearTimeout(config.timeout);
			config.timeout = window.setTimeout(function() {
				QUnit.ok( false, "Test timed out" );
				QUnit.start();
			}, timeout);
		}
	}

};

// Backwards compatibility, deprecated
QUnit.equals = QUnit.equal;
QUnit.same = QUnit.deepEqual;

// Maintain internal state
var config = {
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true
};

// Load paramaters
(function() {
	var location = window.location || { search: "", protocol: "file:" },
		GETParams = location.search.slice(1).split('&');

	for ( var i = 0; i < GETParams.length; i++ ) {
		GETParams[i] = decodeURIComponent( GETParams[i] );
		if ( GETParams[i] === "noglobals" ) {
			GETParams.splice( i, 1 );
			i--;
			config.noglobals = true;
		} else if ( GETParams[i] === "notrycatch" ) {
			GETParams.splice( i, 1 );
			i--;
			config.notrycatch = true;
		} else if ( GETParams[i].search('=') > -1 ) {
			GETParams.splice( i, 1 );
			i--;
		}
	}
	
	// restrict modules/tests by get parameters
	config.filters = GETParams;
	
	// Figure out if we're running the tests from a server or not
	QUnit.isLocal = !!(location.protocol === 'file:');
})();

// Expose the API as global variables, unless an 'exports'
// object exists, in that case we assume we're in CommonJS
if ( typeof exports === "undefined" || typeof require === "undefined" ) {
	extend(window, QUnit);
	window.QUnit = QUnit;
} else {
	extend(exports, QUnit);
	exports.QUnit = QUnit;
}

// define these after exposing globals to keep them in these QUnit namespace only
extend(QUnit, {
	config: config,

	// Initialize the configuration options
	init: function() {
		extend(config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date,
			updateRate: 1000,
			blocking: false,
			autostart: true,
			autorun: false,
			filters: [],
			queue: [],
			semaphore: 0
		});

		var tests = id("qunit-tests"),
			banner = id("qunit-banner"),
			result = id("qunit-testresult");

		if ( tests ) {
			tests.innerHTML = "";
		}

		if ( banner ) {
			banner.className = "";
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}
	},
	
	/**
	 * Resets the test setup. Useful for tests that modify the DOM.
	 * 
	 * If jQuery is available, uses jQuery's html(), otherwise just innerHTML.
	 */
	reset: function() {
		if ( window.jQuery ) {
			jQuery( "#main, #qunit-fixture" ).html( config.fixture );
		} else {
			var main = id( 'main' ) || id( 'qunit-fixture' );
			if ( main ) {
				main.innerHTML = config.fixture;
			}
		}
	},
	
	/**
	 * Trigger an event on an element.
	 *
	 * @example triggerEvent( document.body, "click" );
	 *
	 * @param DOMElement elem
	 * @param String type
	 */
	triggerEvent: function( elem, type, event ) {
		if ( document.createEvent ) {
			event = document.createEvent("MouseEvents");
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);
			elem.dispatchEvent( event );

		} else if ( elem.fireEvent ) {
			elem.fireEvent("on"+type);
		}
	},
	
	// Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) == type;
	},
	
	objectType: function( obj ) {
		if (typeof obj === "undefined") {
				return "undefined";

		// consider: typeof null === object
		}
		if (obj === null) {
				return "null";
		}

		var type = Object.prototype.toString.call( obj )
			.match(/^\[object\s(.*)\]$/)[1] || '';

		switch (type) {
				case 'Number':
						if (isNaN(obj)) {
								return "nan";
						} else {
								return "number";
						}
				case 'String':
				case 'Boolean':
				case 'Array':
				case 'Date':
				case 'RegExp':
				case 'Function':
						return type.toLowerCase();
		}
		if (typeof obj === "object") {
				return "object";
		}
		return undefined;
	},
	
	push: function(result, actual, expected, message) {
		var details = {
			result: result,
			message: message,
			actual: actual,
			expected: expected
		};
		
		message = escapeHtml(message) || (result ? "okay" : "failed");
		message = '<span class="test-message">' + message + "</span>";
		expected = escapeHtml(QUnit.jsDump.parse(expected));
		actual = escapeHtml(QUnit.jsDump.parse(actual));
		var output = message + '<table><tr class="test-expected"><th>Expected: </th><td><pre>' + expected + '</pre></td></tr>';
		if (actual != expected) {
			output += '<tr class="test-actual"><th>Result: </th><td><pre>' + actual + '</pre></td></tr>';
			output += '<tr class="test-diff"><th>Diff: </th><td><pre>' + QUnit.diff(expected, actual) +'</pre></td></tr>';
		}
		if (!result) {
			var source = sourceFromStacktrace();
			if (source) {
				details.source = source;
				output += '<tr class="test-source"><th>Source: </th><td><pre>' + source +'</pre></td></tr>';
			}
		}
		output += "</table>";
		
		QUnit.log(details);
		
		config.current.assertions.push({
			result: !!result,
			message: output
		});
	},
	
	// Logging callbacks; all receive a single argument with the listed properties
	// run test/logs.html for any related changes
	begin: function() {},
	// done: { failed, passed, total, runtime }
	done: function() {},
	// log: { result, actual, expected, message }
	log: function() {},
	// testStart: { name }
	testStart: function() {},
	// testDone: { name, failed, passed, total }
	testDone: function() {},
	// moduleStart: { name }
	moduleStart: function() {},
	// moduleDone: { name, failed, passed, total }
	moduleDone: function() {}
});

if ( typeof document === "undefined" || document.readyState === "complete" ) {
	config.autorun = true;
}

addEvent(window, "load", function() {
	QUnit.begin({});
	
	// Initialize the config, saving the execution queue
	var oldconfig = extend({}, config);
	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	var userAgent = id("qunit-userAgent");
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}
	var banner = id("qunit-header");
	if ( banner ) {
		var paramsIndex = location.href.lastIndexOf(location.search);
		if ( paramsIndex > -1 ) {
			var mainPageLocation = location.href.slice(0, paramsIndex);
			if ( mainPageLocation == location.href ) {
				banner.innerHTML = '<a href=""> ' + banner.innerHTML + '</a> ';
			} else {
				var testName = decodeURIComponent(location.search.slice(1));
				banner.innerHTML = '<a href="' + mainPageLocation + '">' + banner.innerHTML + '</a> &#8250; <a href="">' + testName + '</a>';
			}
		}
	}
	
	var toolbar = id("qunit-testrunner-toolbar");
	if ( toolbar ) {
		var filter = document.createElement("input");
		filter.type = "checkbox";
		filter.id = "qunit-filter-pass";
		addEvent( filter, "click", function() {
			var li = document.getElementsByTagName("li");
			for ( var i = 0; i < li.length; i++ ) {
				if ( li[i].className.indexOf("pass") > -1 ) {
					li[i].style.display = filter.checked ? "none" : "";
				}
			}
			if ( defined.sessionStorage ) {
				sessionStorage.setItem("qunit-filter-passed-tests", filter.checked ? "true" : "");
			}
		});
		if ( defined.sessionStorage && sessionStorage.getItem("qunit-filter-passed-tests") ) {
			filter.checked = true;
		}
		toolbar.appendChild( filter );

		var label = document.createElement("label");
		label.setAttribute("for", "qunit-filter-pass");
		label.innerHTML = "Hide passed tests";
		toolbar.appendChild( label );
	}

	var main = id('main') || id('qunit-fixture');
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if (config.autostart) {
		QUnit.start();
	}
});

function done() {
	config.autorun = true;

	// Log the last module results
	if ( config.currentModule ) {
		QUnit.moduleDone( {
			name: config.currentModule,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all
		} );
	}

	var banner = id("qunit-banner"),
		tests = id("qunit-tests"),
		runtime = +new Date - config.started,
		passed = config.stats.all - config.stats.bad,
		html = [
			'Tests completed in ',
			runtime,
			' milliseconds.<br/>',
			'<span class="passed">',
			passed,
			'</span> tests of <span class="total">',
			config.stats.all,
			'</span> passed, <span class="failed">',
			config.stats.bad,
			'</span> failed.'
		].join('');

	if ( banner ) {
		banner.className = (config.stats.bad ? "qunit-fail" : "qunit-pass");
	}

	if ( tests ) {	
		var result = id("qunit-testresult");

		if ( !result ) {
			result = document.createElement("p");
			result.id = "qunit-testresult";
			result.className = "result";
			tests.parentNode.insertBefore( result, tests.nextSibling );
		}

		result.innerHTML = html;
	}

	QUnit.done( {
		failed: config.stats.bad,
		passed: passed, 
		total: config.stats.all,
		runtime: runtime
	} );
}

function validTest( name ) {
	var i = config.filters.length,
		run = false;

	if ( !i ) {
		return true;
	}
	
	while ( i-- ) {
		var filter = config.filters[i],
			not = filter.charAt(0) == '!';

		if ( not ) {
			filter = filter.slice(1);
		}

		if ( name.indexOf(filter) !== -1 ) {
			return !not;
		}

		if ( not ) {
			run = true;
		}
	}

	return run;
}

// so far supports only Firefox, Chrome and Opera (buggy)
// could be extended in the future to use something like https://github.com/csnover/TraceKit
function sourceFromStacktrace() {
	try {
		throw new Error();
	} catch ( e ) {
		if (e.stacktrace) {
			// Opera
			return e.stacktrace.split("\n")[6];
		} else if (e.stack) {
			// Firefox, Chrome
			return e.stack.split("\n")[4];
		}
	}
}

function resultDisplayStyle(passed) {
	return passed && id("qunit-filter-pass") && id("qunit-filter-pass").checked ? 'none' : '';
}

function escapeHtml(s) {
	if (!s) {
		return "";
	}
	s = s + "";
	return s.replace(/[\&"<>\\]/g, function(s) {
		switch(s) {
			case "&": return "&amp;";
			case "\\": return "\\\\";
			case '"': return '\"';
			case "<": return "&lt;";
			case ">": return "&gt;";
			default: return s;
		}
	});
}

function synchronize( callback ) {
	config.queue.push( callback );

	if ( config.autorun && !config.blocking ) {
		process();
	}
}

function process() {
	var start = (new Date()).getTime();

	while ( config.queue.length && !config.blocking ) {
		if ( config.updateRate <= 0 || (((new Date()).getTime() - start) < config.updateRate) ) {
			config.queue.shift()();
		} else {
			window.setTimeout( process, 13 );
			break;
		}
	}
  if (!config.blocking && !config.queue.length) {
    done();
  }
}

function saveGlobal() {
	config.pollution = [];
	
	if ( config.noglobals ) {
		for ( var key in window ) {
			config.pollution.push( key );
		}
	}
}

function checkPollution( name ) {
	var old = config.pollution;
	saveGlobal();
	
	var newGlobals = diff( old, config.pollution );
	if ( newGlobals.length > 0 ) {
		ok( false, "Introduced global variable(s): " + newGlobals.join(", ") );
		config.current.expected++;
	}

	var deletedGlobals = diff( config.pollution, old );
	if ( deletedGlobals.length > 0 ) {
		ok( false, "Deleted global variable(s): " + deletedGlobals.join(", ") );
		config.current.expected++;
	}
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var result = a.slice();
	for ( var i = 0; i < result.length; i++ ) {
		for ( var j = 0; j < b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice(i, 1);
				i--;
				break;
			}
		}
	}
	return result;
}

function fail(message, exception, callback) {
	if ( typeof console !== "undefined" && console.error && console.warn ) {
		console.error(message);
		console.error(exception);
		console.warn(callback.toString());

	} else if ( window.opera && opera.postError ) {
		opera.postError(message, exception, callback.toString);
	}
}

function extend(a, b) {
	for ( var prop in b ) {
		a[prop] = b[prop];
	}

	return a;
}

function addEvent(elem, type, fn) {
	if ( elem.addEventListener ) {
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {
		elem.attachEvent( "on" + type, fn );
	} else {
		fn();
	}
}

function id(name) {
	return !!(typeof document !== "undefined" && document && document.getElementById) &&
		document.getElementById( name );
}

// Test for equality any JavaScript type.
// Discussions and reference: http://philrathe.com/articles/equiv
// Test suites: http://philrathe.com/tests/equiv
// Author: Philippe Rathé <prathe@gmail.com>
QUnit.equiv = function () {

    var innerEquiv; // the real equiv function
    var callers = []; // stack to decide between skip/abort functions
    var parents = []; // stack to avoiding loops from circular referencing

    // Call the o related callback with the given arguments.
    function bindCallbacks(o, callbacks, args) {
        var prop = QUnit.objectType(o);
        if (prop) {
            if (QUnit.objectType(callbacks[prop]) === "function") {
                return callbacks[prop].apply(callbacks, args);
            } else {
                return callbacks[prop]; // or undefined
            }
        }
    }
    
    var callbacks = function () {

        // for string, boolean, number and null
        function useStrictEquality(b, a) {
            if (b instanceof a.constructor || a instanceof b.constructor) {
                // to catch short annotaion VS 'new' annotation of a declaration
                // e.g. var i = 1;
                //      var j = new Number(1);
                return a == b;
            } else {
                return a === b;
            }
        }

        return {
            "string": useStrictEquality,
            "boolean": useStrictEquality,
            "number": useStrictEquality,
            "null": useStrictEquality,
            "undefined": useStrictEquality,

            "nan": function (b) {
                return isNaN(b);
            },

            "date": function (b, a) {
                return QUnit.objectType(b) === "date" && a.valueOf() === b.valueOf();
            },

            "regexp": function (b, a) {
                return QUnit.objectType(b) === "regexp" &&
                    a.source === b.source && // the regex itself
                    a.global === b.global && // and its modifers (gmi) ...
                    a.ignoreCase === b.ignoreCase &&
                    a.multiline === b.multiline;
            },

            // - skip when the property is a method of an instance (OOP)
            // - abort otherwise,
            //   initial === would have catch identical references anyway
            "function": function () {
                var caller = callers[callers.length - 1];
                return caller !== Object &&
                        typeof caller !== "undefined";
            },

            "array": function (b, a) {
                var i, j, loop;
                var len;

                // b could be an object literal here
                if ( ! (QUnit.objectType(b) === "array")) {
                    return false;
                }   
                
                len = a.length;
                if (len !== b.length) { // safe and faster
                    return false;
                }
                
                //track reference to avoid circular references
                parents.push(a);
                for (i = 0; i < len; i++) {
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i]){
                            loop = true;//dont rewalk array
                        }
                    }
                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        parents.pop();
                        return false;
                    }
                }
                parents.pop();
                return true;
            },

            "object": function (b, a) {
                var i, j, loop;
                var eq = true; // unless we can proove it
                var aProperties = [], bProperties = []; // collection of strings

                // comparing constructors is more strict than using instanceof
                if ( a.constructor !== b.constructor) {
                    return false;
                }

                // stack constructor before traversing properties
                callers.push(a.constructor);
                //track reference to avoid circular references
                parents.push(a);
                
                for (i in a) { // be strict: don't ensures hasOwnProperty and go deep
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i])
                            loop = true; //don't go down the same path twice
                    }
                    aProperties.push(i); // collect a's properties

                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        eq = false;
                        break;
                    }
                }

                callers.pop(); // unstack, we are done
                parents.pop();

                for (i in b) {
                    bProperties.push(i); // collect b's properties
                }

                // Ensures identical properties name
                return eq && innerEquiv(aProperties.sort(), bProperties.sort());
            }
        };
    }();

    innerEquiv = function () { // can take multiple arguments
        var args = Array.prototype.slice.apply(arguments);
        if (args.length < 2) {
            return true; // end transition
        }

        return (function (a, b) {
            if (a === b) {
                return true; // catch the most you can
            } else if (a === null || b === null || typeof a === "undefined" || typeof b === "undefined" || QUnit.objectType(a) !== QUnit.objectType(b)) {
                return false; // don't lose time with error prone cases
            } else {
                return bindCallbacks(a, callbacks, [b, a]);
            }

        // apply transition with (1..n) arguments
        })(args[0], args[1]) && arguments.callee.apply(this, args.splice(1, args.length -1));
    };

    return innerEquiv;

}();

/**
 * jsDump
 * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
 * Date: 5/15/2008
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
 */
QUnit.jsDump = (function() {
	function quote( str ) {
		return '"' + str.toString().replace(/"/g, '\\"') + '"';
	};
	function literal( o ) {
		return o + '';	
	};
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join )
			arr = arr.join( ',' + s + inner );
		if ( !arr )
			return pre + post;
		return [ pre, inner + arr, base + post ].join(s);
	};
	function array( arr ) {
		var i = arr.length,	ret = Array(i);					
		this.up();
		while ( i-- )
			ret[i] = this.parse( arr[i] );				
		this.down();
		return join( '[', ret, ']' );
	};
	
	var reName = /^function (\w+)/;
	
	var jsDump = {
		parse:function( obj, type ) { //type is used mostly internally, you can fix a (custom)type in advance
			var	parser = this.parsers[ type || this.typeOf(obj) ];
			type = typeof parser;			
			
			return type == 'function' ? parser.call( this, obj ) :
				   type == 'string' ? parser :
				   this.parsers.error;
		},
		typeOf:function( obj ) {
			var type;
			if ( obj === null ) {
				type = "null";
			} else if (typeof obj === "undefined") {
				type = "undefined";
			} else if (QUnit.is("RegExp", obj)) {
				type = "regexp";
			} else if (QUnit.is("Date", obj)) {
				type = "date";
			} else if (QUnit.is("Function", obj)) {
				type = "function";
			} else if (typeof obj.setInterval !== undefined && typeof obj.document !== "undefined" && typeof obj.nodeType === "undefined") {
				type = "window";
			} else if (obj.nodeType === 9) {
				type = "document";
			} else if (obj.nodeType) {
				type = "node";
			} else if (typeof obj === "object" && typeof obj.length === "number" && obj.length >= 0) {
				type = "array";
			} else {
				type = typeof obj;
			}
			return type;
		},
		separator:function() {
			return this.multiline ?	this.HTML ? '<br />' : '\n' : this.HTML ? '&nbsp;' : ' ';
		},
		indent:function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing
			if ( !this.multiline )
				return '';
			var chr = this.indentChar;
			if ( this.HTML )
				chr = chr.replace(/\t/g,'   ').replace(/ /g,'&nbsp;');
			return Array( this._depth_ + (extra||0) ).join(chr);
		},
		up:function( a ) {
			this._depth_ += a || 1;
		},
		down:function( a ) {
			this._depth_ -= a || 1;
		},
		setParser:function( name, parser ) {
			this.parsers[name] = parser;
		},
		// The next 3 are exposed so you can use them
		quote:quote, 
		literal:literal,
		join:join,
		//
		_depth_: 1,
		// This is the list of parsers, to modify them, use jsDump.setParser
		parsers:{
			window: '[Window]',
			document: '[Document]',
			error:'[ERROR]', //when no parser is found, shouldn't happen
			unknown: '[Unknown]',
			'null':'null',
			undefined:'undefined',
			'function':function( fn ) {
				var ret = 'function',
					name = 'name' in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
				if ( name )
					ret += ' ' + name;
				ret += '(';
				
				ret = [ ret, QUnit.jsDump.parse( fn, 'functionArgs' ), '){'].join('');
				return join( ret, QUnit.jsDump.parse(fn,'functionCode'), '}' );
			},
			array: array,
			nodelist: array,
			arguments: array,
			object:function( map ) {
				var ret = [ ];
				QUnit.jsDump.up();
				for ( var key in map )
					ret.push( QUnit.jsDump.parse(key,'key') + ': ' + QUnit.jsDump.parse(map[key]) );
				QUnit.jsDump.down();
				return join( '{', ret, '}' );
			},
			node:function( node ) {
				var open = QUnit.jsDump.HTML ? '&lt;' : '<',
					close = QUnit.jsDump.HTML ? '&gt;' : '>';
					
				var tag = node.nodeName.toLowerCase(),
					ret = open + tag;
					
				for ( var a in QUnit.jsDump.DOMAttrs ) {
					var val = node[QUnit.jsDump.DOMAttrs[a]];
					if ( val )
						ret += ' ' + a + '=' + QUnit.jsDump.parse( val, 'attribute' );
				}
				return ret + close + open + '/' + tag + close;
			},
			functionArgs:function( fn ) {//function calls it internally, it's the arguments part of the function
				var l = fn.length;
				if ( !l ) return '';				
				
				var args = Array(l);
				while ( l-- )
					args[l] = String.fromCharCode(97+l);//97 is 'a'
				return ' ' + args.join(', ') + ' ';
			},
			key:quote, //object calls it internally, the key part of an item in a map
			functionCode:'[code]', //function calls it internally, it's the content of the function
			attribute:quote, //node calls it internally, it's an html attribute value
			string:quote,
			date:quote,
			regexp:literal, //regex
			number:literal,
			'boolean':literal
		},
		DOMAttrs:{//attributes to dump from nodes, name=>realName
			id:'id',
			name:'name',
			'class':'className'
		},
		HTML:false,//if true, entities are escaped ( <, >, \t, space and \n )
		indentChar:'  ',//indentation unit
		multiline:true //if true, items in a collection, are separated by a \n, else just a space.
	};

	return jsDump;
})();

// from Sizzle.js
function getText( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += getText( elem.childNodes );
		}
	}

	return ret;
};

/*
 * Javascript Diff Algorithm
 *  By John Resig (http://ejohn.org/)
 *  Modified by Chu Alan "sprite"
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http://ejohn.org/projects/javascript-diff-algorithm/
 *  
 * Usage: QUnit.diff(expected, actual)
 * 
 * QUnit.diff("the quick brown fox jumped over", "the quick fox jumps over") == "the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
 */
QUnit.diff = (function() {
	function diff(o, n){
		var ns = new Object();
		var os = new Object();
		
		for (var i = 0; i < n.length; i++) {
			if (ns[n[i]] == null) 
				ns[n[i]] = {
					rows: new Array(),
					o: null
				};
			ns[n[i]].rows.push(i);
		}
		
		for (var i = 0; i < o.length; i++) {
			if (os[o[i]] == null) 
				os[o[i]] = {
					rows: new Array(),
					n: null
				};
			os[o[i]].rows.push(i);
		}
		
		for (var i in ns) {
			if (ns[i].rows.length == 1 && typeof(os[i]) != "undefined" && os[i].rows.length == 1) {
				n[ns[i].rows[0]] = {
					text: n[ns[i].rows[0]],
					row: os[i].rows[0]
				};
				o[os[i].rows[0]] = {
					text: o[os[i].rows[0]],
					row: ns[i].rows[0]
				};
			}
		}
		
		for (var i = 0; i < n.length - 1; i++) {
			if (n[i].text != null && n[i + 1].text == null && n[i].row + 1 < o.length && o[n[i].row + 1].text == null &&
			n[i + 1] == o[n[i].row + 1]) {
				n[i + 1] = {
					text: n[i + 1],
					row: n[i].row + 1
				};
				o[n[i].row + 1] = {
					text: o[n[i].row + 1],
					row: i + 1
				};
			}
		}
		
		for (var i = n.length - 1; i > 0; i--) {
			if (n[i].text != null && n[i - 1].text == null && n[i].row > 0 && o[n[i].row - 1].text == null &&
			n[i - 1] == o[n[i].row - 1]) {
				n[i - 1] = {
					text: n[i - 1],
					row: n[i].row - 1
				};
				o[n[i].row - 1] = {
					text: o[n[i].row - 1],
					row: i - 1
				};
			}
		}
		
		return {
			o: o,
			n: n
		};
	}
	
	return function(o, n){
		o = o.replace(/\s+$/, '');
		n = n.replace(/\s+$/, '');
		var out = diff(o == "" ? [] : o.split(/\s+/), n == "" ? [] : n.split(/\s+/));

		var str = "";
		
		var oSpace = o.match(/\s+/g);
		if (oSpace == null) {
			oSpace = [" "];
		}
		else {
			oSpace.push(" ");
		}
		var nSpace = n.match(/\s+/g);
		if (nSpace == null) {
			nSpace = [" "];
		}
		else {
			nSpace.push(" ");
		}
		
		if (out.n.length == 0) {
			for (var i = 0; i < out.o.length; i++) {
				str += '<del>' + out.o[i] + oSpace[i] + "</del>";
			}
		}
		else {
			if (out.n[0].text == null) {
				for (n = 0; n < out.o.length && out.o[n].text == null; n++) {
					str += '<del>' + out.o[n] + oSpace[n] + "</del>";
				}
			}
			
			for (var i = 0; i < out.n.length; i++) {
				if (out.n[i].text == null) {
					str += '<ins>' + out.n[i] + nSpace[i] + "</ins>";
				}
				else {
					var pre = "";
					
					for (n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++) {
						pre += '<del>' + out.o[n] + oSpace[n] + "</del>";
					}
					str += " " + out.n[i].text + nSpace[i] + pre;
				}
			}
		}
		
		return str;
	};
})();

})(this);

}};
__resources__["/__builtin__/libs/util.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
var path = require('path');

/**
 * @namespace
 * Useful utility functions
 */
var util = {
    /**
     * Merge two or more objects and return the result.
     *
     * @param {Object} firstObject First object to merge with
     * @param {Object} secondObject Second object to merge with
     * @param {Object} [...] More objects to merge
     * @returns {Object} A new object containing the properties of all the objects passed in
     */
    merge: function(firstObject, secondObject) {
        var result = {};

        for (var i = 0; i < arguments.length; i++) {
            var obj = arguments[i];

            for (var x in obj) {
                if (!obj.hasOwnProperty(x)) {
                    continue;
                }

                result[x] = obj[x];
            }
        };

        return result;
    },

    /**
     * Creates a deep copy of an object
     *
     * @param {Object} obj The Object to copy
     * @returns {Object} A copy of the original Object
     */
    copy: function(obj) {
        if (obj === null) {
            return null;
        }

        var copy;

        if (obj instanceof Array) {
            copy = [];
            for (var i = 0, len = obj.length; i < len; i++) {
                copy[i] = arguments.callee(obj[i]);
            }
        } else if (typeof(obj) == 'object') {
            if (typeof(obj.copy) == 'function') {
                copy = obj.copy();
            } else {
                copy = {};

                var o, x;
                for (x in obj) {
                    copy[x] = arguments.callee(obj[x]);
                }
            }
        } else {
            // Primative type. Doesn't need copying
            copy = obj;
        }

        return copy;
    },

    /**
     * Iterates over an array and calls a function for each item.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The original array
     */
    each: function(arr, func) {
        var i = 0,
            len = arr.length;
        for (i = 0; i < len; i++) {
            func(arr[i], i);
        }

        return arr;
    },

    /**
     * Iterates over an array, calls a function for each item and returns the results.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The return values from each function call
     */
    map: function(arr, func) {
        var i = 0,
            len = arr.length,
            result = [];

        for (i = 0; i < len; i++) {
            result.push(func(arr[i], i));
        }

        return result;
    },

    extend: function(target, ext) {
        if (arguments.length < 2) {
            throw "You must provide at least a target and 1 object to extend from"
        }

        var i, j, obj, key, val;

        for (i = 1; i < arguments.length; i++) {
            obj = arguments[i];
            for (key in obj) {
                // Don't copy built-ins
                if (!obj.hasOwnProperty(key)) {
                    continue;
                }

                val = obj[key];
                // Don't copy undefineds or references to target (would cause infinite loop)
                if (val === undefined || val === target) {
                    continue;
                }

                // Replace existing function and store reference to it in .base
                if (val instanceof Function && target[key] && val !== target[key]) {
                    val.base = target[key];
                    val._isProperty = val.base._isProperty;
                }
                target[key] = val;

                if (val instanceof Function) {
                    // If this function observes make a reference to it so we can set
                    // them up when this get instantiated
                    if (val._observing) {
                        // Force a COPY of the array or we will probably end up with various
                        // classes sharing the same one.
                        if (!target._observingFunctions) {
                            target._observingFunctions = [];
                        } else {
                            target._observingFunctions = target._observingFunctions.slice(0);
                        }


                        for (j = 0; j<val._observing.length; j++) {
                            target._observingFunctions.push({property:val._observing[j], method: key});
                        }
                    } // if (val._observing)

                    // If this is a computer property then add it to the list so get/set know where to look
                    if (val._isProperty) {
                        if (!target._computedProperties) {
                            target._computedProperties = [];
                        } else {
                            target._computedProperties = target._computedProperties.slice(0);
                        }

                        target._computedProperties.push(key)
                    }
                }
        
            }
        }


        return target;
    },

    beget: function(o) {
        var F = function(){};
        F.prototype = o;
        var ret  = new F();
        F.prototype = null;
        return ret;
    },

    callback: function(target, method) {
        if (typeof(method) == 'string') {
            method = target[method];
        }

        return function() {
            method.apply(target, arguments);
        }
    },

    domReady: function() {
        if (this._isReady) {
            return;
        }

        if (!document.body) {
            setTimeout(function() { util.domReady(); }, 13);
        }

        window.__isReady = true;

        if (window.__readyList) {
            var fn, i = 0;
            while ( (fn = window.__readyList[ i++ ]) ) {
                fn.call(document);
            }

            window.__readyList = null;
            delete window.__readyList;
        }
    },


    /**
     * Adapted from jQuery
     * @ignore
     */
    bindReady: function() {

        if (window.__readyBound) {
            return;
        }

        window.__readyBound = true;

        // Catch cases where $(document).ready() is called after the
        // browser event has already occurred.
        if ( document.readyState === "complete" ) {
            return util.domReady();
        }

        // Mozilla, Opera and webkit nightlies currently support this event
        if ( document.addEventListener ) {
            // Use the handy event callback
            //document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
            
            // A fallback to window.onload, that will always work
            window.addEventListener( "load", util.domReady, false );

        // If IE event model is used
        } else if ( document.attachEvent ) {
            // ensure firing before onload,
            // maybe late but safe also for iframes
            //document.attachEvent("onreadystatechange", DOMContentLoaded);
            
            // A fallback to window.onload, that will always work
            window.attachEvent( "onload", util.domReady );

            // If IE and not a frame
            /*
            // continually check to see if the document is ready
            var toplevel = false;

            try {
                toplevel = window.frameElement == null;
            } catch(e) {}

            if ( document.documentElement.doScroll && toplevel ) {
                doScrollCheck();
            }
            */
        }
    },



    ready: function(func) {
        if (window.__isReady) {
            func()
        } else {
            if (!window.__readyList) {
                window.__readyList = [];
            }
            window.__readyList.push(func);
        }

        util.bindReady();
    },


    /**
     * Tests if a given object is an Array
     *
     * @param {Array} ar The object to test
     *
     * @returns {Boolean} True if it is an Array, otherwise false
     */
    isArray: function(ar) {
      return ar instanceof Array
          || (ar && ar !== Object.prototype && util.isArray(ar.__proto__));
    },


    /**
     * Tests if a given object is a RegExp
     *
     * @param {RegExp} ar The object to test
     *
     * @returns {Boolean} True if it is an RegExp, otherwise false
     */
    isRegExp: function(re) {
      var s = ""+re;
      return re instanceof RegExp // easy case
          || typeof(re) === "function" // duck-type for context-switching evalcx case
          && re.constructor.name === "RegExp"
          && re.compile
          && re.test
          && re.exec
          && s.charAt(0) === "/"
          && s.substr(-1) === "/";
    },


    /**
     * Tests if a given object is a Date
     *
     * @param {Date} ar The object to test
     *
     * @returns {Boolean} True if it is an Date, otherwise false
     */
    isDate: function(d) {
        if (d instanceof Date) return true;
        if (typeof d !== "object") return false;
        var properties = Date.prototype && Object.getOwnPropertyNames(Date.prototype);
        var proto = d.__proto__ && Object.getOwnPropertyNames(d.__proto__);
        return JSON.stringify(proto) === JSON.stringify(properties);
    },

    /**
     * Utility to populate a namespace's index with its modules
     *
     * @param {Object} parent The module the namespace lives in. parent.exports will be populated automatically
     * @param {String} modules A space separated string of all the module names
     *
     * @returns {Object} The index namespace
     */
    populateIndex: function(parent, modules) {
        var namespace = {};
        modules = modules.split(' ');

        util.each(modules, function(mod, i) {
            // Use the global 'require' which allows overriding the parent module
            util.extend(namespace, window.require('./' + mod, parent));
        });

        parent.exports = namespace;

        return namespace;
    }


}

util.extend(String.prototype, /** @scope String.prototype */ {
    /**
     * Create an array of words from a string
     *
     * @returns {String[]} Array of the words in the string
     */
    w: function() {
        return this.split(' ');
    }
});




module.exports = util;

}};
__resources__["/__builtin__/path.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var path = {
    /**
     * Returns full directory path for the filename given. The path must be formed using forward slashes '/'.
     *
     * @param {String} path Path to return the directory name of
     * @returns {String} Directory name
     */
    dirname: function(path) {
        var tokens = path.split('/');
        tokens.pop();
        return tokens.join('/');
    },

    /**
     * Returns just the filename portion of a path.
     *
     * @param {String} path Path to return the filename portion of
     * @returns {String} Filename
     */
    basename: function(path) {
        var tokens = path.split('/');
        return tokens[tokens.length-1];
    },

    /**
     * Joins multiple paths together to form a single path
     * @param {String} ... Any number of string arguments to join together
     * @returns {String} The joined path
     */
    join: function () {
        return module.exports.normalize(Array.prototype.join.call(arguments, "/"));
    },

    /**
     * Tests if a path exists
     *
     * @param {String} path Path to test
     * @returns {Boolean} True if the path exists, false if not
     */
    exists: function(path) {
        return (__resources__[path] !== undefined);
    },

    /**
     * @private
     */
    normalizeArray: function (parts, keepBlanks) {
      var directories = [], prev;
      for (var i = 0, l = parts.length - 1; i <= l; i++) {
        var directory = parts[i];

        // if it's blank, but it's not the first thing, and not the last thing, skip it.
        if (directory === "" && i !== 0 && i !== l && !keepBlanks) continue;

        // if it's a dot, and there was some previous dir already, then skip it.
        if (directory === "." && prev !== undefined) continue;

        // if it starts with "", and is a . or .., then skip it.
        if (directories.length === 1 && directories[0] === "" && (
            directory === "." || directory === "..")) continue;

        if (
          directory === ".."
          && directories.length
          && prev !== ".."
          && prev !== "."
          && prev !== undefined
          && (prev !== "" || keepBlanks)
        ) {
          directories.pop();
          prev = directories.slice(-1)[0]
        } else {
          if (prev === ".") directories.pop();
          directories.push(directory);
          prev = directory;
        }
      }
      return directories;
    },

    /**
     * Returns the real path by expanding any '.' and '..' portions
     *
     * @param {String} path Path to normalize
     * @param {Boolean} [keepBlanks=false] Whether to keep blanks. i.e. double slashes in a path
     * @returns {String} Normalized path
     */
    normalize: function (path, keepBlanks) {
      return module.exports.normalizeArray(path.split("/"), keepBlanks).join("/");
    }
};

module.exports = path;

}};
__resources__["/__builtin__/system.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var system = {
    /** @namespace */
    stdio: {
        /**
         * Print text and objects to the debug console if the browser has one
         * 
         * @param {*} Any value to output
         */
        print: function() {
            if (console) {
                console.log.apply(console, arguments);
            } else {
                // TODO
            }
        }
    }
};

if (window.console) {
    system.console = window.console
} else {
    system.console = {
        log: function(){}
    }
}

}};
__resources__["/main.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');

var PTM_RATIO = 30;

var TAGS = {
  kTagPaddle        : "Paddle",
  kTagPuck          : "Puck",
  kTagBlueGoal      : "Blue Goal",
  kTagRedGoal       : "Red Goal",
  kTagRedScore      : "Red Score",
  kTagBlueScore     : "Blue Score",
  kTagPlayButton    : "Play Button",
  kTagRematchButton : "Rematch Button"
}

var COLORS = {
  red : "red",
  blue : "blue"
}

var assets = [
  "winner.wav",
  "buzzer.wav",
  "goalScore.wav",
  "puckHitPaddle.wav",
  "puckHitWall.wav"
];

var loadAssets = function( assets, onComplete ) {
  var current, ext, obj, totalLoaded = 0, total = assets.length;

  for( var i = 0; i < assets.length; i++ ) {
    current = assets[ i ];
    ext     = current.substr( current.lastIndexOf( "." ) + 1 ).toLowerCase();

    if( ext === "mp3" || ext === "wav" || ext === "ogg" || ext === "mp4" ) {
      obj = new Audio( current );
    } else if( ext === "jpg" || ext === "jpeg" || ext === "gif" || ext === "png" ) {
      obj     = new Image();
      obj.src = "/resources/" + current;
    } else {
      total--;
      continue;
    }

    obj.onload = function() {
      totalLoaded++;

      if( totalLoaded == total ) {
        if( onComplete ) { onComplete(); }
      }
    }
  }
}

loadAssets( assets );

var Splash = cocos.nodes.Layer.extend( {
  init : function() {
    Splash.superclass.init.call( this );

    this.set( "isMouseEnabled", true );

    var director = cocos.Director.get( "sharedDirector" );
    var winSize = director.get( "winSize" );

    var titleSplash = cocos.nodes.Sprite.create( { file : "/resources/titleSplash.png" } );
    titleSplash.set( "position", new geo.Point( winSize.width / 2, winSize.height * 4 / 5 ) );
    this.addChild( { child : titleSplash, z : 100 } );

    var playButton = cocos.nodes.Sprite.create( { file : "/resources/playButton.png" } );
    playButton.set( "position", new geo.Point( winSize.width / 2, winSize.height / 5 ) );
    this.addChild( { child : playButton, z : 100, tag : TAGS.kTagPlayButton } );


    playButton.push = function() {
      console.log( "PLAY" );
      director.pushScene( Hockey.create() );
    }

    var background = cocos.nodes.Sprite.create( { file : "/resources/screenshot.png" } );
    background.set( "position", new geo.Point( winSize.width / 2, winSize.height / 2 ) );
    this.addChild( { child : background, z : -1 } );
  },

  mouseDown : function( evt ) {
    var pos        = evt.locationInCanvas,
        playButton = this.getChild( { tag : TAGS.kTagPlayButton } );

    if( geo.rectContainsPoint( playButton.get( "rect" ), pos ) ) {
      playButton.push();
    }
  }
} );

var Rematch = cocos.nodes.Layer.extend( {
  init : function( winner ) {
    Rematch.superclass.init.call( this );

    this.set( "isMouseEnabled", true );

    var director = cocos.Director.get( "sharedDirector" );
    var winSize  = director.get( "winSize" );

    var background = cocos.nodes.Sprite.create( { file : "/resources/screenshot.png" } );
    background.set( "position", new geo.Point( winSize.width / 2, winSize.height / 2 ) );
    this.addChild( { child : background, z : -1 } );

    var winnerImagePath;
    if( winner == COLORS.blue ) {
      winnerImagePath = "/resources/bluePlayerWins.png";
    } else if( winner == COLORS.red ) {
      winnerImagePath = "/resources/redPlayerWins.png";
    }

    var playerWins = cocos.nodes.Sprite.create( { file : winnerImagePath } );
    playerWins.set( "position", new geo.Point( winSize.width / 2, winSize.height * 4 / 5 ) );
    this.addChild( { child : playerWins, z : 100 } );

    var rematchButton = cocos.nodes.Sprite.create( { file : "/resources/rematchButton.png" } );
    rematchButton.set( "position", new geo.Point( winSize.width / 2, winSize.height / 5 ) );
    this.addChild( { child : rematchButton, z : 100, tag : TAGS.kTagRematchButton } );

    rematchButton.push = function() {
      console.log( "Rematch" );
      director.pushScene( Hockey.create() );
    }
  },
  mouseDown : function( evt ) {
    var pos        = evt.locationInCanvas,
        rematchButton = this.getChild( { tag : TAGS.kTagRematchButton } );

    if( geo.rectContainsPoint( rematchButton.get( "rect" ), pos ) ) {
      rematchButton.push();
    }
  }
} );

// Create a new layer
var Hockey = cocos.nodes.Layer.extend({
    world: null,
    bodies: null,
    selectedBody: null,
    mouseJoint: null,
    contactListener : null,
    puckBody : null,
    redPaddleBody : null,
    bluePaddleBody : null,
    sounds : null,

    init: function() {
        // You must always call the super class version of init
        Hockey.superclass.init.call(this);

        this.set('isMouseEnabled', true);

        this.set('bodies', []);
        this.set( "sounds", {
          goalScore     : new Audio( "goalScore.wav" ),
          puckHitPaddle : new Audio( "puckHitPaddle.wav" ),
          puckHitWall   : new Audio( "puckHitWall.wav" ),
          buzzer        : new Audio( "buzzer.wav" ),
          winner        : new Audio( "winner.wav" )
        } );

        // Get size of canvas
        var s = cocos.Director.get('sharedDirector').get('winSize');

        this.play();
        this.scheduleUpdate();
    },

    playSound : function( sound ) {
      this.get( "sounds" )[ sound ].play();
    },

    update: function(dt) {
        var world = this.get('world'),
            mouseJoint = this.get('mouseJoint');

        world.Step(dt, 10, 10);
        //world.DrawDebugData();
        world.ClearForces();

        var listener = this.get( "contactListener" );

        if( listener.puckHitPaddle ) {
          this.playSound( "puckHitPaddle" );
          listener.puckHitPaddle = false;
        }

        if( listener.puckHitWall ) {
          this.playSound( "puckHitWall" );
          listener.puckHitWall = false;
        }

        if( listener.redJustScored || listener.blueJustScored ) {
          var winSize = cocos.Director.get( "sharedDirector" ).get( "winSize" ),
              midx    = (winSize.width / 2) / PTM_RATIO;
              puckBody       = this.get( "puckBody" ),
              bluePaddleBody = this.get( "bluePaddleBody" ),
              redPaddleBody  = this.get( "redPaddleBody" );

          this.playSound( "buzzer" );

          var score;
          var winner;
          if( listener.redJustScored ) {
            winner = COLORS.red;
            puckBodyY = winSize.height * 2/3;
            var redScore = this.getChild( { tag : TAGS.kTagRedScore } );
            score    = 1 + parseInt( redScore.get( "string" ) );

            redScore.set( "string", score );
          } else {
            winner = COLORS.blue;
            puckBodyY = winSize.height / 3;
            var blueScore = this.getChild( { tag : TAGS.kTagBlueScore } );
            score    = 1 + parseInt( blueScore.get( "string" ) );

            blueScore.set( "string", score );
          }

          puckBody.SetLinearVelocity( new box2d.b2Vec2( 0, 0 ) );
          puckBody.SetPosition( new box2d.b2Vec2( midx, puckBodyY / PTM_RATIO ) );

          bluePaddleBody.SetLinearVelocity( new box2d.b2Vec2( 0, 0 ) );
          bluePaddleBody.SetPosition( new box2d.b2Vec2( midx, (winSize.height * 4 / 5) / PTM_RATIO ) );

          redPaddleBody.SetLinearVelocity( new box2d.b2Vec2( 0, 0 ) );
          redPaddleBody.SetPosition( new box2d.b2Vec2( midx, (winSize.height / 5) / PTM_RATIO ) );

          this.mouseUp({});

          listener.redJustScored = false;
          listener.blueJustScored = false;

          this.playSound( "goalScore" );

          if( score == 5 ) {
            this.playSound( "winner" );
            console.log( "Game Over" );
            var director = cocos.Director.get( "sharedDirector" );
            director.pushScene( Rematch.create( winner ) );
          }
        }

        var bodies = this.get('bodies');
        for (var i = 0, len = bodies.length; i < len; i++) {
            var body = bodies[i],
                pos = body.GetPosition(),
                angle = geo.radiansToDegrees(body.GetAngle());
            body.sprite.set('position', new geo.Point(pos.x * PTM_RATIO, pos.y * PTM_RATIO));
            body.sprite.set('rotation', angle);
        }
    },

    play: function() {
        var world = new box2d.b2World(
            new box2d.b2Vec2(0, 0),
            true                  //allow sleep
        );
        this.set('world', world);

        var listener = new box2d.b2ContactListener();
        listener.redJustScored = false;
        listener.blueJustScored = false;
        listener.puckHitPaddle  = false;
        listener.puckHitWall    = false;
        this.set( "contactListener", listener );

        listener.BeginContact = function( contact ) {
          var fixtureA = contact.GetFixtureA();
          var fixtureB = contact.GetFixtureB();

          var fixtureAData = fixtureA.GetBody().GetUserData();
          var fixtureBData = fixtureB.GetBody().GetUserData();
          var otherFixtureData;

          // pucks are the only important thing, so find out which fixture is the Puck, if it's not we don't care about the contact
          if( fixtureAData == TAGS.kTagPuck ) {
            otherFixtureData = fixtureBData;
          } else if( fixtureBData == TAGS.kTagPuck ) {
            otherFixtureData = fixtureAData;
          } else { return; }

          // scored goal
          if( otherFixtureData == TAGS.kTagBlueGoal ) {
            console.log( "RED SCORED" );
            this.redJustScored = true;
            return;
          } else if( otherFixtureData == TAGS.kTagRedGoal ) {
            console.log( "BLUE SCORED" );
            this.blueJustScored = true;
            return;
          }

          if( otherFixtureData == TAGS.kTagPaddle ) {
            this.puckHitPaddle = true;
            return;
          }

          if( otherFixtureData == TAGS.kTagWall ) {
            this.puckHitWall = true;
            return;
          }
        }

        world.SetContactListener( listener );

        this.playSound( "buzzer" ) // game start

        /* ------------------------------------------------------------------------------
         * ------------------------------------------------------------------------------
         *                                GAME ELEMENTS
         * -----------------------------------------------------------------------------
         * -----------------------------------------------------------------------------
         * Z indexes:
         *
         * Background: -1
         * Walls     : 0
         * Score     : 10
         * Puck      : 20
         * Paddle    : 20
         * Goal      : 30
         * Red Wall  : 30
         * Blue Wall : 30
         *
         * ------------------------------------------------------------------------------
         *  Collision Filters
         *
         *  Category:
         *    Wall   : 1
         *    Paddle : 2
         *    Puck   : 4
         *    Center : 8
         *
         *  Mask:
         *    Wall   : n/a
         *    Puck   : 3
         *    Paddle : 15
         *
         *
         *  */


        var winSize = cocos.Director.get( "sharedDirector" ).get( "winSize" );

        var background = cocos.nodes.Sprite.create( { file : "/resources/groundbg.png" } );
        background.set( "position", new geo.Point( winSize.width / 2, winSize.height / 2 ) );
        this.addChild( { child : background, z : -1 } );

        var boundaryBodyDef    = new box2d.b2BodyDef;
        var boundaryFixtureDef = new box2d.b2FixtureDef;

        boundaryBodyDef.type = box2d.b2Body.b2_staticBody;
        boundaryBodyDef.userData = TAGS.kTagWall;

        boundaryFixtureDef.density     = 1.0;
        boundaryFixtureDef.restitution = 0.2;
        boundaryFixtureDef.friction    = 0.5;
        boundaryFixtureDef.shape       = new box2d.b2PolygonShape;
        boundaryFixtureDef.filter.categoryBits = 1;

        /* ------------------------------
         * LEFT WALL
         * ------------------------------ */

        /* left wall size : 16 x 480 */
        boundaryFixtureDef.shape.SetAsBox( 8 / PTM_RATIO, 240 / PTM_RATIO );
        boundaryBodyDef.position.Set( 8 / PTM_RATIO, 240 / PTM_RATIO );

        var leftWallSprite = cocos.nodes.Sprite.create( { file : "/resources/sLeftWall.png" } );
        leftWallSprite.set( "position", new geo.Point( boundaryBodyDef.position.x * PTM_RATIO, boundaryBodyDef.position.y * PTM_RATIO ) );
        this.addChild( { child : leftWallSprite, z : 0 } );

        var boundaryBody = world.CreateBody( boundaryBodyDef );
        boundaryBody.CreateFixture( boundaryFixtureDef );
        this.get( "bodies" ).push( boundaryBody );
        boundaryBody.sprite = leftWallSprite;

        /* ------------------------------
         * RIGHT WALL
         * ------------------------------ */

        /* right wall size : 16 x 480 */
        boundaryFixtureDef.shape.SetAsBox( 8 / PTM_RATIO, 240 / PTM_RATIO );
        boundaryBodyDef.position.Set( (winSize.width - 8) / PTM_RATIO, 240 / PTM_RATIO );

        var rightWallSprite = cocos.nodes.Sprite.create( { file : "/resources/sRightWall.png" } );
        rightWallSprite.set( "position", new geo.Point( boundaryBodyDef.position.x * PTM_RATIO, boundaryBodyDef.position.y * PTM_RATIO ) );
        this.addChild( rightWallSprite );

        var boundaryBody = world.CreateBody( boundaryBodyDef );
        boundaryBody.CreateFixture( boundaryFixtureDef );
        this.get( "bodies" ).push( boundaryBody );
        boundaryBody.sprite = rightWallSprite;

        /* --------------------------------
         * RED WALL
         * -------------------------------- */

        /* red wall size : 320 x 22 */
        boundaryFixtureDef.shape.SetAsBox( 160 / PTM_RATIO, 11 / PTM_RATIO );
        boundaryBodyDef.position.Set( (winSize.width / 2) / PTM_RATIO, 11 / PTM_RATIO );

        var redWallSprite = cocos.nodes.Sprite.create( { file : "/resources/sredBar.png" } );
        redWallSprite.set( "position", new geo.Point( boundaryBodyDef.position.x * PTM_RATIO, boundaryBodyDef.position.y * PTM_RATIO ) );
        this.addChild( { child : redWallSprite, z : 0 } );

        var boundaryBody = world.CreateBody( boundaryBodyDef );
        boundaryBody.CreateFixture( boundaryFixtureDef );
        this.get( "bodies" ).push( boundaryBody );
        boundaryBody.sprite = redWallSprite;

        /* --------------------------------
         * BLUE WALL
         * -------------------------------- */

        /* blue wall size : 320 x 22 */
        boundaryFixtureDef.shape.SetAsBox( 160 / PTM_RATIO, 11 / PTM_RATIO );
        boundaryBodyDef.position.Set( (winSize.width / 2) / PTM_RATIO, (winSize.height - 10) / PTM_RATIO );

        var blueWallSprite = cocos.nodes.Sprite.create( { file : "/resources/sblueBar.png" } );
        blueWallSprite.set( "position", new geo.Point( boundaryBodyDef.position.x * PTM_RATIO, boundaryBodyDef.position.y * PTM_RATIO ) );
        this.addChild( { child : blueWallSprite, z : 0 } );

        var boundaryBody = world.CreateBody( boundaryBodyDef );
        boundaryBody.CreateFixture( boundaryFixtureDef );
        this.get( "bodies" ).push( boundaryBody );
        boundaryBody.sprite = blueWallSprite;

        /* --------------------------------
         * RED GOAL
         * -------------------------------- */

        /* red goal size : 136 x 14 */
        boundaryFixtureDef.shape.SetAsBox( 68 / PTM_RATIO, 8 / PTM_RATIO );
        boundaryBodyDef.position.Set( (winSize.width / 2) / PTM_RATIO, (11 + 3.5) / PTM_RATIO );

        var redGoalSprite = cocos.nodes.Sprite.create( { file : "/resources/goal.png" } );
        redGoalSprite.set( "position", new geo.Point( boundaryBodyDef.position.x * PTM_RATIO, boundaryBodyDef.position.y * PTM_RATIO ) );
        this.addChild( { child : redGoalSprite, z : 0 } );

        var boundaryBody = world.CreateBody( boundaryBodyDef );
        boundaryBody.CreateFixture( boundaryFixtureDef );
        this.get( "bodies" ).push( boundaryBody );
        boundaryBody.sprite = redGoalSprite;

        boundaryBody.SetUserData( TAGS.kTagRedGoal );

        /* --------------------------------
         * BLUE GOAL
         * -------------------------------- */

        /* blue goal size : 136 x 14 */
        boundaryFixtureDef.shape.SetAsBox( 68 / PTM_RATIO, 8 / PTM_RATIO );
        boundaryBodyDef.position.Set( (winSize.width / 2) / PTM_RATIO, (winSize.height - 10 - 3.5) / PTM_RATIO );

        var blueGoalSprite = cocos.nodes.Sprite.create( { file : "/resources/goal.png" } );
        blueGoalSprite.set( "position", new geo.Point( boundaryBodyDef.position.x * PTM_RATIO, boundaryBodyDef.position.y * PTM_RATIO ) );
        this.addChild( { child : blueGoalSprite, z : 0 } );

        var boundaryBody = world.CreateBody( boundaryBodyDef );
        boundaryBody.CreateFixture( boundaryFixtureDef );
        this.get( "bodies" ).push( boundaryBody );
        boundaryBody.sprite = blueGoalSprite;

        boundaryBody.SetUserData( TAGS.kTagBlueGoal );

        /* --------------------------------
         * CENTER LINE
         * -------------------------------- */

        boundaryFixtureDef.filter.categoryBits = 8;
        boundaryFixtureDef.shape.SetAsBox( (winSize.width / 2) / PTM_RATIO, 1 / PTM_RATIO );
        boundaryBodyDef.position.Set( (winSize.width / 2) / PTM_RATIO, (winSize.height / 2) / PTM_RATIO );

        var centerLineSprite = cocos.nodes.Sprite.create( { file : "/resources/centerLine.png" } );
        centerLineSprite.set( "position", new geo.Point( boundaryBodyDef.position.x * PTM_RATIO, boundaryBodyDef.position.y * PTM_RATIO ) );
        this.addChild( { child : centerLineSprite, z : -1 } );

        var centerBody = world.CreateBody( boundaryBodyDef );
        centerBody.CreateFixture( boundaryFixtureDef );
        this.get( "bodies" ).push( centerBody );
        centerBody.sprite = centerLineSprite;

        /* ----------------------
         * PUCK
         * ---------------------- */

        /* puck size : 47 x 47 */

        var puckBodyDef = new box2d.b2BodyDef;
        var puckFixture = new box2d.b2FixtureDef;

        // puck is a little off-center, so adjust by (-1,-1) px
        puckBodyDef.position.Set( (winSize.width / 2 - 1) / PTM_RATIO, (winSize.height / 2 - 1) / PTM_RATIO );
        puckBodyDef.type = box2d.b2Body.b2_dynamicBody;

        puckFixture.density = 1.0;
        puckFixture.friction = 0.9;
        puckFixture.restitution = 1.0;
        puckFixture.shape = new box2d.b2CircleShape( (47 / 2) / PTM_RATIO );
        puckFixture.filter.categoryBits = 4;
        puckFixture.filter.maskBits = 3;


        var puckSprite = cocos.nodes.Sprite.create( { file : "/resources/spuck.png" } );
        puckSprite.set( "position", new geo.Point( puckBodyDef.position.x * PTM_RATIO, puckBodyDef.position.y * PTM_RATIO ) );
        this.addChild( { child : puckSprite, z : 20 } );

        var puckBody = world.CreateBody( puckBodyDef );
        puckBody.sprite = puckSprite;
        this.get( "bodies" ).push( puckBody );
        puckBody.CreateFixture( puckFixture );

        puckBody.SetUserData( TAGS.kTagPuck );
        puckBody.SetFixedRotation( true );

        this.set( "puckBody", puckBody );

        /* ----------------------
         * PADDLES
         * ---------------------- */

        var paddleBodyDef = new box2d.b2BodyDef;
        var paddleFixture = new box2d.b2FixtureDef;

        paddleBodyDef.type = box2d.b2Body.b2_dynamicBody;
        paddleBodyDef.fixedRotation = true
        paddleBodyDef.userData = TAGS.kTagPaddle;

        paddleFixture.density = 1.0;
        paddleFixture.friction = 0.2;
        paddleFixture.restitution = 0.5;
        paddleFixture.shape = new box2d.b2CircleShape( (55 / 2) / PTM_RATIO );
        paddleFixture.filter.categoryBits = 2;
        paddleFixture.filter.maskBits = 15;

        /* ----------------------
         * RED PADDLE
         * ---------------------- */

        /* redPaddle size : 55 x 55 */
        paddleBodyDef.position.Set( (winSize.width / 2) / PTM_RATIO, (winSize.height / 5) / PTM_RATIO );

        var redPaddleSprite = cocos.nodes.Sprite.create( { file : "/resources/spaddle.png" } );
        redPaddleSprite.set( "position", new geo.Point( paddleBodyDef.position.x * PTM_RATIO, paddleBodyDef.position.y * PTM_RATIO ) );
        this.addChild( { child : redPaddleSprite, z : 20, tag : TAGS.kTagPaddle } );

        var redPaddleBody = world.CreateBody( paddleBodyDef );
        redPaddleBody.sprite = redPaddleSprite;
        this.get( "bodies" ).push( redPaddleBody );
        redPaddleBody.CreateFixture( paddleFixture );

        this.set( "redPaddleBody", redPaddleBody );

        /* ----------------------
         * BLUE PADDLE
         * ---------------------- */

        /* bluePaddle size : 55 x 55 */
        paddleBodyDef.position.Set( (winSize.width / 2) / PTM_RATIO, (4 * winSize.height / 5) / PTM_RATIO );

        var bluePaddleSprite = cocos.nodes.Sprite.create( { file : "/resources/spaddle.png" } );
        bluePaddleSprite.set( "position", new geo.Point( paddleBodyDef.position.x * PTM_RATIO, paddleBodyDef.position.y * PTM_RATIO ) );
        this.addChild( { child : bluePaddleSprite, z : 20, tag : TAGS.kTagPaddle } );

        var bluePaddleBody = world.CreateBody( paddleBodyDef );
        bluePaddleBody.sprite = bluePaddleSprite;
        bluePaddleBody.limits = { upper : { y : winSize.height / 2 } };
        this.get( "bodies" ).push( bluePaddleBody );
        bluePaddleBody.CreateFixture( paddleFixture );

        this.set( "bluePaddleBody", bluePaddleBody );

        var redScore = cocos.nodes.Label.create( { string : "0", fontName : "Helvetica", fontSize: "40", fontColor : "#ff0000" } );
        redScore.set( 'rotation', 90.0 );
        redScore.set( "position", new geo.Point( 40, winSize.height / 2 - 17 ) );
        this.addChild( { child : redScore, z : 10, tag : TAGS.kTagRedScore } );

        var blueScore = cocos.nodes.Label.create( { string : "0", fontName : "Helvetica", fontSize: "40", fontColor : "#0000ff" } );
        blueScore.set( 'rotation', 90.0 );
        blueScore.set( "position", new geo.Point( 40, winSize.height / 2 + 17 ) );
        this.addChild( { child : blueScore, z : 10, tag : TAGS.kTagBlueScore } );

        /*
        //setup debug draw
        var debugDraw = new box2d.b2DebugDraw();
            debugDraw.SetSprite(document.getElementById('debug-canvas').getContext("2d"));
            debugDraw.SetDrawScale(30.0);
            debugDraw.SetFillAlpha(0.5);
            debugDraw.SetLineThickness(1.0);
            debugDraw.SetFlags(box2d.b2DebugDraw.e_shapeBit | box2d.b2DebugDraw.e_jointBit);
            world.SetDebugDraw(debugDraw); */
    },

    getBodyAtPoint: function (point) {
        point = new geo.Point(point.x /PTM_RATIO, point.y /PTM_RATIO);
        var world = this.get('world');
        var mousePVec = new box2d.b2Vec2(point.x, point.y);
        var aabb = new box2d.b2AABB();
        aabb.lowerBound.Set(point.x - 0.001, point.y - 0.001);
        aabb.upperBound.Set(point.x + 0.001, point.y + 0.001);


        var self = this;
        function getBodyCB(fixture) {
            if(fixture.GetBody().GetType() != box2d.b2Body.b2_staticBody) {
                if(fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                    self.set('selectedBody', fixture.GetBody());
                    return false;
                }
            }
            return true;
        }


        // Query the world for overlapping shapes.

        this.set('selectedBody', null);
        world.QueryAABB(getBodyCB, aabb);
        return this.get('selectedBody');
    },

    mouseDown: function(evt) {
        var point = evt.locationInCanvas,
            world = this.get('world'),
            mouseJoint = this.get('mouseJoint');

        if (!mouseJoint) {
            var body = this.getBodyAtPoint(point);
            if( body && body.sprite.get( "tag" ) == TAGS.kTagPaddle ) {
                var md = new box2d.b2MouseJointDef();
                md.bodyA = world.GetGroundBody();
                md.bodyB = body;
                md.target.Set(body.GetPosition().x, body.GetPosition().y );
                md.collideConnected = true;
                md.maxForce = 300.0 * body.GetMass();
                mouseJoint = world.CreateJoint(md);
                body.SetAwake(true);
                this.set('mouseJoint', mouseJoint);
            }
        }
    },

    mouseDragged: function(evt) {
        var point = evt.locationInCanvas,
            world = this.get('world'),
            mouseJoint = this.get('mouseJoint');

        if (mouseJoint) {
            mouseJoint.SetTarget(new box2d.b2Vec2(point.x /PTM_RATIO, point.y /PTM_RATIO));
        }
    },

    mouseUp: function(evt) {
        var mouseJoint = this.get('mouseJoint'),
            world = this.get('world');

        if (mouseJoint) {
            world.DestroyJoint(mouseJoint);
            this.set('mouseJoint', null);
        }
    }
});

AirHockey = {}
AirHockey.start = function() {
  // Initialise everything

  // Get director
  var director = cocos.Director.get('sharedDirector');

  // Attach director to our <div> element
  director.attachInView(document.getElementById('cocos2d-app'));

  director.set('displayFPS', false);

  // Create a scene
  var scene = cocos.nodes.Scene.create();

  // Add our layer to the scene
  scene.addChild( { child: Splash.create() } );

  // Run the scene
  director.runWithScene( scene );
}

}};
__resources__["/resources/anscaLogo.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/ball.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/bg.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/blueBar.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAAYCAYAAADXsGegAAAC7mlDQ1BJQ0MgUHJvZmlsZQAAeAGFVM9rE0EU/jZuqdAiCFprDrJ4kCJJWatoRdQ2/RFiawzbH7ZFkGQzSdZuNuvuJrWliOTi0SreRe2hB/+AHnrwZC9KhVpFKN6rKGKhFy3xzW5MtqXqwM5+8943731vdt8ADXLSNPWABOQNx1KiEWlsfEJq/IgAjqIJQTQlVdvsTiQGQYNz+Xvn2HoPgVtWw3v7d7J3rZrStpoHhP1A4Eea2Sqw7xdxClkSAog836Epx3QI3+PY8uyPOU55eMG1Dys9xFkifEA1Lc5/TbhTzSXTQINIOJT1cVI+nNeLlNcdB2luZsbIEL1PkKa7zO6rYqGcTvYOkL2d9H5Os94+wiHCCxmtP0a4jZ71jNU/4mHhpObEhj0cGDX0+GAVtxqp+DXCFF8QTSeiVHHZLg3xmK79VvJKgnCQOMpkYYBzWkhP10xu+LqHBX0m1xOv4ndWUeF5jxNn3tTd70XaAq8wDh0MGgyaDUhQEEUEYZiwUECGPBoxNLJyPyOrBhuTezJ1JGq7dGJEsUF7Ntw9t1Gk3Tz+KCJxlEO1CJL8Qf4qr8lP5Xn5y1yw2Fb3lK2bmrry4DvF5Zm5Gh7X08jjc01efJXUdpNXR5aseXq8muwaP+xXlzHmgjWPxHOw+/EtX5XMlymMFMXjVfPqS4R1WjE3359sfzs94i7PLrXWc62JizdWm5dn/WpI++6qvJPmVflPXvXx/GfNxGPiKTEmdornIYmXxS7xkthLqwviYG3HCJ2VhinSbZH6JNVgYJq89S9dP1t4vUZ/DPVRlBnM0lSJ93/CKmQ0nbkOb/qP28f8F+T3iuefKAIvbODImbptU3HvEKFlpW5zrgIXv9F98LZua6N+OPwEWDyrFq1SNZ8gvAEcdod6HugpmNOWls05Uocsn5O66cpiUsxQ20NSUtcl12VLFrOZVWLpdtiZ0x1uHKE5QvfEp0plk/qv8RGw/bBS+fmsUtl+ThrWgZf6b8C8/UXAeIuJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACMUlEQVR4Ae3cvU7DMBDA8XPq0PIlgZiYqAQPwAALEy/Bm7DwArwhEhMDKzAUKLRNYnNOguRWVdXtln+ktEka6ayfq5N1seOOr+8f3WD4EJtZlHZzTqQ/7C7wiQACCCBgIFAYxCQkAggggMAWAiToLZC4BQEEELAQIEFbqBMTAQQQ2ELAr79Hy9BsCCCAAAKmAl2CTs8FhaRs2hMERwABBFYEfBEW4kIhMS76n0jUK0acIoAAAiYCfrpzKs7vSqx/TRpAUAQQQACB9QJ+tncp4g9Equ/1d3AVAQQQQMBEwEsIIkEXpqQ9LVBp69EsVDHpDYIigAACmYCXuh85N1O9nBJzqkGToDMjDhFAAAETAU3QKTHr9v/dnfGJAAIIIGAsoAn6SwfMjUjzY9wUwiOAAAII5AJeqk9N0JWOoPtZHMyyy304RgABBMwEdAQ90QQ91xH0rG8ENWiz3iAwAgggkAl0NeigI+iQJ+jsDg4RQAABBEwEUomjkaJMZY5GJ2+k4TMvUDLpCoIigAACywJeHw4eSqELVUKl7+Vget0yD2cIIICAnYAuVKmeZP7xLKEudTbHkSbpUd8csrVdvxAZAQQQ0JLG+HYk7y/numDlRhP0lcRwoi48KeTPgQACCBgLuBi18OxcGjVf6H6m+75xmwiPAAIIIKACOlK+G8j4rZTJ61Bqn8oc+u7R4MQVsf2GCQEEEEDARKAdQZtEJigCCCCAwEYBptRt5OFHBBBAwE7gDysDcVLiUr8ZAAAAAElFTkSuQmCC")};
__resources__["/resources/bluePlayerWins.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/centerCircle.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAYAAADHcWrDAAAC7mlDQ1BJQ0MgUHJvZmlsZQAAeAGFVM9rE0EU/jZuqdAiCFprDrJ4kCJJWatoRdQ2/RFiawzbH7ZFkGQzSdZuNuvuJrWliOTi0SreRe2hB/+AHnrwZC9KhVpFKN6rKGKhFy3xzW5MtqXqwM5+8943731vdt8ADXLSNPWABOQNx1KiEWlsfEJq/IgAjqIJQTQlVdvsTiQGQYNz+Xvn2HoPgVtWw3v7d7J3rZrStpoHhP1A4Eea2Sqw7xdxClkSAog836Epx3QI3+PY8uyPOU55eMG1Dys9xFkifEA1Lc5/TbhTzSXTQINIOJT1cVI+nNeLlNcdB2luZsbIEL1PkKa7zO6rYqGcTvYOkL2d9H5Os94+wiHCCxmtP0a4jZ71jNU/4mHhpObEhj0cGDX0+GAVtxqp+DXCFF8QTSeiVHHZLg3xmK79VvJKgnCQOMpkYYBzWkhP10xu+LqHBX0m1xOv4ndWUeF5jxNn3tTd70XaAq8wDh0MGgyaDUhQEEUEYZiwUECGPBoxNLJyPyOrBhuTezJ1JGq7dGJEsUF7Ntw9t1Gk3Tz+KCJxlEO1CJL8Qf4qr8lP5Xn5y1yw2Fb3lK2bmrry4DvF5Zm5Gh7X08jjc01efJXUdpNXR5aseXq8muwaP+xXlzHmgjWPxHOw+/EtX5XMlymMFMXjVfPqS4R1WjE3359sfzs94i7PLrXWc62JizdWm5dn/WpI++6qvJPmVflPXvXx/GfNxGPiKTEmdornIYmXxS7xkthLqwviYG3HCJ2VhinSbZH6JNVgYJq89S9dP1t4vUZ/DPVRlBnM0lSJ93/CKmQ0nbkOb/qP28f8F+T3iuefKAIvbODImbptU3HvEKFlpW5zrgIXv9F98LZua6N+OPwEWDyrFq1SNZ8gvAEcdod6HugpmNOWls05Uocsn5O66cpiUsxQ20NSUtcl12VLFrOZVWLpdtiZ0x1uHKE5QvfEp0plk/qv8RGw/bBS+fmsUtl+ThrWgZf6b8C8/UXAeIuJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAgAElEQVR4Ac2dCZRdxXnnv/v69a5udUtqqbUgtRYkNoFBLDYCWxBsFsc+CbYx9rEhhgjFxoeZ5NiZOZ7MSO2c+CRjn8yMHTsBjBfiYIJj40lsDDEDwiAMGFmANhASWlBra/WibvW+3Pn/ql61bj+9fv1atOTUO/fdreqrr/711VdffVX33iiOYzuTIVJYZVZUZxY/EsdD2XlfEkV1abO5kdnZcSq1WPfnx1G8wGKbPWxWa3E0VcdTdV1RdBTZMYviYymzNh0fjOJor67vi4aHd6lkbw6aNf02jpt1bVS4JYqKdDFabzYkDM4oCNGZyk9Yp1aZpZ6OY+FwIlwVRVUC81yV+t3DllohgJcLyoZhi2oEZAQauq9LowPnoJ4MnCuNu640wymLVSG2RxWxJWXDL+v+C7q//bk47kymuyaK0usVX1iQ1WkPpx30XGBfGkXFkuYLBcAHVMIbBPBF2kt6oxFwPYCxFetKcakNK0FXOmXdJWnrTaVsoChlg0PDlh4etuL+QSsbHLaKgUGrHOiz1IDoiOYoWplqU4uIX1Vejwvdf1ftv/ZyHA8ElM8U+KcNdIHt1EhSsi+PovpSs5skpR9WQVcK5BlILBsSWqKj8nLrqy6z5mmVdlD7A7PKbd+cKjsyrczaq0utY2qJdVeVWt/UUus/1mclnX1WeqzfKtr6rPpYr9Uc6LSZzT02v73X5rR22eyOXqvr6bHSflcRvhX4FhIfVZYbdPyvfWaPvRTHh3TuQgb806Z2Tgvo6Eu4DzpbhZin048K3E9ru4RC046JVKZtarW1zay2XfOqbPuSabb9nGm297wZdsimWLdqYsBKbcj6FH1Y26DqpygjyhJb3YktrTspHYV4/Wogx61i21Grf73VFuxstXP3d9q5Rzps8bEOq+1VnnQmVDQVLn42aXtQh/8iIdmvvWWXgWuTFSYVdKR7hVk6NNnro2imwL1N2+0q1AUUkA2gqyutZ+ZU27mo1jZeXG+/WXmWvZmeqc4Q8AYEo6RTABcLzrSugE9S+7jTUX90qQSqRqpHqQZMrUYUBqmswQNWu+Ggnb3pkF32VputOHLMlnR0WTkVQEI28Sbdb9/vVgVsiOMjumSowo1mg9L3sD4pYdJARzLOF99rM53RDVH0ERXkC+JSHaQPldrV1ljLwhn2awH93JVzbWvtHEk0ktojiHpUH4BMAOpYgMUCr1ibaRvUNWSdO0j7iX1a8Wk4xCzWHba0YroW5yqh3HpdDmopbQes/vkmO18VcNXuo/aetnab3kWeCr527QUh/LXH4/jHXGuUEbBV9RJaLtfeSZgU0KU+0mqWzir5/Si6QIx/QUB/UqAXA3iFtroaa15SZ7+6osGeXHm2bbFq69KvVAqEugAkAO1z8Kd0Z1BbsaqhWGB1Wr/UzJDawbB01klmpnRBkYzJlGIVWZVTSGUCv1ywVypFpe6UK3Wpqyoqr0K0K5VXh1VueN0uePFtu25ns723ud3qJOUOeIE+oHI8JP6/9rM43qLLliwn56ca3hHo0ibROjVoSbcD/A+j6E4B/d/F7AIulGhTh9i1bI49sWqhPXbxEtuuwvZK31YO9lqFE2lZIwKmQ6C3C7QOlbjLvidAJqM5iz/7I4EN8CWq5thqRL9aFVoGf+kyVfkU5ddlZZt22rnrd9tNbxyw69UBV/ZzX5tA36sK+MtH4/gBnSL16XXv0LY/ddBVoFskFDQ5SXetxPUr4ulPBDqMutHL/Hn2m6sW28PXLLcXVXQHtoAtF8DYgtjKRwVAi+Sz0+49Ybrpug+AFjQphMcLybi5Km1NVCyJrxKa00Vqho6naEupQnoc+H1W9vRmu+K5XXbrvv122TFFQt1kyP6DVNCXJPVtqNJHKGauPMbjUfdPCXTVNryYJHz4tihiYPMtKc9VKF6ku26qHbl4of3w5gvs8dJ51qwxY4WTbDq5tM6K7LBk+qg9GAdVCjlxkwEZgE+xQI5O+MtH77YI6Z8hXurFVfWgwHeSP9W6+/Zb3U+22A2bdtsnmo/ZTKS+WJv02nqx9rkH43h7EoOQXaH7CYNOZoBNBp+RKS707xXgSwEc5dwwz3590/l2/3kXSG+jY9HZvtvrkoQfEOSHpJd7SO8CwBAmA2RHKM9frrxuicrVLOvF4xxtleJxyOl89SHbttgFj2211Xv223uQjgzwO1T4Nd+N4/XklMSD80LChEBPZnBXFH1YgN8vvTcT/VglQbhwmT30iXfbD9KzrFWdXqXYL1X7xIY4pO7rbXsgMfzOBUAhHE9GnFx53xlVCdWzxDOSjy3Up865a/CwTfvhC/ap196wT0ofFqHnVd4jAn71fXH8r7CTxKUQ9goGPUn4nij6qMTzfkl4DabEtHI7dvn59s0br7CfuUzVSUpiUk5vD9leu0+gB0nOVeBCOD0dcbJ54fwugR5Zg8CfIskflhGLQWO/eNF+/6Wtdndbj01Ft6rc7VKrq78ex//C/SQ+nOcLTjfni+DuBeZ08sUo+pCG8vfLDKyhuWkU2fTBS23djdfao05CeiThiEOx9PZx26wO8qADHBpsgB8qwBH/Hf4FXpK8wW+3veb4pxyUR5JP+SjnXJWXclN+cACPkRIkcBq5luNgXEkXnUg9depjslK+FEXvUy09gkpBqU+vtj2S7r9ausI2qVuscqAzqBmSKumw3SM2NcxMFOhQgLHShfs5CjXhvAKNJJ/Y/tW2UGrmLKcgUZMzrHPHRrtYUv/fWjqsAYlF1Wh/y5fj+JkfyaqRRYe3MthRgfKo/bigN8ouXSs7XPvzpFIeVS0vdSql0pquu9LWOcCPiL0i/RieDNlbdr/3X4xI9qgsxzhJgpjNdBKMMZKfdDkfvZMiZ11I5rdafqMiWySBYng2ZDOtA+CffN7WyZ6fKxWr7sp2COU/FE7bGjN4ZVEcdZoX9EDgr2WHi+hP1JxWYT5Vmx27+mprXL7SfmVJwItsh30z461LMj4qy6wT4hGygc6KlrMCsbtRZthFOLsOSfByjVgLzSOZZ5L/u6N6UV+aBP7VDfbeDc/a2g4NSTCT5alcXy7g/3MctzeOA/yYoNNUUCnw8dUo+pYIf1aEVUYbuvgS++srr7OfykaZ4lRKsSS8T4B/9xQAT4J9S1Ric6Uue5VNvxtJIkid9j31D8RLAnFnNEcSOFdgpKV/aecMc/Dg9mrfKb6O62r3SYOuJA1FyBuScT8j4EsF/IAkHlUzzY4//6T9wabf2n+VOVkkgVTm9vdfjOPPQTOJX3YedBUnB2W2LTMQ+9soukMl/yw6HDt8yVJ76Mr32M9VrHIHeJHYQMInAngoTAB8jabgGCFOw0hTNphsAOlnIoZlUdTIPNgp4AdHgEfGBzWy9CqNMfuJmYsB2R14GYdEbU3ULv5a1ed0uFYQ8hQhmpdyGTskK5ry3a0kw7ZMdBlPl4ND53Gbv2uHfRqBBKevRdHGL8hl4PAL5czKIaek3yd35l2aUflfUbRchP5NNbMAHTCr3n598w22VsU97np1Ok2zXZKmfY7uGJmMyjMZh1FhmaQ1tllOQRCRwYkG2J6e9pieVMKQNdkCe13DYOpfxYvmCvRlOkpOErlbLhUjeNISqBipRJ0fVTtokYDg0fUhyU+4lr1PxlkTzdftxcq7SGKH32bKo49b46FD9h6YVse6V6B86E/jeHPAMZucZypxtVH6CMBpHlIpX5J0O8A1a3PksovsfnUkbWK8QnUNIPtPGfA10WxRuVBUFih75Nq7bwPg8EQO2MpIbVojxiOqoBAiqQ4/pUGc0RtxqLxAExVEFzhg5yin5ZL++RpO49b3fQmg5gtB4omDgFFuyg8OwuNS4QI+EAEvcAM/cATPbNKjQFfepHOS1Gr2CUn5rXCuDsLOPsd+cBZDe/S4l74We0NmIYF0I83WXTn5LxlndbRQEc5RTgy70cN4xj1w2Sm5zl1mifoF+p9p2E6YpQaO+oAXUmaHQI89FEI++OIiO1sVdqHUxVmqAMGXUTO+/NmU/HkSeMo9rBZD3sIDXMAHxsAL3Frk2s4QGhbZUZU6CvSnFX+t/Crf01ymEv4ndDgdxKzZ9tzly+1x1SzTDSXKrEvUd9nTCR2bySHnLgDeKEfZXdFSQYQJBiNo39xgJwl54CkPnvAad2ut8o6lLgjczxdG54Gup9OtVue/VEcX2OeiWpc8CWwueuE+5ab84AAewuXyi+wX4ETzATeJ9z3gCJ73ei/xCMUR0BvlyFpFR+XD7Up8KSKvkVfnOUvtEZunOmV05n0pe0f8KDCSLwTAidNkS/Q/X6IA5F6686VN3vNVg7zLzZMJHVI4SDtjhFzSHuIl9ycqiEUDtABcvOdL6utdtABsMk3yOJQXP1KRXBzgAS5zrA2cJO2d4AZ+2t1O0oyaGcF65OB93nVs342iRZLyz6CIqLX6RfbEwuX2W9yzOk3p1yzvxEEde7XiDsb4SwJ+Z4R0n5UBG82dXzpzkSQNFrmzPBQBb2WJqpIwUXqeFv+ot1K1uWWGGepoZcxTd5Ljj3IRwAE8wEX4gBN4gRv4Cdw7HhKeOrSAL8cO9KSUqxP4uBItg6qmdg6p9n4uLd6rpliu2Lhk9zkLIgkolHKFIBWM6tLqMJFwOsaJAgTtABI2eNLUm6mCD6oVMidaqLQHXqHpeRkQV3gWz5ZVNNPdDryHuMl9aA3ektrncAEf4QRe4AZ+kvql2t1KUrQIOHPs/kItqMedqxr6BKaEwLe6Bnuq7myZabhpCbho79WqqUJCkIY10QwVbJGaMKrh1AD3YMKWFlXIciBAnw3dXiTXA4MigJso8NCCN9QEVlQscxA3LyGUwZ2M8Qce4EJosSngNavB/h/4wTCdKrhyO+CcakzoctXOjYq8PFNLRxYvsqcE94AaYLkodMpIO0Bix0w+SYBZ7q+JUEmLVSA/ijsVCT8BeKd42OlADvQDDxR80AFPDrmtGcd4nr8g8bh0S9Qq6fSDROdKlrwHLuCjuVfwWrDInlbBD4OjgAfPGyERpB1Jd9L+vSgqU63cjNmDPqqZby/ULZWUo8sp+KB0V/b0muKdFAIgqhmlWqgNqfFWykmRx7kQAGeBRrEM1G/GDO3RLvFISvIjPBBT8D0Z0E8NeOgg8cNWp/ZUx2lBAVzAB36F1yzhNnW+vQiOSB24rhe+GVqp1NqMXT7NbIVurszUTtfss+w51Xm30+UlshAqZCkQRkDNkMjeBUA+66a/GGli6k0swHwAHP+JFn3at+K2nESSEvf3sp9TgstPD04ceJ/rsFNTjARw7ybpZzOQvAc+4OR1ezf4Scq7wFNSfZWYx5rRcN4tbPXDat14v2qlWsBb5TR7fcFCTUB0qrl4RtrsG3Rg44QgdaiVQWepTFyPe8BpfajEY+Jgi3071lhNIdB3J4m/UHj2R6WCGDGip09d1dD3VKn/8H1ZIqsxD8EnVu8HXsIN/MCRgohIldT2+11a2e1cs19EUbUOrqWUhJqZtlF2ebO6Job7+MhbRmqcguUKyRYwJCmP1E4mola8ZNPuGIDhvGJedbN9PZb3NBPGypvbAXhcu/dJFRVJ1Xg6E+9c0QtwgRdovBDyZQ9O4AVuwq92prE82xklEuZrwBlyDnRdOFfbRZwI+Ja6OZoJYuiCN416G5TEFRp8zz9L7OaunGw6QZV4lUBxcc3utAdsq3NMjSXd2XQ4TwJwb7xLV3aIf5xdXp5CxRI3X6CVsADqW1IXhYRQUnCK5QwEN+E3Y469Ap4Ar+0i7c6DnANdf5dLy1dzs2KavTVzjoa4WnjjsibzpFeOVNkhKeUpjfBYxjbeiDMJtgcFXaoJbM1P4lRKApidX77zkI44zGAVSz2ltHqMUauv2NBfjKZCdcMTcWihg9LRgRb7fAHgCB6nYw434QeO4Mlt8JWKuZxoQdIvpZclTKmVxaIhrbqvMjUxrA4v5UlgfdST/xvlUWPpGiEpVQHgsKeAKWck+TWMjOrStk26e8uIe6GQ/FxGOf4CWNyiA56tiuzToA4wqeAk+IFPxhA4EzA2WJ/zncwjM+t0Nl5rS+YHXuAGfsJReG4XTWfFCOwVHKef1TM+OlkO+sqxr3q6QGe5Mk2EjqzPzcCo6RJ9nNAi2uhy332eiEyHhn6lOOwxynCMegnErXB0xE8ewB5Puk5Qz30U0nt6qJg35dg6qnLNU7614oCxA5INL5QOlYCb4YB8mW85oj7tMCbHuCHgA16lMnGH5M0UjsLzjVbpDeFbCs7gnZbQzdNQrAHQJf7NNTPUAeG99qFb0HiHPzIQCGdunrTrUgzWg0MKSQZgH8IS535dxzPXoeppG9VJBmkKYJ1E/BQvBClk78xOzSSt0YxT7OxwWmWZhAFxwId6UIYibg7v+CMNllibyvRITMWNHQI+4MVaZFzIwhE8wVX4ztPWAN5pdc9n66SGNCU1drBylvQqC/L94vqukYnefGCEe/MF6AGpiZSzXJAchtfI0YD2+G96ND7tGZFqinC6wIZ2CIE/L7mx3etcwke1iIc5sBonZEXS+0kXB5McaSmmSFuNi7/DkQs0Au2wD3lgPa2J6IAZ0pWCJ7jG7Q70GvDWs1O2SKPQCNuofIo8dgyIBtD7DrKMlGeG9SGDsfbeAUQfML61cybAzuYTYJL5ftUtYD3ZQrkjqhMCCyUsVdpoBWm7Jzo0qmVm0+Y8VAgC5g3ONHiWCNeedrtM9nokj+GilLrq+RJ/0VY7q9AiIXwtTG8x8C9S4omEUKCx0uDPCHEAIEjHWPFPx/WQr+Mj40IIPJHfHZpNSsu0G9IkBz2bd6Tp8TL1A4RkxbkLOf7ADfzAUXiCK/iCM3ijuxdkVPVwmZY4Sw0MObh5eCSWQiCMp8thOhQGYA87fcaEBwvy+fUpe5pvd0Gdksv0NP+FCg+8kx3Td7h36YvSblDoDQDuFUvqk3G5lh0CTuCGD2dQprPwdLhK3eh2Smq8Ia2/2aTVvqukUsBgOBGGlaRbWyEhFABfNKNRmmWyI5UOU+iSy3SbMwnHY76QPCcrTuCddS1p9TgEv3zDc805/dKQAFznLLr8HSrxwY1Jc4LwBFfw1VmV9vXo9Ok6AOnuMj2nqTpCh2GFsJ7FO6uIEGpRhycFpPttW6R087TReugi/KOGRPZWzFTRXCQn0ha1CjXbAvsJ0p+uEHi4R8PzIgGOFYOwYQAkA6PzWNph1zigB5xYgKcHjNVWkPkicBUoOL8AfTri7gYzAr23uNjVkc+wX9nzYFUhwbtBFygLWomfe8T+pa7ZOB52w/EZ6ljmOJJBwtzJ7+AvAH6NBnS9TmAqHMeMV5OBcyTdt1zKN34AN/Aj6Gk+cBWoTlWDN6CXZ3LpL+KhQuSc4L0V7jDnH0yHwPpWWEOP+UE2beXEfY65QgWUqDWEZRRJGoHWmdgHwMlrsYZCKfcMUn6fP2XAiCQUIjABP+HpcNWqOwDRVo5UO0I6GdTqIuYKT4BFBuMFVAv6DlDzBQ88frtKudDqXVSY/10BDwN3R3hC54l/uMvPP/FZlzzRIDyL/IAxzCsUIemDGZTTQzzeTVOaWEDC0wWlo2AMulNaF3VPpFn930FISvmAVF0hzrnAJl6biQbhOaSRqTAuyuDcT825h650oWSIp5apdQKuoULCVrGNaikkIE+MU5H2LtekC2uqhdCeaBxc0JEqHzEoNNBbFRoCfsITXMGXxNrwwzhzhpzLBniWGI8JASB5Cnm8oNfejFTUeHG575syrWPGiGo5kyom6ONIXpbYjbxpe+ODSSsN1tx45QS3IIjCE1wlya5lK6MOQHVOdl2s6NfrO3QrwJLWsQc9X6Oip8Z3PpG+AOlKy5b/nCT+TIZQufhVWNnl4c5XOs8dZUPt9jlTQAKZMCKS/AdK4IbKpTKFZ3+PVYEvNav90ZT+DpFO+8p+1gnSLfpQrAS+t85cyLnDweOXIue8nfMiBRgU9V5VMiFIX87Ik3gx5JPSSnhc3Ki68ULoYDGA/dLw8VIg0+Dm7RfhKdBrpT7otMH5EJK8J6NDUn16OtgNjiBOY2pTcsJ4jY9ly4RCmilxvIQhCx50l/gM/pUIdGTXjyHGKx1WC3H8e2fysRkogRv4gaMGRw5XjWszOO9JqQb2Ma4lfn+3ZvCxYPy6b5aZjW1hBKmBCZ7tR3bRZIUEpAdpZ8KD2SbCWE22EHqFxAn08Y/jzELFBSkeL71XL/3SCVTT+AHcEClwFJ4D3TbP4auU4A3ob2kFT8xQq/+4Bgp6I5CTAb+2j7VHYzf/UJAjAp1lw0hPoQWhLaFijrjOzGVzRv6GcVw5UNTSCwyIBxo910NkSRJBEHlGA/xoS8Kz77jNA19wFt67sdPf1AFP/1p/u83uPayBC28EQlMPqaNj8EMIALuTrD9mVYo0z+llpzBpR9KRBpainYkQAMEZh3Cg4gpVh3hk/KKnsTkN+PjBIo/oMwLoA09wBV9wFjg7UjLS9+tkDz2K1EzdsRat4/MjKDKo0EyQByWXXFCQkFmXQIcxdFmh0k5c3L9nKsArHu6JBNoufvVe5yX0KUMFJukEfDxefp5fOLYJT3AFX3AG79TVelGk7PgtXNRWKtB5LAUwmD4uV/fhmRxPflnPNyxlgRQVEpB030H5Xj5XQQqhU0icIBh3CXK3vl2JChEM4lAelogzt0sItNxJ4i/gA17g5vEr6my1ZeCawXcLeDuAVAMvQ5F0x/VmN0l3rZIx5VQiqT9h1uXKMCntRUpZJNWF2shXKIoSuqTgv0/wf9oOeYSA2ZyQdyEZoSYirX/Pt/YHXILQgBe4gZ9wPN5iPGnuakzAbyRLB7pOXpLYd1AbPa226OgB+d7wOPLeN2a1eai2kMDM0KCyIhSiLz3N4I/zZ4X856r8QtLhWaLfyScQgQ5xaIusOOtzqtNLeQA3xEvuPU5THW7CDxzB0+EqfFXXLxLdgS71sk03XuWmJkWnHzlgF7umz4O5dDy149jT2dLOQkq0ZyGFSzKdPAbYsCWvc5yr4CFuvgrpE0cTC6jZZkl5e0HJwAm8/APNkXB8F3hKk6C6XwVn6DjQb4xjauEpvOxEONaslUhMTPCuE6yL2I3gfGHHKlQAnndxFesBKAYThXSqzMiGEIDjHHphC/fz7UNc9oRAK8kvQ5ZC+hwvLIxXjkt09o/QC7Tdhcwf9MN1cAIvcGuyGe3CETyZ3RfoT4MzqSSNMgm1fFc3fym9/qcyJao71Jnu3m3LF15tTyp5tapmulsj4pcskC5/+Lu4RWs/YHahiukNyaS6oVDBxgmWUpL5QJ3mWif9SEEGtfceDaaM6YYZITI455WZrCxGZgY0+e39ewEIR0vAEHiWZKpbHsK6+YwVp+vZvMEdBnNse3I+iOCIZf2xhsZPhvCap969r9hK4cj7zQCdZea/dCmEd7pR0r5WAt4qJS8zZYOGhzeK68rDTXbVwuP2vIrKErEp+p+hRFrDlTETRxXKkTvRErg3R9LepOxlLmlj0Ds6UBXYyn4az6clBiPGYTdMn6rq9i9mQDoZapCGjg1NS1rmqfCK8sOsYwCz2i306RS/Hco1s1gqI/0Mbj4T7VBlkXedKFF53mInbyrC63Ho79EC1INcdq0mV3mTggI+/tGZHgZETU12tQpdiSpRU96gnetEwZtrtAD7ozjuVaRHsWJA6OjbdsXhHTIfeW+hHyjNGnm0mwRjhVApLE3jGSFfyywU9c0+pPPyz5jU+fPdZR4KG3L9yTKdzxagVBppPTwnoNaLGRTTAx7aTali8jT0XOW0TIbARao0/1R0mB4kE6yQ2VqGHWuamWWeBIDmR15Ug0aNAnw3t8YE3N3M/OG1HJKrGJyEl3Bb1rrfrgDHDJ4/0RtFQjmHU2ulWhozz69L7zymprAZJdslIrt22zWqgWIVrlfVNVWNvN5lE4DN5HnSLtznGaF+LdxEAj14HniaMxtvF01nCs7j4v7BXuxcWGDq0IPrpfqkbFwsL6e+DYR0VIgHcLqoLFPjvkgtYOGI0CAQgNppryje6+Jhn1IcEE9NOt5eEOBJKQcX8AEn4SXcru0atFkUQgVnDPQYzIMzeHtnU0bab4vjpm9H0cNSgMtB52CT/d6hN+3J+nfpiYjDTDpIadytla/hgSsojRUAnvB96ffV0Q4BuExywCPuXudiuLGQ9OsxFQLENaoEVrqin0frWRchz19SJ5+IRgtG5bBamIpkiUWdVnDtHlkG7V9VGCTwREqOkqCOvjP6jHlW1vog5bPs+IFNdiG40XnSkQj4H94hXDOJnFZx1gvor89IuxB5WE1iB7XU2W31W3faB6WjfI+MzhrURC4hSLM7GeMPxgn3x4dV6O1ii9aGRDPbiPrBdeBDmVQJzRyYcoMYYha+D3RCC+B9AEV6JJ2lcyMhw+PIeeYgCE32dc6TFQIe4ILF0mGlb+yyG8AN/MBREvUwScAXnDl2oHPwTEbaPxvHbynBdxBHEDqw0z7w5ma7RDKI/qPLqi/oqWJFHlUxLLIf0FMRPOjqvRlH7Jsa6YXAy/gCSOHaZO2h62lTLLw9i9Vhz/fkM4bBRPIKFcKKNvAAF+Gzc5tdvH+3XQ9uZKTtu+AJ6YAvxyOgUwu8FIaLsm8eFMIb0Q8yLKu3vGkfY0irzsm/9cGsQaNU7/YN0kzCXCEwyD1eYlDvBgib1Xp2u0oJadDKdGWnO+Dj5iWdWC/BgzqRPEN5ffkbRIchP0vEazfvtI9rWD8V3AT8K1IxD0IaXIOUcz4COidrpIIaZUd+KY4PStr/DzXG1nTArn72VT31i7WMzqXTmCYbPDSzwAhE8gXirVUTu1efRnD6dFTTpuP0/UA+Gqdyz8s5so71XSoSrSrDrpF18knByEc/WV7KDw7gIVzAp2m/XR0wU7f0v/88jg80Ck9wTZIdBbryptDu2st6d7iah9NHDKO27bJP7dG7ZwX2cUGDXXYlEdYAAAqBSURBVFxvd+o1IgTSFQJ8iDcSN9PZOhpSX95ccyQn5S8JNmsRoV8kCyVyT+4VNrQPjATAOafclB8chMdbwgV83HBTt4XbPwu/H2SSpjK4Zk6zJJ2ra+N4cI2aA6/olp35FdXcXqrp6HGb+asttlrO21p52Xksm1FbgyyTWY5aANSd5PkjHlsIoQJKtGJ4SFIDOAGsEGci+2RaZm+g51vQYdlvW/UUxna3ZHtCNNUiA8+Ul3JTfnAQHhu22B+DDzgJL6Y//wr8wHGt8MzOapSkh5v3ZdSM3qq5WbX2l5g/NJt9TfaeR/WyXxUikh5j4XuJirXEPh9Nd2lhLIAYiI23D4XBDOX50dh12P5bGKQNILJPhuT1cA8nLGNXbyFxROt5Wwplswb/W52pOFEekxJOOSkv5fau7wg89jbZleADTsLry+DWKLUCjkmWw3FO0MVXvNWbmfYVve5OhO4lAe1x6+v2ySdflBlZ5UaSPG9ZIflcpoFHjSM60UK5RJk/3nPbrwELQ3A/aII/RolILN0sI9PI7TlHkoMJyj2sokHZAQxyUpLo2F6VVL9u+IJwAQBgEkQlzhuScSkf5aS8YKvyP/WS3QQeQU+BE3hBE/zAMRd9buS67q6pttJr1Tz+LIqmycD8sUybVSJsdZXW9oEV1njZlXppA28gBRQ8coN6PDz5HH8+4mPmmrnB0N2/r4t3NlYIQB4mZuCPNGPL06/064r/jkaRYjOl1iDpXpvjSbgkgOPlzf1k/D+Opikf3sfIyz8HtVClY+OvbeXjL9u65i6rxeSTSnlGUnHz38Zxa8BtrGzygk6iQODzUXS+quenEq0lqgCrr7WmDwv45ZfLkQPwfsDTLaZ2jIz4koxDrJCQK014vSvDKXSpX0+C32ZI/s+BESskmz60CBOt/CQPPPSV0huKooyEC/Ctv7FLfirAD7XZXJqidMhOZfQHfycF0ZgRVJfvGH/jgq78o4+p6dIxrI6ia0X8YdVoHe1j7jTbd9PF9jcrVthLmrbgiwAlgoSVBKNfckzmEyk4hZ5oGpdAf5OZNrzcGDOTdwzo/agbN9rlj22y/9LUavNhUqZhs7C49f44fopvZfxIAyUVdWz1AYvj3PdFSRTkTn0hQBQfVA3T7K1+qjW//wL76vuu1luQOtS98BYkeOH1H5EGQMG/DY2CMvNZjvyHvMOFQGOs6yHeRPdJ/ty7Gm2hhGieyBRJlHrUlnueedau/eUW++KhYxpYKajFHxPwtz3AFwMCP4G/PPnn7EhPii9CjaogrpOB9Pqd0mGt6Pe3xcDPXrO/+L9P2s06ZR6clwujdRdof6GhDwmBmcCcu1jAH+mSW0iSvBZoh3sT2Qd+Ag34hW/PP2tXmIAYpnw/22x/QXkpd6b8dzrAde7wCTTGyb8wSc8QaZQZtDbjtPl4FF2vGvu2tnno+OnyKF/YYD/61Ap7sGKuHFm8qZRmiZTwtqG0LIrgUYQehS2QyUz2k7vLzp+HFAblix+WdNNaUZMa+HQ3Wd0PNtptr+2xj7X0mj4O6ST8be1X/1McPwFTSVwKYXJCoIcM1jm5jeOPRNG7pd+/IwbOpfaxGRfOs5c/eJ79w8XvkrnWY+nBTqvSI3z4VZis3i8naLM6vhP2K4UnnIkKyJVXo9ZSHpC6QJUMWa0+sRmnqyTd5Ta46RW76Ofb7E9277dLMQuxUiRg26XH7/hxHL8gctE6iU8QRN0uKEwYdKg2SuLZk9nN/jtH39CF3wNJFPqc6XZkxQJ76KPn6ztHM/Vcfbe+c6S3dAp8bI+jsjcOybhrle2sVpoJAEL3QxVMZgWMRZf510rJcrGG80M2Q2Cn0xipFdbdddjqfrrNrt+41z55oMVm4nBnQCDAnxJ7n//Jmf7OkfJ2QWUZsWpu0muSxNQ6MXWPmHLP1uj7odZQZy+tXGT//P5ztd6Dz6d12JRBfVMu7ZcotInQUZWm1b1BKBvoABa5+baQvzKITwh2A2e5aPIgAq+c91/0qpWgFEsY6CiPC/KyX263Kza8ZR/f02yXt2qICTltQxKqbyju2sc0o1+olaKkOcMpSXqS0jWyS5/O+Bf0ZcZPq6xfljZpYJ6N6ZrpNfp23Sx7fNUCe+zSJZoaC+BrZJdmgONXhLWrZG2qgE4pn55xV8cmGRjvmDfO1aEsNIaMZPQNSwtqkKOn21J67wprHRzYL++0c57Zaze+fthubGm3yi51RAyDpW32CPT/oS82/iNZJcs7XtZj3X/HoGczom+Q8t3RP9d2qyoANajSyrCXylk8w569cr6+0rhYvpBpkqtugRG+DMDQGonjHVh8wrVHd6u08YXGBkG2TlBlSy7EQ0DS16kKcSDwpcZOKYpybQPq0FkHj10FP6g4HjOrUA6t+krjLlv+/D67btdRu7pZqgRThSD+B8Q/U5f/84n/SF9p9Oz5/+zvkV6nD1CJ8S/o7hXaq6z++Y/p06xl8XTbcGG9bVjJ90jnSr9jYAKDXnmCbkW89AwgQ3zeyMEqF3Q/fTU+d6YNcAH4sSl3+fkKxlHGAI21MsWDDNbU7FxfwiR4pSpRboS2JqvfoO+RvnbIVu5qsZUtrTZda8d1a0STvSiwv/Zk4sNR+FIYICrKOw6TIumBCwlbtEJ9Tvjy7rujaJZU++26f5uAP594oIPI6RPH3fVVtquhxjaqAn5z9VzbkZ4unxpDe76Xy9QAiyyA3k+1kdwHXF20fD8pAckTge4YyJkh4s3mvC9aj6AMtljNs022VEBftqfdLjnUaUv06eMKOknAJghoYWsPSpV//4VY87oK/6G/vAuDISD1HAfJeF8UnSXQP6Ltdm3vYiEAgdnpcimgmin6xvQU2zm32rYv1ovGltba3vPr1AJQL6yxpSLQ/rwswj9kg5Lw7i/Ap20Qh3khH4feoWKr3g62o80W7Gqzc5s69I3p47ak/bjV9qjNhEdC8Zyp1jaJnQfF1Y+fieO34S27DFybrDCpkp5kCqlfJUsmdLLce28UzZZUfVDAf0hiyitmpyPECCfiXKbSl1foS+lldqSm3A7qO2UHZlXavllV1qyvp7fV6m0SVfoab02Z9U7XUw4tel2Tvppe1imLyH1NXZ/4O9xpdYe79DX1PpvT3mOz9YX1mT3dVtqrjOncQ37ioUVaja+p/5uy/fmvNEUZ+L9GxsF6WSzqQhRt8sNpAz2wKuxTUjlFQeVwnSYrtXORFOQHBML1SL8at3svJKWkHfiXKOoNKGoJ2oaL5bot1WekUpH1lUjXl2nrld7u1zYcW2mfuscBPa6jB2VT2iTyONcTpj8ZW9wh2q/o6hNqiv+uAc9rW+ITY4WMKgHsoHFcqsn+O+2gB4YBf5VUelLyuXdVFFXJ/kXfXyGXzaUCBuunQZUxVQCBv6TTbxznC0R2CbRXmljg4pDao6v6Svqwpi3dm563PhcnPtGpixnJxjt4WsFWVi6cMdBHMsyALzddHHR+uMd+pT57L8DmqiLOVh0tjlOaBI7iBmntejV2eRqiGt3Hfw++ApZVInG7DMZ2KWe9wTTao7fA7VP3uEsDtjd1vyl8jh76IaCztdIpWq+IZwrskPf/B9VzEj6zVJ87AAAAAElFTkSuQmCC")};
__resources__["/resources/centerLine.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAAECAYAAACjpKVAAAAC7mlDQ1BJQ0MgUHJvZmlsZQAAeAGFVM9rE0EU/jZuqdAiCFprDrJ4kCJJWatoRdQ2/RFiawzbH7ZFkGQzSdZuNuvuJrWliOTi0SreRe2hB/+AHnrwZC9KhVpFKN6rKGKhFy3xzW5MtqXqwM5+8943731vdt8ADXLSNPWABOQNx1KiEWlsfEJq/IgAjqIJQTQlVdvsTiQGQYNz+Xvn2HoPgVtWw3v7d7J3rZrStpoHhP1A4Eea2Sqw7xdxClkSAog836Epx3QI3+PY8uyPOU55eMG1Dys9xFkifEA1Lc5/TbhTzSXTQINIOJT1cVI+nNeLlNcdB2luZsbIEL1PkKa7zO6rYqGcTvYOkL2d9H5Os94+wiHCCxmtP0a4jZ71jNU/4mHhpObEhj0cGDX0+GAVtxqp+DXCFF8QTSeiVHHZLg3xmK79VvJKgnCQOMpkYYBzWkhP10xu+LqHBX0m1xOv4ndWUeF5jxNn3tTd70XaAq8wDh0MGgyaDUhQEEUEYZiwUECGPBoxNLJyPyOrBhuTezJ1JGq7dGJEsUF7Ntw9t1Gk3Tz+KCJxlEO1CJL8Qf4qr8lP5Xn5y1yw2Fb3lK2bmrry4DvF5Zm5Gh7X08jjc01efJXUdpNXR5aseXq8muwaP+xXlzHmgjWPxHOw+/EtX5XMlymMFMXjVfPqS4R1WjE3359sfzs94i7PLrXWc62JizdWm5dn/WpI++6qvJPmVflPXvXx/GfNxGPiKTEmdornIYmXxS7xkthLqwviYG3HCJ2VhinSbZH6JNVgYJq89S9dP1t4vUZ/DPVRlBnM0lSJ93/CKmQ0nbkOb/qP28f8F+T3iuefKAIvbODImbptU3HvEKFlpW5zrgIXv9F98LZua6N+OPwEWDyrFq1SNZ8gvAEcdod6HugpmNOWls05Uocsn5O66cpiUsxQ20NSUtcl12VLFrOZVWLpdtiZ0x1uHKE5QvfEp0plk/qv8RGw/bBS+fmsUtl+ThrWgZf6b8C8/UXAeIuJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAuElEQVRYCe2XQQrCQBAEZ6PxkIOIP/T/iOAliknWasnCXnzAQA8U2SSXoTI0k3KLsYbLBhIYGKLGFFuc4Uq/jQvnCY6gYV7gDS+Y4Ql3eICeu2wgi4EhS6Pu0wZqlFhBAfzp0P226ylchQZbHGDcUYDrncsGshhwQGf5Uu7ztx3/C+gVP+1XsAW0wrmF9ImzgtoDjwRXGgOe1zSfyo3KgDblhZjtN2idFdBti9ZQ9/RbtAceOa40Br4ktyZxrjlGtwAAAABJRU5ErkJggg==")};
__resources__["/resources/crate.jpg"] = {meta: {mimetype: "image/jpeg"}, data: __imageResource("data:image/jpeg;base64,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")};
__resources__["/resources/goal.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAAAOCAYAAAD0U1SXAAAC7mlDQ1BJQ0MgUHJvZmlsZQAAeAGFVM9rE0EU/jZuqdAiCFprDrJ4kCJJWatoRdQ2/RFiawzbH7ZFkGQzSdZuNuvuJrWliOTi0SreRe2hB/+AHnrwZC9KhVpFKN6rKGKhFy3xzW5MtqXqwM5+8943731vdt8ADXLSNPWABOQNx1KiEWlsfEJq/IgAjqIJQTQlVdvsTiQGQYNz+Xvn2HoPgVtWw3v7d7J3rZrStpoHhP1A4Eea2Sqw7xdxClkSAog836Epx3QI3+PY8uyPOU55eMG1Dys9xFkifEA1Lc5/TbhTzSXTQINIOJT1cVI+nNeLlNcdB2luZsbIEL1PkKa7zO6rYqGcTvYOkL2d9H5Os94+wiHCCxmtP0a4jZ71jNU/4mHhpObEhj0cGDX0+GAVtxqp+DXCFF8QTSeiVHHZLg3xmK79VvJKgnCQOMpkYYBzWkhP10xu+LqHBX0m1xOv4ndWUeF5jxNn3tTd70XaAq8wDh0MGgyaDUhQEEUEYZiwUECGPBoxNLJyPyOrBhuTezJ1JGq7dGJEsUF7Ntw9t1Gk3Tz+KCJxlEO1CJL8Qf4qr8lP5Xn5y1yw2Fb3lK2bmrry4DvF5Zm5Gh7X08jjc01efJXUdpNXR5aseXq8muwaP+xXlzHmgjWPxHOw+/EtX5XMlymMFMXjVfPqS4R1WjE3359sfzs94i7PLrXWc62JizdWm5dn/WpI++6qvJPmVflPXvXx/GfNxGPiKTEmdornIYmXxS7xkthLqwviYG3HCJ2VhinSbZH6JNVgYJq89S9dP1t4vUZ/DPVRlBnM0lSJ93/CKmQ0nbkOb/qP28f8F+T3iuefKAIvbODImbptU3HvEKFlpW5zrgIXv9F98LZua6N+OPwEWDyrFq1SNZ8gvAEcdod6HugpmNOWls05Uocsn5O66cpiUsxQ20NSUtcl12VLFrOZVWLpdtiZ0x1uHKE5QvfEp0plk/qv8RGw/bBS+fmsUtl+ThrWgZf6b8C8/UXAeIuJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEUlEQVRYCe1YMQ7CMAxMoIAYkNjhG0i8h4F/MvMBRsrAhJDYKIKWu9aHGLPbli5H2iw+n3DjnFLKhjmYiPCtQIf0P8ATaCrTYgPeAguAhuEhcoQfBVhzxhiogQO56hA55z02O6AFRkCETwVU/yPSPwEXmWFmemjvU57IWvWfQgoiqcW8TRsyD0V7MUGcEb896Aly33JkEBmCLOBnhDMF/n3Qp66/FGc6RLqlCoRBSpVyei4M4rTwpWmHQUqV8nVOM5HfLUYPeA9m6GNl2MXqRQHWn4MyRu8B3WLEk+FdrE4VUEchv4BOxribIA9wXHNNDIfE+ccSqIErhuxtxpIwal/jwQqI1gIRnAdbzA04wxvNF7BULz1V3wEGAAAAAElFTkSuQmCC")};
__resources__["/resources/goalLine.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/groundbg.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/leftRightWall.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/paddle.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/playButton.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/ppaddle.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAYAAADFeBvrAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJAxAtJKuHlp0AABYQSURBVGjepXp5jBzXfeb3rjr6mqPnIDkiOeSQFEmJMk2JpCRKlkiTYYQECxiwYiOW1/85iezE3s0qWQX+I5ssIK+zu1jEcZwggLNex4JsJQ6i2LIMShaEkJRN0jRFWTah4Yw4M5wZXs3p6emjqt61f7yqmm6SPrDbwEP1THf1e1/9ru/3vUdw5xfputJ0sHRwAOKW4W3ZssXbsGGDTynlP/vZz8j8/DwBYNNB7nAlY2NjdseOHdYYo2ZnZ+OLFy8mABIA8pahAOh0mHTYdI32Tgu/0/9o+v5WIF42OOf+7t27g0qlEnz/+9+n6UQcQACg9MRv/mbftomJsNLfL8rlolhZXpHLzaaavHCh/d3vfncZQBNAlC6YHjp0yDQajejMmTMRgDgF1w2yG5hN5+sBRX4BmG6rdAMJAAR79uwJwzAMT5w4kVlx4Jlnnhm/d9euibVr144XCoVh4XkDQogiZ8zjnAuplNTaSCmTpkySpXa7ff3y4vzMz3564eJffP7zlwDcBGAPHDhgO51O5+zZs50UcHQLsFutlYMivwQMB+AVi0Wv1WoFAILNmzcX1q1bVzx+/DgDwI4cObLhqY9//IGNmzbt6e/r2xoEQTUsFCA4z33r572UUmi120jiuLZUr0/OvPfe2X/42tfOHDt2bBaA3v/II/r6wkJrenq6fQdg6k6gyC8AIwB4YRj6nU4nAFDYvW9faW5qKqjVanTv3r3rn/njP35806ZNHyiXy5tLxSIIpbDGQBsDSoghhFiQPGysm48A1sJaS4y1lFGa39dstbCysjI9PT39b//9C194/fTp03Plctns2LEjOnXqVBNAOwzDqNPpxLdYKwdFfhGYIAiCKIrCYrFYvO+++0pvvvmmAFD6q7/+60cfeGDvh4aGqluDIIA1BhawlBBDKSWMUgJCCKUUhJAeK1kA1loYYwBrrTbGGmOssZYSgBBKEUURarXa5OnTp//5008//W8Amg899JA8f/58s9VqtYIg6ERRFN0JFOkCRVMX4wD8DEy1Wi1NTExUTp06xTatXz/2pb/7u4+Ob9z465W+Pma0BnEgwBijjDFQQkAcHhC4660vCwtr02EsjLXQSkMbbYwxsLCUUoblRkPPXLr0ymd+//dfmJycnN+/f7+6ePHiSq1Wa3aBilP3UwAMu0PM+GEYZmDK27dvr/zgBz9gn/zkJ3f+2XPP/cGWiYlHA9+n1hjDGLOCcyo8j3DOwBmDA5VahpCfUxPcZ5RQUJoORsEYI9TdZIzWNvB9Njw8vO3QBz+4lTI2+68vvVTbtWuXB8AuLS3ZMAytUqo724HdIQH47XY7LBaL5e3bt1fefPNN/h+feWbPJz7xic+uX7/+bqUUGKWaC8E8TxDOORhlyNzL2lWXMsZAa90zjDG5dW4DR0gKzHmfMcZoY0i1Wh29e9u2nZW+vtl/fPHFqzt37hT1KLLtRqO7JlkAlnW5mSiXy36z2QwBFB966KG+kydP8j/47Gd3P/XUU/9hbGxso0wSIziD8DwqOAdjHCwHYqG1AyClRJIOmaxepVJQSkFplYLLXA+5RZ11aea6BLBWKWUHBgYHxsfH7/GDYOpb//RP1x7et4/PzMyYroRgMkAisw6lNFBKFQ4ePFh54403+Ec+8pGtv/O7v/uZu+66a3MSx4YLQbzUvRjjoKlLqXShUkokSYI4SZDEMeIkQZykYKRMgbrvaqWgjYHRutdiORj3oCilxMJCJtL29ff3jY+PT9Tq9Z++8vLL9X2PPMLmZ2fVrUkhTOMm7HQ6hQMHDvSfOHGiAGD49ddf/8y27ds/kCSJFZzD8zySxQmA3KUSqSCTxC1aKWiloVL3ylwsYzzpIkEpdTHHGQTnEEJAeB48wV0cUgoA0Nr9VpIkVioFIQSZfPfd4wcff/x/Aqi9733va7311lvLAFoAOgxAWC6X/VarFWzdurXUaDSKS0tLwQvf/OaHduzc+SEQQFBmPd+jjHHwLjBSSsRxjCgdcZwgSdxQSsIY7TIabOrk1tUpraG1SjObq1s5cGud+9E0plJgJPVrbQwplssbHnn0QOsfv/niO2NjY7TZbKokSXSW5QpJkgQAwnvvvbd87tw5/kf/+Y/ed/Dgod/p6+8rwFrtCY9xxsE5z5+aA5MgimIHKgei0kJAYCzcorVzMWOMs1LqTsZaF0taw1jj6lnueuixZobKGqOFELRYKG4oFgoXvvWtby0++OCDdGZmRgLQrFKplOI4Dh54+OHSm8eP+wAG//S//NnHN46P36ukNIILJoQAZ8wtIrdMgiiOEEUJ4jiBVNLNSQmSOEZrZQXNxjLarRV0Wi1E7TaiThuxozqwxrg4ZBTaWGijkdZagNjV7EdXS0D6EIhUihQKhUK1OuT9n69+9UdXl5bUutFRvby8rFgcxxUA4fj69cW5uTnx3HPPPbDn/vv/fej7ghJihScIZxyUUlhrIZVCEifOzaIEcRxDaw1CCZSUWF5aQrO+BGs0isUiBgcGUB0aQnVgAJW+PoS+D2M04nYb7XYbgIUQXmp545wzJYGUOFqUZdKsjFlrNaGUcsZH1m/cMPm973zn0r59++j09HTCAfD9+/f7J0+eZADK9+/d+9jAwEColTKe59GsxuSulri4iWNnGe3YAtqtNho3b4AzhnVjYxgeHUWlUoEfBOCc56ldKYU4itBYXsb1q1dRq9WQxDHKfQOgjEJJlXosyWOIUQrOef6eMUYTmaDcVynu3bv3cQA/unDhwsr4+LjPAFQnJiaKMzMz4tOf/vTdj37gAx8vFAoFSmCFcIWz29VczDjLKKVACEGruYL6jevo7+vDlm3bML5pE6pDQygUChBCgKWZkTEGIQTCMESlrw/9AwPwgwDNlRW0Wy0IzwdlNI81SoCUVuWul3JbYrXRjDEKa8thGL79ve99b2HPgw8SumXLFjE3N8cA8IcOHNhVLpeHtFKgjBOWZprMHVxalkhkAqUdmE67jfqNGxgeGsL2nTuxfuNGFEul3KqmizUYY2DSoKeUolgqYcP4OO7evh3FMMBKow5rstbC1SypXP3SWrv7iLMSZYxYrVEoFEYeevjhXQA4VYrT4eFh/t5771EAxXVr1+4IggCEUsMIISRblLHQWkFKlYLSgHUFdfnmDfT392Fi2zaMrFmTZ0JjjCu4WbGNY5cFpYTKMx7AOcfo2rXYvHUrfMHRbjbSDGnzYi3lKrNwiYeCUkoNYAvFIkZGR+8GUHr11VcJpZQyAOTJJ58cKpXLmy2QV+rMOm5xOp1Awxj3tFYadTBKsXHTJgwND+eJQxsDqZRL51GEThQhijrpNUIcx64AG8cSKKUYGR3FXes3QCsJmcSghKQPUadMZHVeSggYo0jbFRRLpQ0f+9jHRgEY2jaGASC7d+8eKYThGuuCPO9lVhmBgUoJJgBImSBqtjAyOorhkREIIXIXk0mCOF14FEWIOh10Ou6aAYqjCDKRuQtyzjE6Oor+vj7EnY6jQ6mrZ/PazEI55yOwAApBMPr+++9fAwA8qtcJADoyMrKGch7YtJZkSXKVOau0VriA7bQ74JxhaGQExVJpFbhSOVtIkgTGmPzB2LSQKq3gGS+PJZJmsGKphOrQEBorK9BKgQvRNa9jFTxlEnCFlxhjQBgrDA4OjgJgfHl5mQKgQ8PDg77wAGtBQXsW4dzIwuiM+hskcYRisYhKpbKaANJMqFJQ1lqEYZhbz1lWIooiJDIBpRRSqdWeiFJU+vrgex5kCshaC6Pd/NlaugotsVrDE4IODg4OAGB0aWkJAEixWCxxkQobpFfdcJ2lyYPSaGeJQrGIIAx7LKm1zoM+CAKEYdiTtsMwRBAEMNrkrNt0UZ7sc6tV2tm6B9VNi7IXTWub53koFItFAIR2Oh3nw54nKKUguRzUayH3W7YHoO/7eVbLXdOavNhyznuavWzhQggQQnJSarraB5Yy71yAIGnTbtHTZjifc9+irvAKAITmfMKYW/r+X6RFpr/XS0mQYV4lmKTHyreLCzZn2N1PnTCKX+llb1ucpWEYWgBWah07gSL7Ui/rdWtbVb0Ioa4563oQLlhJT/z1fHbrM0kFFXR9ZoyB1aZXjwLpIai9jw8kdfMEgKWDg4MWgFlptppSKrimt1cxzvuTNPtlARzHMaSUXamUpDWCwVqLJEmcGzGWiSAAgDiO8/qTaQnZQrPO1skcq/NlSlK3O5g0QSRSot1sNgEYOjAwYACYm9ev3UhkDIC43qTLbfK+hFGAEFBGwD0P7VYLURqDhBBQxsC565sYY0iSBO12O2UIqudv1vVdmrYmANCJIsRxAi5YSlIpGCOgtNdCqRRmCaWQSaJrN2/eBKB4GIYGgL5248YVo3SHAGFW1LKFMkbBKHPqDmOwyiIIQrSWl1BfXsZAtYpMk+NpUGcWyihPdywxxuB5HoQQDlDOFzUa9Tqk1vA9P69TlHIwysFYV8xawFhjCWUw2rSXl5auAFCUc64BmHNvvXW1E0VXiHMXa3q6RwrGUg0grTl+EAKU4frVq3DWdpNzpz3A8zz4vg/P93O2zBiD56f/T7+TtQWOSjVws1YDSR8ciHNX7qQtkDSHZfQK1mWFThJdO/vW+SsAQBljGoB98YUXbjRWVqYy+mKNtSalvm6hDEJwCMFS9yMolitYunkTVxYWcisQQiCEgO/7CIIgr0XZCAJXZ3zfz9M3ACRJgqtXrqDdieD5PgALRrM5OThnXQw+KwOWGmPQarYu/cNX//cVAITeuHFDbtmyRQNoLi4snI86HVhjqLar3IlSApZqCpmbEBAEhRAiCDE3O4sri4t5f5RZyvd9BBmwtGAGvu/ql+B5j6OUwuLCPK5evQrhu56I5O7Lwblw7TpN48dYGGMMJYS0mi1cWVz8CYDGE088YemFCxfkmjVrNAB5/MSJ8ysrK1eY4DBKW5VzN4AxCiEEPOHBE24CQghKff3QFpienMTC/HxuqczFnDwl4Anh3qcNH03dJ4ljzM/NYW5mDmAcPG3HBc/u8SCEi5+cLzo9zxLO0em0F948ceKtVJtTDEBhdHSULywsiDOnTkUf/vCHx4aHh3dorS2llGQpuofbuerpwBLA83x0Oh0s1WqOVHIOLsRtAkd3llJKYblex+W5OSwsLMAyDt8Pcubtex78wFnY87w85ac1xyqtqDEGly/Pv/6pp3/v2zt27JCzs7NtBiBYWFigBw8e9C5duqTu3rFDbdy48dFCoRAYYwxllHTT9dW6lvEsF5heEEIrjaXaDTSWl5FEUaqOaicRK4VEStfh1uu4urCAy3NzqNeXwb0Anu/lYDzPQxD4CAIfvu+hWwZQWkFJaShjtLHcWH79+6995bXXXpvas2ePPnfuXItXq1VVq9WklDIGwD737LPvPLh//+sDAwP/LiOaWQHM/NrrkW4J4jgBMQrFchky8NFud3BpZgbe4mKe0WjahUopkcQJlDagQsAvltKCTcBFCsZ31smyYK6du0bTKmMYBXDt+rXjzz777Lm1mzaR6enpDgDJOp2OAEBnZ2fJ0aNHvampKTk8NLS8Zdu2fX2VSkUqpRih9FY1Myt6IECmA1rj0qzwfXDhw4JAKokoThDFidMiDMA9AREEEJ5wGgGhEJ6An6b0IAjgp2mdUpo2ehpKKkitDOec1mq1Ky88//xf/fCHP7y89/3vl2fPnm0BiFnOMQBCKaWjo6PeSy+9tHTw4EEyVK0+yDinxhjjMK0Kf+6aAiRpKk8bL1g46SnTq9N6JDwfwktVoEzfFnwViL+aBT1P3KZvSymNtZZ1Om385CfvfOU//eEfvnbgwAF7/vz5Zrb5lW3Fq0qlIicnJzujo6MxgOSjv/Vb3567fPllxhiU1kRKabIfzrKY54m0zgQohCEKhRCFMEQYBhC+y06c8ZxlMMrAGYcnBDzfW70vXL0vCIIeMFn7LaU0SmvKKMX83OVXPvLkk/8CwLTb7Xa9Xs+2J1W24UXiOEa5XCbvvvuuTV0vXrp5c+a+3bu3VavVtVJK6whlyrvTjMVY1m26nYRM0M94Gue8a3dBwPOEYxGel1vD972UOYhbYia1TCKtUgqe75PLly+/9V///M//19TU1NWHH35Ynj59utW1O65YN0lPawiZmpqyH3ziCf+V73xn2fP96S0TEzsHBwaHEpm47WuSbgV3CeosZdOMM3DOciBZ/fE8V8Oyxfve6nsv43TdTEC7jCalMlIp+L5PF+bn3/3K3//9F77xwguThw8fNm+88cYKgE66z+rE+ls7uP7+fhJFEd67eNEeOnTIf/Eb37heKJUmN27YsGVgcHBUKUWssdo6y8LC9jByx9tWQXEu4Ameg3LFdZUBZJSmO5NprSGVgpRKK62Z7/vk8tzcO19//vm/+NJf/uVPMjDGmE7XiZN8O6Wn54qiCJVKBXEc4/Lly/bxX/s174Wvfe1qYuRPN2/avKZSqWxglFKllDbGEuIOIKRaBOltN7otl49VQaRHDcr2jZRCoqRVUhlKKTPWYnZm5sTf/s3f/I+//fKX3zl8+LA9c+ZMs91udyqVShzHcfeRGfNzzylUKhWv0WgEQojwscceK7/66qsAsPbbL7/80U3j408ODFaDJIlBKdWMUsoZA3FnFG7vLvNu1+aN46pW4cBYY6x0u37GGMM8z8fSzVp0aWbmm7/xxBPfALB4+PBhnDlzZqVer3cqlUrUaDRuO6fAuoSD7qbfxnGMSqViO52OnZ6e1kePHhVTU1PN57/+9fM777lnslgsVv0gWBf4PlVKEa21O0CRqkMpIyYmU4zSuNCrO+PWbV0qR2WUgrGWCiFoHMdYXFz80cmTJ7/41G//9r8AuHn06FFz7NixlSiKOpVKJb4TmF/lrI/o7+8X9XrdA+AfOXKkdOzYMQGA7Nq1a92ffO5zj01MTBwtVyr3VcrlXOGx1oCA2LQY29tOkhhD3PakJXlrTygaKytoLC+/PT099coXPv/f3vjxj3+8AMAeOXJEHjt2rAUg6u/vT+r1urwTmO6zPr/yaax9+/aFpVIpO07G9+3bt+b3PvWp+yc2bz5Q6evbFQTBmrBQIJzzHgEl3btfnYgSaKXRarVtnMRX6vX62+9NT5/48pe+9KNTp05dAaAOHTpkms1mdOrUqQ6ApFqtJrVa7Vc+jfVLz8tVKhXRaDSE53n+I488El6/fl28/fbb2QGO8tNPPz12/969W+5av35rGIbrfM8b8T2vwjgPGGO+1jpWUsVxEi8nUl6LO52F2ZmZi+fOnZv84he/uACgAcDs2rXLDg8Py+PHj3eSJIkrlYpsNBr/T+flfumJxmq1ymu1Ggfg3XPPPd7Y2Jh37do1ce7cOdL1ADiAcM+ePeXdu3f7/f39olgsspV2WzWWltSZc+ei82fPNgG0uxe4e/duOzIyIufn55N33nknSa2iarXa/9eJxjuB6gZGAfBqtcpSYHzz5s1i7dq1ghAims0mm5qaoisrK93HMW+XCAFSLpftxMSEKZVK2lorFxcX5fT0tASgUiA6O5R0C5A7ggGA/wsUNgydw6F9KAAAAABJRU5ErkJggg==")};
__resources__["/resources/puck.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/redBar.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAAZCAYAAAAc7LQFAAAC7mlDQ1BJQ0MgUHJvZmlsZQAAeAGFVM9rE0EU/jZuqdAiCFprDrJ4kCJJWatoRdQ2/RFiawzbH7ZFkGQzSdZuNuvuJrWliOTi0SreRe2hB/+AHnrwZC9KhVpFKN6rKGKhFy3xzW5MtqXqwM5+8943731vdt8ADXLSNPWABOQNx1KiEWlsfEJq/IgAjqIJQTQlVdvsTiQGQYNz+Xvn2HoPgVtWw3v7d7J3rZrStpoHhP1A4Eea2Sqw7xdxClkSAog836Epx3QI3+PY8uyPOU55eMG1Dys9xFkifEA1Lc5/TbhTzSXTQINIOJT1cVI+nNeLlNcdB2luZsbIEL1PkKa7zO6rYqGcTvYOkL2d9H5Os94+wiHCCxmtP0a4jZ71jNU/4mHhpObEhj0cGDX0+GAVtxqp+DXCFF8QTSeiVHHZLg3xmK79VvJKgnCQOMpkYYBzWkhP10xu+LqHBX0m1xOv4ndWUeF5jxNn3tTd70XaAq8wDh0MGgyaDUhQEEUEYZiwUECGPBoxNLJyPyOrBhuTezJ1JGq7dGJEsUF7Ntw9t1Gk3Tz+KCJxlEO1CJL8Qf4qr8lP5Xn5y1yw2Fb3lK2bmrry4DvF5Zm5Gh7X08jjc01efJXUdpNXR5aseXq8muwaP+xXlzHmgjWPxHOw+/EtX5XMlymMFMXjVfPqS4R1WjE3359sfzs94i7PLrXWc62JizdWm5dn/WpI++6qvJPmVflPXvXx/GfNxGPiKTEmdornIYmXxS7xkthLqwviYG3HCJ2VhinSbZH6JNVgYJq89S9dP1t4vUZ/DPVRlBnM0lSJ93/CKmQ0nbkOb/qP28f8F+T3iuefKAIvbODImbptU3HvEKFlpW5zrgIXv9F98LZua6N+OPwEWDyrFq1SNZ8gvAEcdod6HugpmNOWls05Uocsn5O66cpiUsxQ20NSUtcl12VLFrOZVWLpdtiZ0x1uHKE5QvfEp0plk/qv8RGw/bBS+fmsUtl+ThrWgZf6b8C8/UXAeIuJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACQUlEQVR4Ae3dyUoDQRDG8a+TcsHdg4oXEQ++gyfx+X0AvSp4ESNo3DW2VUnaZYjX9ED+DcNkJoEqfw1F090zJkldP2gIIIAAAu0RyJ5KtnVpf44i3Z5uIRMEEJhpgSR9fkrPm1Lf7qRj11iYaRH+eAQQQKA9Au+eylVPOjd1dCR1Vsa5xbDaCzgNAQQQQGDKAqX+Pvsg+swnn3vpRN3THaXDgfQx5WQIhwACCCDQEPAR8qCr1Dflnm0or+4qrb0pijfD54YVlwgggEAFgbzlhfrA5pUHcxpEeR5V6AqpEBIBBBBA4K+AF+hsi8opJqDfRoPnMgfy95dcIYAAAghMWyDZkodc9eN1FDqxQjjtPiAeAgggMFnAlv2+74XWy+TvuYsAAgggUElgOIJe8+DzlRIgLAIIIIDAZIHhCDoKtD9NSEMAAQQQaJHA9xy0tSgpUkEAAQQQkHwXhxTz0GVxsJzBQQABBBCoK2DxEo7YyVE2QVOg63YI0RFAAIEiYDH3HEW6POdNgS40nBFAAIG6Ap264YmOAAIIIPCfgPlLkoajZ0bQ/xFxHwEEEKgjYNsed8+P/jg+Uxx1OoKoCCCAQFMgttnlmOeIx71joTA+lwVD/0hDAAEEEKgkYPe+wy4e834YJ8AIulJPEBYBBBBoCJgX5o9bv/k4/oIC3RDiEgEEEKgkYP4Wu1v/31d6+pnZoEZX6gzCIoAAAr8FzAvz5YXf8TMNAQQQQKBFAnYjXcccdHndKAuELeodUkEAgZkW+AKo6EXy2hCXpwAAAABJRU5ErkJggg==")};
__resources__["/resources/redPlayerWins.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/rematchButton.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/sblueBar.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAAAUCAYAAAD8+OT/AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJAxAxAp/9Tj0AAACcSURBVHja7dyxDYMwFEVROyCliURBwRAZhM2YJqNRJYgCkMkg75wRXnHl37iO83IXgEAPEwACCCCAABn6UqsVAC9AgKgXYNdOKwCZAVyfkxWAzAC219sKQGYAy92sAIQG8NqtAIQG8BRAIDaAmxWA0AAePysAqQH8WgFIDaATGMg9gf0HCIQGsB1+QwBCA7ivbmAgUi398DEDkOgPFvYcb8hO910AAAAASUVORK5CYII=")};
__resources__["/resources/scenterLine.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAAAECAYAAAD/LuZkAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJAxEPMBctbvcAAACiSURBVFjD7ZfBCsIwEAVnkwqiKPqz/raCp9pu10O2tN6lUHgD75LkFB6TjT3OJRDiDxQLThZcKtwztwrXCscCNc+NwCegn6APeDs8HV7e1oTYrLO6AvEvIgwHxmgZaBkDptUza1m8OQdr6XJPCAlQ7E+AgIfhAUMsInRgPdjNAqyWErRFgkUGFBKg2CtTfnGH+M1agiUlaCm/mlNgZyqk2JYvTzI4jUDJLrMAAAAASUVORK5CYII=")};
__resources__["/resources/score.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/screenshot.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/sideBar.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAHgCAYAAACVcVyXAAAC7mlDQ1BJQ0MgUHJvZmlsZQAAeAGFVM9rE0EU/jZuqdAiCFprDrJ4kCJJWatoRdQ2/RFiawzbH7ZFkGQzSdZuNuvuJrWliOTi0SreRe2hB/+AHnrwZC9KhVpFKN6rKGKhFy3xzW5MtqXqwM5+8943731vdt8ADXLSNPWABOQNx1KiEWlsfEJq/IgAjqIJQTQlVdvsTiQGQYNz+Xvn2HoPgVtWw3v7d7J3rZrStpoHhP1A4Eea2Sqw7xdxClkSAog836Epx3QI3+PY8uyPOU55eMG1Dys9xFkifEA1Lc5/TbhTzSXTQINIOJT1cVI+nNeLlNcdB2luZsbIEL1PkKa7zO6rYqGcTvYOkL2d9H5Os94+wiHCCxmtP0a4jZ71jNU/4mHhpObEhj0cGDX0+GAVtxqp+DXCFF8QTSeiVHHZLg3xmK79VvJKgnCQOMpkYYBzWkhP10xu+LqHBX0m1xOv4ndWUeF5jxNn3tTd70XaAq8wDh0MGgyaDUhQEEUEYZiwUECGPBoxNLJyPyOrBhuTezJ1JGq7dGJEsUF7Ntw9t1Gk3Tz+KCJxlEO1CJL8Qf4qr8lP5Xn5y1yw2Fb3lK2bmrry4DvF5Zm5Gh7X08jjc01efJXUdpNXR5aseXq8muwaP+xXlzHmgjWPxHOw+/EtX5XMlymMFMXjVfPqS4R1WjE3359sfzs94i7PLrXWc62JizdWm5dn/WpI++6qvJPmVflPXvXx/GfNxGPiKTEmdornIYmXxS7xkthLqwviYG3HCJ2VhinSbZH6JNVgYJq89S9dP1t4vUZ/DPVRlBnM0lSJ93/CKmQ0nbkOb/qP28f8F+T3iuefKAIvbODImbptU3HvEKFlpW5zrgIXv9F98LZua6N+OPwEWDyrFq1SNZ8gvAEcdod6HugpmNOWls05Uocsn5O66cpiUsxQ20NSUtcl12VLFrOZVWLpdtiZ0x1uHKE5QvfEp0plk/qv8RGw/bBS+fmsUtl+ThrWgZf6b8C8/UXAeIuJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABR0lEQVR4Ae3SIQ6DQABFwW0JBsP9b4mHQEtF5RN1TWYFK/5iJu+xbds13uc8z3Ecx9j3/Xtf1zXWdR3LsoxpmsY8z5/7fv+8P78cP4YaHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIxKQdOCMSkHDghEJNy4IRATMqBEwIx/VE5L3udGbxDyERYAAAAAElFTkSuQmCC")};
__resources__["/resources/sLeftWall.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAHgCAYAAACsFu3MAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJAxEJFH10LaAAAADySURBVHja7c6xTcRAFATQsb2b4OAoya3SBC24C7KTSEjQSU4WfxLIwfGbZKJ5mqmqKklVVapqGmNkjJHH45HjONJaS2stvffM81y996n3nn3fX7dte5lzMWOMpyTPl4HzPJck7TLwGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfxnO85nk6zKwLMuR5PNfwDRN9dNZ1/Ujyf3yg9vt9p7k7RvheS8D+D9DZQAAAABJRU5ErkJggg==")};
__resources__["/resources/spaddle.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADcAAAA3CAYAAACo29JGAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJAxAnE+nV2xgAABdfSURBVGjetXprjFzned7z3c5lZmd2dmcvJFckl9wlRVKiTFMiKYmSJdJkWCFBAQNWbMRy/c9JZCd2myqpCv9okwJynbYo4jhOEMCJ61iQrcRBVFuWQcmCEJKySZqmKMsmtBdyd7nL6+zOzu1cvlt/nMvOLmVJddoBPsyQM2fP95z39rzP9xK8vxfpeicAaNdi3cv3fR4EQfb/tOv32fU2/WzSzwaA9n3fBEGgAOg1y3Qt23W9fb+b/lVA8RQAX7MEALZp0yZeKpV4pVJhhUKBMsaoEAJSSmitTafTMfV6XTebTTU7O5uBkgDUmqXT9/9rkOR9AltrpQxE93LGx8edTZs2uZRS/otf/ILMz8+Tro2Qd3gnIyMjdufOndYYo2ZnZ6PJyckYQJwC7V7qHaz5rgDJewDL3GotKCdbnHN3z549Xrlc9n74wx/S9KYcgAeg57Hf+I3e7WNjfrlSEaVSUTSXm3K51VITFy92vv/97y8DaAEI083Tw4cPm0ajEZ49ezYEEKVAuwF3g8zc+h0BkvcA1m2tblAeAG/v3r2+7/v+yZMnM+v2PfXUU6N37949tn79+tFCoTAoHKdPCFHkjDmccyGVklobKWXcknG81Ol0bl65Oj/zi59fnPzTL37xMoBFAPbgwYM2CILg3LlzQQo+XANyrRVvA0jeBzAOwCkWi0673fYAeFu3bi1s2LCheOLECQaAHT16dNMTn/zkfZu3bNlb6e3d5nle1S8UIDjP/e+XvZRSaHc6iKOotlSvT8xcunTu777xjbPHjx+fBaAPPPSQvrmw0J6enu68A0j1bgDJewATABzf990gCDwAhT379/fMTU15tVqN7tu3b+NTf/RHj27ZsuVDpVJpa0+xCEIprDHQxoASYgghFiQPMwtYAhDAWlhribGWMkrz61rtNprN5vT09PQ//7cvfenVM2fOzJVKJbNz587w9OnTLQAd3/fDIAiiNVa8DSB5L2Ce53lhGPrFYrF4zz339Lz++usCQM+f/8VfPHzfffs+MjBQ3eZ5HqwxsIClhBhKKWGUEhBCKKUghKx6ihaAtRbGGMBaq42xxhhrrKUEIIRShGGIWq02cebMmX/87JNP/jOA1gMPPCAvXLjQarfbbc/zgjAMw3cD+E6pPkvpbgasWq32jI2NlU+fPs22bNw48pW//uuPj27e/K/Kvb3MaA2SAAJjjDLGQAkBSbCBIHlf+7KwsDZdxsJYC600tNHGGAMLSyllWG409Mzlyy997vd+77mJiYn5AwcOqMnJyWatVmt1AYy6SkdeKtgaYFmMub7vZ8BKO3bsKP/oRz9in/70p3f98TPP/P742NjDnutSa4xhjFnBORWOQzhn4IwhAZhajJBfko6T7yihoDRdjIIxRmhykTFaW8912eDg4PbDH/7wNsrY7P9+4YXa7t27HQB2aWnJ+r5vlVLdWTN/sXcA5hSLRbfT6fjFYrG0Y8eO8uuvv87/3VNP7f3Upz71+Y0bN96plAKjVHMhmOMIwjkHowyZC1q74nbGGGitVy1jTG6124ASkoJMPNQYY7QxpFqtDt+5ffuucm/v7N8///z1Xbt2iXoY2k6jsbaw227LdQMTpVLJbbVaPoDiAw880Hvq1Cn++5///J4nnnji346MjGyWcWwEZxCOQwXnYIyD5aAstE7ASCkRp0vGK+9SKSiloLRKgWbuidzSidVp5t4EsFYpZfv6+vtGR0fvcj1v6jv/8A83Hty/n8/MzJhfwl5uA+dQSj2lVOHQoUPl1157jX/sYx/b9tu/8zufu+OOO7bGUWS4EMRJXZAxDpq6nUo3LaVEHMeI4hhxFCGKY0RxCkzKFHTyW60UtDEwWq+2ZA4seWiUUmJhIWNpeyuV3tHR0bFavf7zl158sb7/oYfY/Ap9WwWQpFkxizM/CILCwYMHKydPniwAGHz11Vc/t33Hjg/FcWwF53Ach2RxBSB3u1gqyDhOACgFrTRU6oKZG2asK90wKKVJjHIGwTmEEBCOA0fwJG5pwre1Tv5WHMdWKgUhBJl4++0Thx599H8AqH3gAx9ov/HGG8sA2gCCLMFkKV+USiW33W5727Zt62k0GsWlpSXvuW9/+yM7d+36CAggKLOO61DGOHgXMCkloihCmK4oihHHyVJKwhidZEbY1F9sUge1htYqzZBJXcwfgrWJi9I0BlOQJPV9bQwplkqbHnr4YPvvv/38WyMjI7TVaqk4jld1ESylUyKOYw+Af/fdd5fOnz/P//A//OEHDh06/Nu9ld4CrNWOcBhnHJzz/GkmwGKEYZQAzEGpNAcTGIsEgE7c0BiTWC91OWNtEntaw1iT1MvcPbHKyhlCa4wWQtBiobipWChc/M53vnP1/vvvpzMzM6toGQPglctlJ4oi774HH+x5/cQJF0D/f/rPf/zJzaOjdyspjeCCCSHAGUs2lFssRhiFCMMYURRDKpncnxLEUYR2s4lWYxmddhNBu42w00EYdBAldAvWmCRuGYU2FtpopHUdIHYli9KVspI+ECKVIoVCoVCtDjj/6+tf/8n1pSW1YXhYLy8vq25wfhRFLgB/dOPG4tzcnHjmmWfu23vvvf/Gd11BCbHCEYQzDkoprLWQSiGO4sQVwxhRFEFrDUIJlJRYXlpCq74EazSKxSL6+/pQHRhAta8P5d5e+K4LYzSiTgedTgeAhRBO6hEmceCUlFKSULMsI2dl0lqrCaWUMz60cfOmiR9873uX9+/fT6enp3POyVGpMNTr/MCBA+6pU6cYgNK9+/Y90tfX52uljOM4NKthuTvGSZxFUWIxnbAUdNodNBZvgTOGDSMjGBweRrlchut54Jzn5UIphSgM0Vhexs3r11Gr1RBHEUq9faCMQkmVejXJY45RCs55/pkxRmMZo9RbLu7bt+9RAD+5ePFic3R01L18+XIIgDGEYQ8Af2xsrDgzMyM++9nP3vnwhz70yUKhUKAEVoikSHe7YxJjicWUUiCEoN1qon7rJiq9vRjfvh2jW7agOjCAQqEAIQRYmmEZYxBCwPd9lHt7Uenrg+t5aDWb6LTbEI4Lymgem5QAKbXL3TPl3cRqoxljFNaWfN9/8wc/+MHC3vvvJ5cmJ6NSqaQoADY+Pi7m5uYYAP7AwYO7S6XSgFYKlHHC0oyVuUyS6iViGUPpBFjQ6aB+6xYGBwawY9cubNy8GcWentzapoutGGNg0oRBKUWxpwebRkdx544dKPoemo06rMnaoaQmSiUzeSK5jiTWo4wRqzUKhcLQAw8+uBsAp0pxAKLZbHIKgA0ODvJLly5RAMUN69fv9DwPhFLDCCEk26Cx0FpBSpUC1IBNivfy4i1UKr0Y274dQ+vW5RnVGJMU96ywR1GSTaWEyjMnwDnH8Pr12LptG1zB0Wk10kxrc2Ig5QqjSZIWBaWUGsAWikUMDQ/fCaDn5ZdfJjt27BAAKAXAKKUMAHn88ccHekqlrRbIGUJmtWSjOr2ZhjHJU2w26mCUYvOWLRgYHMyTjjYGUqmkRIQhgjBEGAbpe4goipJibxJ2QinF0PAw7ti4CVpJyDgCJSR9oDplQCv3pYSAMYq0xUKxp2fTJz7xiWEAZt26dQIAo9VqlXaMYQDInj17hgq+v84mCSLvxVaYiIFKyS8ASBkjbLUxNDyMwaEhCCFyN5RxjCgFEYYhwiBAECTvGbgoDCFjmbsp5xzDw8Oo9PYiCoKEkqXhkN3XZpbLOSiBBVDwvOEP3nvvOgAol8sMAOWFQoGF9ToBQIeGhtZRzj2b1qos8a4wfJXWoiTYg04AzhkGhoZQ7OlZeQhK5SwljmMYY/KHZNOirbSCY5w89kiaCYs9PagODKDRbEIrBS5E130TNsNTBoOkyBNjDAhjhf7+/mEALIoiA4Byr6+fLN+6SQHQgcHBflc4gLWgoKs2lLiahdFZu2IQRyGKxSLK5fJK8kgzqkoBWmvh+35u1cTiEmEYIpYxKKWQSq30dJSi3NsL13EgU3DWWhid3D/bS1dRJ1ZrOELQ/v7+PgBscXFRVioVSj1ryNLSEgCQYrHYw0Uq6pDVCkvSMZs8oI1OLFQoFuH5/ioLa63zhOF5HnzfX1UKfN+H53kw2uTdgemiXdn3Vqu0Y08eWjc1y140rZ2O46BQLBYBkEajQYrFIqG+7yMIgsTnHUdQSkFygWW15ZK/a1eBdV03z465+1qTF3bO+arGNQMhhAAhJCfMpqvlYWmHkAsuJBUmLFa1RolfJr+iSZEXAEiz2UShUMg1/OSnxqzROd5DuyXICfCqa9JNZIHfbf3bxRSbdwLd1iCMvr9TDHvb5vI/RKMosr7vWwBWah0l4kx2wWp2nuxzRVMihCaNZtdDSQKdrIrXVd+tfT6pmISu74wxsNqsqDv5/cgaXSZ3JZKGQgzAlstl2+l0LA3D0Pb391sAptlqt6RUSBr71fpt3l+lWTQL/iiKIKXsSs8krUEM1lrEcZy4GmOZAAQAiKIor2+ZdpJtOuvYM4knu1+mqHXbyKTJJZYSnVarBcCUy2UbBIGhQRCYvr4+A8As3rxxK5YRAJL0Vl2ulfdVjAKEgDIC7jjotNsI05glhIAyBs6Tvo8xhjiO0el0UmaiVv2bdf2Wpu0UAARhiCiKwQVLCTQFYwSUrrZcKg9aQilkHOva4uIiAFWtVu3i4qKhN27c0L7vGwD6xq1b14zSAckSRpfVGKNglCUqF2MgIPC8JBnVl5e7eF+SRIQQcBwnt2673Uar1UK73UYURaCUwnEcCCEScDl/1WjU65BagzGe10FKORjlYKwrxi1grLGEUhhtOstLS9cAqBSPoWEYas65BmDOv/HG9SAMr5HEpaxZ1RVTMJZqHmlNcz0foAw3r19H4hHJRniitcBxHLiuC8d1c1bPGIPjpv+f/iZrZRI618BirQaSPkSQxKV5IveBELpCBpLOFgRAEIc3zr1x4RoANJtNBUBTAJoxpgHY55977laj2ZzKKJQ11pqUoiebZhCCQwiWuihBsVTG0uIiri0s5PFFCIEQAq7rwvO8vNZly/OSOua6bl4SACCOY1y/dg2dIITjugAsGM3uycE56+o0stJiqTEG7Vb78t99/W+vASCXLl2SObhbt27J8fFxDaB1dWHhQhgEsMZQbVe4HKUELNVQMlciIPAKPoTnY252FteuXs37u8yCruvCy0Cmxdlz3aQ+Cp73aEopXF2Yx/Xr1yHcpKcjuYtzcC4SSYKm8WYsjDGGEkLarTauXb36MwCNxx57zE5OTq6Au3jxoly3bp0GIE+cPHmh2WxeY4LDKG1VziUBxmgSS8KBI5KbEULQ01uBtsD0xAQW5udzC2ZumEh2Ao4Qyee0eaWpi8VRhPm5OczNzAGMg6eSg+DZNQ6ESOIt56+J3mkJ5wiCzsLrJ0++0XXELCuVis7ULzo8PMwXFhbE2dOnw49+9KMjg4ODO7XWllJKsrS/imsmlToBTgDHcREEAZZqtYTwcg4uxG3iTne2U0phuV7Hlbk5LCwswDIO1/XyDsF1HLheYnnHcfIyktY0q7SixhhcuTL/6mee/N3v7ty5U87OznaazWYYhmGc6ZZ0YWGBHjp0yLl8+bK6c+dOtXnz5ocLhYJnjDGUUdLdYqzU0Iz3JUHteD600liq3UJjeRlxGKaqsk5kdqUQS5l07vU6ri8s4MrcHOr1ZXDHg+M6OTDHceB5LjzPhes66JY6lFZQUhrKGG0sN5Zf/eErX3vllVem9u7dq8+fP99ORVnJAehqtapqtZqUUkYA2Beefvqt+w8ceLWvr+9fZyQ4K7ZZHDir5G+CKIpBjEKxVIL0XHQ6AS7PzMC5ejXPjDTtrqWUiKMYShtQIeAWe1JyQMBFCsxNrJZl0/wsImmarTKGUQA3bt448fTTT59fv2ULmZ6eDrrPzRkAls6N0NnZWXLs2DFnampKDg4MLI9v376/t1wuS6UUI5SuVYGzAguS9vQArElSt3BdcOHCgkAqiTCKEUZxor0YgDsCwvMgHJFoIoRCOAJuWiY8z4OblgpKadq0aiipILUynHNaq9WuPffss3/+4x//+Mq+D35Qnjt3LrdaJqd3D8AQSikdHh52XnjhhaVDhw6RgWr1fsY5NcaYBN+KSJq8p2BJWh7SJhIWiRyX6f9pvROOC+Gkalh2XiD4Cih3JZs6jrjtvEBKaay1LAg6+NnP3vrav/+DP3jl4MGD9sKFC62ug8g8W2bauiqXy3JiYiIYHh6OAMQf/83f/O7clSsvMsagtCZSSpPdJMuGjiPSOuah4PsoFHwUfB++70G4SZbjjOfshlEGzjgcIeC4zsp1/sp1nuetApZJDFJKo7SmjFLMz1156WOPP/5PAEyn0+nU6/WwawggPyvIuDeJogilUom8/fbbNnXPaGlxceaePXu2V6vV9VJKm5DdtD9IMx9jWRednNhkhyUZb+Scd53iCDhOQs1cx8mt5LpOyljEmhhLLRZLq5SC47rkypUrb/yXP/mT/zk1NXX9wQcflGfOnGl3TTmsktNXvdIaRaampuyHH3vMfel731t2XHd6fGxsV39f/0As42QMgaTH+F2HFSxl/YwzcM5yUFl9c5ykRmZAXGfls5NxzG4GopPMKKUyUim4rksX5uff/trf/M2XvvXccxNHjhwxr732WrPr2Kr74D8/E1/1qlQqJAxDXJqctIcPH3af/9a3bhZ6eiY2b9o03tffP6yUItZYbdN4tbCrOoeER64A5FzAETwHmBTyFeaR0arujKi1hlQKUiqttGau65Irc3NvffPZZ//0K3/2Zz/LgBljgq5JI909NsXeqb8OwxDlchlRFOHKlSv20V/7Nee5b3zjemzkz7du2bquXC5vYpRSpZQ2xhKSDJik2gtZ3SJ1WzRfK2LQKlUsO7dTCrGSVkllKKXMWIvZmZmTf/WXf/nf/+qrX33ryJEj9uzZs61OpxOUy+UoiiK5ZuDGrh3VuG0OpVwuO41GwxNC+I888kjp5ZdfBoD1333xxY9vGR19vK+/6sVxBEqpZpRSzhhIMoNye9dMuiYSLdZoMwkwa4yVyWmsMcYwx3GxtFgLL8/MfPvXH3vsWwCuHjlyBGfPnm3W6/WgXC6HjUbjl86hsDUTRN0ih42iCGlXa6enp/WxY8fE1NRU69lvfvPCrrvumigWi1XX8zZ4rkuVUkRrnQzLpCpZytyJyZSzNI70yoSDTY6XVUKnlIKxlgohaBRFuHr16k9OnTr15Sd+67f+CcDisWPHzPHjx5thGAblcjl6N2Dvd/ZLVCoVUa/XHQDu0aNHe44fPy4AkN27d2/4j1/4wiNjY2PHSuXyPeVSKVe6rDUgIDYt/Pa2CSJjSHKEbEkuXxCKRrOJxvLym9PTUy996Yv/9bWf/vSnCwDs0aNH5fHjx9sAwkqlEtfrdfluwH7lqb39+/f7PT092Qgi379//7rf/cxn7h3buvVgubd3t+d56/xCgXDOV4lH6TzGyo0ogVYa7XbHRnF0rV6vv3lpevrkV7/ylZ+cPn36GgB1+PBh02q1wtOnTwcA4mq1GtdqtV9pau895y3L5bJoNBrCcRz3oYce8m/evCnefPPNLDmVnnzyyZF79+0bv2Pjxm2+729wHWfIdZwy49xjjLla60hJFUVxtBxLeSMKgoXZmZnJ8+fPT3z5y19eANAAYHbv3m0HBwfliRMngjiOo3K5LBuNxr943vI9J2Wr1Sqv1WocgHPXXXc5IyMjzo0bN8T58+dJ18PgAPy9e/eW9uzZ41YqFVEsFlmz01GNpSV19vz58MK5cy0Ane7N7tmzxw4NDcn5+fn4rbfeilNrqVqt9v9sUvZ9zThXq1WWguRbt24V69evF4QQ0Wq12NTUFG02m90jv3gH8ZSUSiU7NjZmenp6tLVWXr16VU5PT8tUxVK1Wu3/y4zzrzSdDoCPj4+z/v5+5jgO1VozrTXxfT8jNjYIAjDGLGNMx3FsFhcX9eTkpF7jcv/i6fT/A1l+9p7nxVTUAAAAAElFTkSuQmCC")};
__resources__["/resources/spuck.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/sredBar.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAAAWCAYAAACxMEX0AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJAxA5IxtN1GsAAACtSURBVHja7dsxCsJAFEXR+ckohmhjo1t0Ze5LSCmIWCkhLuSds4RXXP4QUq3q3gAC1W2qpxmARP3at7MZgMgA9mqbGYDIAM5DKzMAkQE8DUYAQgN4HI0ApAbQBQgIIEBYAGdPYCA1gJNvwEBqAA+ewEBqAPcuQCCU+w/IvQBXP8IBqQG87IwAhAbQRxAgNoCf1QhAaADfAgikBvAlgEBqAJefEYDQAD6+RgAy/QFq8hCndrq7RQAAAABJRU5ErkJggg==")};
__resources__["/resources/sRightWall.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAHgCAYAAACsFu3MAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJAxEJLFV2lT4AAADySURBVHja7d2xUcUwAETBk63kY8+YdtwCBZDSqishY4aEhIRAQiahAb5D9hWwcx1cSfJ8HMfLvu9PrbW01s4xRmmtpfee3ntut1vWdU2tNbXWlFLOUkqSlCnJY+/9IXc2JaljjPkKcCkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/hvwPU3TuAJ8zvP8dQV4W5bl4/ctOaWU86/A67Zt7/cu+AEN1Sqp0GY4rAAAAABJRU5ErkJggg==")};
__resources__["/resources/titleSplash.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};/*globals module exports resource require window Module __main_module_name__ __resources__*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

function resource(path) {
    return __resources__[path].data;
}

(function () {
    var process = {};
    var modulePaths = ['/__builtin__', '/__builtin__/libs', '/libs', '/'];

    var path; // Will be loaded further down

    function resolveModulePath(request, parent) {
        // If not a relative path then search the modulePaths for it
        var start = request.substring(0, 2);
        if (start !== "./" && start !== "..") {
            return modulePaths;
        }

        var parentIsIndex = path.basename(parent.filename).match(/^index\.js$/),
            parentPath    = parentIsIndex ? parent.id : path.dirname(parent.id);

        // Relative path so searching inside parent's directory
        return [path.dirname(parent.filename)];
    }

    function findModulePath(id, dirs) {
        if (id.charAt(0) === '/') {
            dirs = [''];
        }
        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            var p = path.join(dir, id);

            // Check for index first
            if (path.exists(path.join(p, 'index.js'))) {
                return path.join(p, 'index.js');
            } else if (path.exists(p + '.js')) {
                return p + '.js';
            }
        }

        return false;
    }

    function loadModule(request, parent) {
        parent = parent || process.mainModule;

        var paths    = resolveModulePath(request, parent),
            filename = findModulePath(request, paths);

        if (filename === false) {
            throw "Unable to find module: " + request;
        }


        if (parent) {
            var cachedModule = parent.moduleCache[filename];
            if (cachedModule) {
                return cachedModule;
            }
        }

        //console.log('Loading module: ', filename);

        var module = new Module(filename, parent);

        // Assign main module to process
        if (request == __main_module_name__ && !process.mainModule) {
            process.mainModule = module;
        }

        // Run all the code in the module
        module._initialize(filename);

        return module;
    }

    function Module(id, parent) {
        this.id = id;
        this.parent = parent;
        this.children = [];
        this.exports = {};

        if (parent) {
            this.moduleCache = parent.moduleCache;
            parent.children.push(this);
        } else {
            this.moduleCache = {};
        }
        this.moduleCache[this.id] = this;

        this.filename = null;
        this.dirname = null;
    }

    Module.prototype._initialize = function (filename) {
        var module = this;
        function require(request) {
            return loadModule(request, module).exports;
        }

        this.filename = filename;

        // Work around incase this IS the path module
        if (path) {
            this.dirname = path.dirname(filename);
        } else {
            this.dirname = '';
        }

        require.paths = modulePaths;
        require.main = process.mainModule;

        __resources__[this.filename].data.apply(this.exports, [this.exports, require, this, this.filename, this.dirname]);

        return this;
    };

    // Manually load the path module because we need it to load other modules
    path = (new Module('path'))._initialize('/__builtin__/path.js').exports;

    var util = loadModule('util').exports;
    util.ready(function () {
        // Populate globals
        var globals = loadModule('global').exports;
        for (var x in globals) {
            if (globals.hasOwnProperty(x)) {
                window[x] = globals[x];
            }
        }

        process.mainModule = loadModule(__main_module_name__);
        if (process.mainModule.exports.main) {
            process.mainModule.exports.main();
        }

        // Add a global require. Useful in the debug console.
        window.require = function require(request, parent) {
            return loadModule(request, parent).exports;
        };
        window.require.main = process.mainModule;
        window.require.paths = modulePaths;

    });
})();

// vim:ft=javascript

})();
